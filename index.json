[{
    "title": "Archives",
    "date": "June 11, 2020",
    "description": "",
    "body": "",
    "ref": "/archives/"
  },{
    "title": "ROS In Docker Container",
    "date": "May 7, 2020",
    "description": "",
    "body": "ROS (Robot Operating System) - Documentation - http://wiki.ros.org/\nIn this example I use docker image of ROS Melodic and a Dockerfile for creating the required docker container. Python3 (python3.7) is also installed in this example.\nPlease refer https://docs.docker.com/get-started/ for more information on Dockers.\n  Pull the docker image for ROS Melodic\n docker pull ros:melodic    Creating the Dockerfile FROM ros:melodic MAINTAINER dhanoopbhaskar@gmail.com RUN apt-get update \u0026amp;\u0026amp; apt-get upgrade -y \\ \u0026amp;\u0026amp; apt-get install -y software-properties-common \\ \u0026amp;\u0026amp; add-apt-repository ppa:deadsnakes/ppa \\ \u0026amp;\u0026amp; apt-get install -y python3.7 RUN apt-get update \u0026amp;\u0026amp; apt-get install -y \\ python-pip \\ python3-pip \\ python3-all-dev RUN apt-get install -y \\ python3-rospkg* RUN apt-get update --fix-missing RUN dpkg --configure -a RUN apt-get install -f RUN apt-get install -y \\ ros-melodic-desktop-full --fix-missing RUN apt-get install -y python-catkin-tools RUN apt-get install --no-install-recommends --no-install-suggests -y \\ build-essential \\ cmake \\ python3.7-dev \\ \u0026amp;\u0026amp; rm -rf /var/lib/apt/lists/* RUN python -m pip install --upgrade pip RUN python2 -m pip install --upgrade pip RUN python3 -m pip install --upgrade pip RUN pip3 install --upgrade pip RUN pip3 install --upgrade setuptools RUN python3.7 -m pip install --upgrade pip RUN python3.7 -m pip install --upgrade setuptools    Now create the docker using this Dockerfile and run ðŸ˜Š (Refer documentation for more information).\n  ",
    "ref": "/blog/2020-05-07-ros-in-docker-container/"
  },{
    "title": "Working With Python 3 In ROS Kinetic Or Melodic",
    "date": "May 7, 2020",
    "description": "",
    "body": "ROS (Robot Operating System) - Documentation - http://wiki.ros.org/\n The Robot Operating System (ROS) is a flexible framework for writing robot software. It is a collection of tools, libraries, and conventions that aim to simplify the task of creating complex and robust robot behavior across a wide variety of robotic platforms. â€” https://www.ros.org/ 1 ROS (upto Melodic) officially supports only python2 and NOT python3. However some libraries we use in our projects (eg. Speech Recognition using Google Cloud Speech) may require python3 to run.\nIf ROS needs to support python3 we may have to recompile ROS source code using python3 which is not practical.\nSo what we can do is to run python3 programs, separately and connect using ROS bridge. (if we use custom messages (ROS msg)\nHowever, if we are not using any custom rosmsg and using only built-in rosmsg, we can do the following steps to run python3 codes in ROS (without using a ROS bridge.)\nInstall ROS (here I install Melodic)\n apt install ros-melodic-desktop-full  After installing ROS, install rospkg for python3\n apt install python3-pip python3-all-dev python3-rospkg  This will prompt to install python3-rospkg and to remove ROS packages (already installed). Select Yes for that prompt. This will remove ROS packages and we will have to re-install them.\n apt install ros-melodic-desktop-full --fix-missing  This will complete the installation part. Now comes the coding part.\nJust include the following directive as the first line of your program code (file) which should be executed using python3.\n #!/usr/bin/env python3  We can now execute everything as we do normally in ROS. Read the documentation (link is given above) for more information on ROS.\n  https://www.ros.org/ \u0026#x21a9;\u0026#xfe0e;\n   ",
    "ref": "/blog/2020-05-07-working-with-python-3-in-ros-kinetic-or-melodic/"
  },{
    "title": "Biped Walking Robot",
    "date": "October 28, 2019",
    "description": "",
    "body": "We, a team of 3, attended a course titled \u0026ldquo;2 Mechatronics Project\u0026rdquo; conducted by Skyfi Labs in the month of October 2019. Thought of sharing the assignments done as a part of the course.\nBiped Walking Robot\n  ",
    "ref": "/blog/2019-10-28-biped-walking-robot/"
  },{
    "title": "Robotic Arm",
    "date": "October 28, 2019",
    "description": "",
    "body": "We, a team of 3, attended a course titled \u0026ldquo;2 Mechatronics Project\u0026rdquo; conducted by Skyfi Labs in the month of October 2019.Â Thought of sharing the assignments done as a part of the course.\nRobotic Arm\n  ",
    "ref": "/blog/2019-10-28-robotic-arm/"
  },{
    "title": "7 Robots in 6 Days",
    "date": "October 28, 2019",
    "description": "",
    "body": "7 Robots in 6 Days\nWe, a team of 3, attended a course titled \u0026ldquo;7 Robots in 6 Days\u0026rdquo; conducted by Skyfi Labs in the month of June 2019. Thought of sharing the assignments done as a part of the course.\n1. Line Follower Robot using Arduino\n  2. Obstacle Avoider Robot using Arduino\n  3. Obstacle Follower Robot using Arduino\n  4. Gesture Based Robotics\n  5. Mobile Controlled Robot\n  6. Swarm Robotics\n  7. Maze Solver Robot using Arduino\n  ",
    "ref": "/blog/2019-10-28-7-robots-in-6-days/"
  },{
    "title": "About",
    "date": "February 28, 2019",
    "description": "the insane techie",
    "body": "A technical blog which covers mainly Java technologies. Other programming languages are also covered.\n",
    "ref": "/about/"
  },{
    "title": "Pencils",
    "date": "January 28, 2019",
    "description": "A few of my pencil sketches",
    "body": "    26th July 2012\n      17th Sept 2013\n      14th April 2015\n      22nd February 2016\n      20th February 2018\n      23rd July 2018\n      27th January 2019\n    ",
    "ref": "/pencils/"
  },{
    "title": "Mounting an iPhone to Linux Mint as an external drive to copy images and videos",
    "date": "July 2, 2018",
    "description": "",
    "body": "Phone: iPhone SE\nOperating System: Linux MintÂ 18.1(should work in Ubuntu as well)\nIt is done by compiling most of the sources yourself.\nOnly one library - usbmuxd - must be installed as root\nAll others are installed in the home account.\nInstall necessary software for building the source packages.\nTo check-out and compile the needed packages from source, you have to install git first.\nOpen a terminal and do the following:\n:~$ sudo apt-get install -y git :~$ sudo apt-get install -y build-essential :~$ sudo apt-get install -y libtool m4 automake :~$ sudo apt-get install -y libfuse-dev  All new commands to mount and unmount the file-system of your iPhone, will be installed in the sub-directory ${HOME}/usr/bin/.\nCreate the sub-directory to store the source files of the packages to be compiled:\n:~$ mkdir -p \u0026quot;$HOME/usr/src\u0026quot;  Set all required environment variables to ensure to build the packages from source as desired:\n:~$ export PKG_CONFIG_PATH=\u0026quot;${HOME}/usr/lib/pkgconfig:${PKG_CONFIG_PATH}\u0026quot; :~$ export CPATH=\u0026quot;${HOME}/usr/include:${CPATH}\u0026quot; :~$ export MANPATH=\u0026quot;${HOME}/usr/share/man:${MANPATH}\u0026quot; :~$ export PATH=\u0026quot;${HOME}/usr/bin:${PATH}\u0026quot; :~$ export LD_LIBRARY_PATH=\u0026quot;${HOME}/usr/lib:${LD_LIBRARY_PATH}\u0026quot;  Now put the last two export statements into your .bashrc, to be loaded every time you open a new terminal, otherwise you must type:\n:~$ export PATH=\u0026quot;${HOME}/usr/bin:${PATH}\u0026quot; :~$ export LD_LIBRARY_PATH=\u0026quot;${HOME}/usr/lib:${LD_LIBRARY_PATH}\u0026quot;  whenever you open a new terminal.\nClone all needed repositories from Github.\n:~$ cd ~/usr/src :~$ for x in libplist libusbmuxd usbmuxd libimobiledevice ifuse; do git clone https://github.com/libimobiledevice/${x}.git;done  Build and install the packages in the following order.\nBuild libplist\n:~$ cd ~/usr/src/libplist :~$ ./autogen.sh --prefix=\u0026quot;$HOME/usr\u0026quot; :~$ make \u0026amp;\u0026amp; make install  Build libusbmuxd\n:~$ cd ~/usr/src/libusbmuxd :~$ ./autogen.sh --prefix=\u0026quot;$HOME/usr\u0026quot; :~$ make \u0026amp;\u0026amp; make install  Build libimobiledevice\n:~$ cd ~/usr/src/libimobiledevice :~$ ./autogen.sh --prefix=\u0026quot;$HOME/usr\u0026quot; :~$ make \u0026amp;\u0026amp; make install  Build usbmuxd\n(The package usbmuxd must be installed with administrative rights, because it needs write access to /lib/udev/rules.d and /lib/systemd/system)\n:~$ cd ~/usr/src/usbmuxd :~$ ./autogen.sh --prefix=\u0026quot;$HOME/usr\u0026quot; :~$ make \u0026amp;\u0026amp; sudo make install  Build ifuse\n:~$ cd ~/usr/src/ifuse :~$ ./autogen.sh --prefix=\u0026quot;$HOME/usr\u0026quot; :~$ make \u0026amp;\u0026amp; make install  TESTING\nIt\u0026rsquo;s assumed that you put the two exports into your ~/.bashrc as mentioned above.\nOpen a new terminal. Connect your iPhone. Create a mount point, where you want the content of your iPhone to appear.\n:~$ mkdir -p ~/usr/mnt  Connect your iPhone to the computer and try to pair the iPhone with your computer.\n:~$ idevicepair pair  If error occurs during validation, please enter the passcode on the device and retry. A trust dialog will be appeared on your device. You have to accept it as well\n:~$ idevicepair pair  After successfully pairing the device, mount the file-system of your iPhone and check the content\n:~$ ifuse ~/usr/mnt/ :~$ ls ~/usr/mnt/  To safely disconnect your iPhone, you have to unmount the file-system in ~/usr/mnt first with fusermount.\n:~$ fusermount -u ~/usr/mnt  Now, you can plug-off your iPhone again.\nERRORS AND SOLUTIONS\n(1) configure: error: OpenSSL support explicitly requested but OpenSSL could not be found\n:~$ sudo apt-get install libssl-dev  (2) configure: error: Could not link test program to Python. Maybe the main Python library has been installed in some non-standard library path. If so, pass it to configure, via the LDFLAGS environment variable.\nExample: ./configure LDFLAGS=\u0026rdquo;-L/usr/non-standard-path/python/lib\u0026rdquo;\n(You probably have to install the development version of the Python package for your distribution.Â The exact name of this package varies among them.)\n:~$ sudo apt-get install python-dev  ",
    "ref": "/blog/2018-07-02-mounting-an-iphone-to-linux-mint-as-an-external-drive-to-copy-images-and-videos/"
  },{
    "title": "RESTful Web Services in Java",
    "date": "August 22, 2016",
    "description": "",
    "body": "Read about REST here\u0026hellip;\nIn the example program REST is implemented using Jersey Framework.\nDownload Jersey framework from here\u0026hellip;\nI used Dynamic Web Project in Eclipse for coding. Extract jersey zip file and copy all the .jar files from api, ext, lib folders to WebContent/WEB-INF/lib folder.\nEmployee.java\npackage in.theinsanetechie.rest; import java.io.Serializable; import javax.xml.bind.annotation.XmlElement; import javax.xml.bind.annotation.XmlRootElement; @XmlRootElement(name = \u0026#34;employee\u0026#34;) public class Employee implements Serializable { private static final long serialVersionUID = 1L; private int empcode; private String name; private String designation; private float basicpay; public Employee() { } public Employee(int empcode, String name, String designation, float basicpay) { super(); this.empcode = empcode; this.name = name; this.designation = designation; this.basicpay = basicpay; } public int getEmpcode() { return empcode; } @XmlElement public void setEmpcode(int empcode) { this.empcode = empcode; } public String getName() { return name; } @XmlElement public void setName(String name) { this.name = name; } public String getDesignation() { return designation; } @XmlElement public void setDesignation(String designation) { this.designation = designation; } public float getBasicpay() { return basicpay; } @XmlElement public void setBasicpay(float basicpay) { this.basicpay = basicpay; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Employee other = (Employee) obj; if (Float.floatToIntBits(basicpay) != Float.floatToIntBits(other.basicpay)) return false; if (designation == null) { if (other.designation != null) return false; } else if (!designation.equals(other.designation)) return false; if (empcode != other.empcode) return false; if (name == null) { if (other.name != null) return false; } else if (!name.equals(other.name)) return false; return true; } } EmployeeAccessObject.java\npackage in.theinsanetechie.rest; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.ArrayList; import java.util.List; public class EmployeeAccessObject { private String fileName = \u0026#34;Employee.dat\u0026#34;; @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public List getFullList() { List list = null; File file = new File(fileName); try { if (file.exists()) { FileInputStream fileInputStream = new FileInputStream(file); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); list = (List) objectInputStream.readObject(); objectInputStream.close(); } else { Employee employee = new Employee(1001, \u0026#34;The Insane Techie\u0026#34;, \u0026#34;Dev\u0026#34;, 99999.99f); list = new ArrayList(); list.add(employee); saveList(list); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } return list; } public Employee get(int empcode) { List list = getFullList(); for (Employee temp : list) { if (temp.getEmpcode() == empcode) { return temp; } } return null; } public boolean addToList(Employee emp) { List list = getFullList(); boolean exists = false; for (Employee temp : list) { if (temp.getEmpcode() == emp.getEmpcode()) { exists = true; break; } } if (!exists) { list.add(emp); saveList(list); return true; } return false; } public boolean updateList(Employee emp) { List list = getFullList(); for (Employee temp : list) { if (temp.getEmpcode() == emp.getEmpcode()) { int index = list.indexOf(temp); list.set(index, emp); saveList(list); return true; } } return false; } public boolean deleteFromList(int empcode) { List list = getFullList(); for (Employee temp : list) { if (temp.getEmpcode() == empcode) { int index = list.indexOf(temp); list.remove(index); saveList(list); return true; } } return false; } private void saveList(List list) { File file = new File(fileName); try { FileOutputStream fileOutputStream = new FileOutputStream(file); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(list); objectOutputStream.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } } EmployeeService.java\npackage in.theinsanetechie.rest; import java.io.IOException; import java.util.List; import javax.servlet.http.HttpServletResponse; import javax.ws.rs.Consumes; import javax.ws.rs.DELETE; import javax.ws.rs.FormParam; import javax.ws.rs.GET; import javax.ws.rs.OPTIONS; import javax.ws.rs.POST; import javax.ws.rs.PUT; import javax.ws.rs.Path; import javax.ws.rs.PathParam; import javax.ws.rs.Produces; import javax.ws.rs.core.Context; import javax.ws.rs.core.MediaType; @Path(\u0026#34;/EmployeeService\u0026#34;) public class EmployeeService { EmployeeAccessObject accessObject = new EmployeeAccessObject(); private static final String SUCCESS = \u0026#34;success\u0026#34;; private static final String FAILURE = \u0026#34;failure\u0026#34;; @GET @Path(\u0026#34;/employees\u0026#34;) @Produces(MediaType.APPLICATION_XML) public List getFullList() { return accessObject.getFullList(); } @GET @Path(\u0026#34;/employees/{empcode}\u0026#34;) @Produces(MediaType.APPLICATION_XML) public Employee get(@PathParam(\u0026#34;empcode\u0026#34;) int empcode) { return accessObject.get(empcode); } @PUT @Path(\u0026#34;/employees\u0026#34;) @Produces(MediaType.APPLICATION_XML) @Consumes(MediaType.APPLICATION_FORM_URLENCODED) public String add(@FormParam(\u0026#34;empcode\u0026#34;) int empcode, @FormParam(\u0026#34;name\u0026#34;) String name, @FormParam(\u0026#34;designation\u0026#34;) String designation, @FormParam(\u0026#34;basicpay\u0026#34;) float basicpay, @Context HttpServletResponse servletResponse) throws IOException { Employee emp = new Employee(empcode, name, designation, basicpay); boolean result = accessObject.addToList(emp); if (result == true) { return SUCCESS; } return FAILURE; } @POST @Path(\u0026#34;/employees\u0026#34;) @Produces(MediaType.APPLICATION_XML) @Consumes(MediaType.APPLICATION_FORM_URLENCODED) public String update(@FormParam(\u0026#34;empcode\u0026#34;) int empcode, @FormParam(\u0026#34;name\u0026#34;) String name, @FormParam(\u0026#34;designation\u0026#34;) String designation, @FormParam(\u0026#34;basicpay\u0026#34;) float basicpay, @Context HttpServletResponse servletResponse) throws IOException { Employee emp = new Employee(empcode, name, designation, basicpay); boolean result = accessObject.updateList(emp); if (result == true) { return SUCCESS; } return FAILURE; } @DELETE @Path(\u0026#34;/employees/{empcode}\u0026#34;) @Produces(MediaType.APPLICATION_XML) public String deleteUser(@PathParam(\u0026#34;empcode\u0026#34;) int empcode) { boolean result = accessObject.deleteFromList(empcode); if (result == true) { return SUCCESS; } return FAILURE; } @OPTIONS @Path(\u0026#34;/employees\u0026#34;) @Produces(MediaType.APPLICATION_XML) public String getSupportedOperations() { return \u0026#34;GET, PUT, POST, DELETE\u0026#34;; } }  WebServiceTester.java\npackage in.theinsanetechie.rest; import java.util.List; import javax.ws.rs.client.Client; import javax.ws.rs.client.ClientBuilder; import javax.ws.rs.client.Entity; import javax.ws.rs.core.Form; import javax.ws.rs.core.GenericType; import javax.ws.rs.core.MediaType; public class WebServiceTester { private Client client; private String REST_SERVICE_URL = \u0026#34;http://localhost:8080/EmployeeManagement/rest/EmployeeService/employees\u0026#34;; private static final String SUCCESS = \u0026#34;success\u0026#34;; private static final String PASS = \u0026#34;pass\u0026#34;; private static final String FAIL = \u0026#34;fail\u0026#34;; private void init() { this.client = ClientBuilder.newClient(); } public static void main(String[] args) { WebServiceTester tester = new WebServiceTester(); tester.init(); tester.testGetFullList(); tester.testGet(); tester.testUpdate(); tester.testAdd(); tester.testDelete(); } private void testGetFullList(){ GenericType\u0026gt; list = new GenericType\u0026gt;() {}; List employees = client .target(REST_SERVICE_URL) .request(MediaType.APPLICATION_XML) .get(list); String result = PASS; if(employees.isEmpty()){ result = FAIL; } System.out.println(\u0026#34;Test case name: testGetFullList, Result: \u0026#34; + result ); } private void testGet() { Employee sampleEmp = new Employee(); sampleEmp.setEmpcode(1001); Employee emp = client.target(REST_SERVICE_URL).path(\u0026#34;/{empcode}\u0026#34;).resolveTemplate(\u0026#34;empcode\u0026#34;, 1001) .request(MediaType.APPLICATION_XML).get(Employee.class); String result = FAIL; if (sampleEmp != null \u0026amp;\u0026amp; sampleEmp.getEmpcode() == emp.getEmpcode()) { result = PASS; } System.out.println(\u0026#34;Test case name: testGet, Result: \u0026#34; + result); } private void testUpdate() { Form form = new Form(); form.param(\u0026#34;empcode\u0026#34;, \u0026#34;1001\u0026#34;); form.param(\u0026#34;name\u0026#34;, \u0026#34;Dhanoop Bhaskar\u0026#34;); form.param(\u0026#34;designation\u0026#34;, \u0026#34;Computer Scientist\u0026#34;); form.param(\u0026#34;basicpay\u0026#34;, \u0026#34;100000.00f\u0026#34;); String callResult = client.target(REST_SERVICE_URL).request(MediaType.APPLICATION_XML) .post(Entity.entity(form, MediaType.APPLICATION_FORM_URLENCODED_TYPE), String.class); String result = PASS; if (!SUCCESS.equals(callResult)) { result = FAIL; } System.out.println(\u0026#34;Test case name: testUpdate, Result: \u0026#34; + result); } private void testAdd() { Form form = new Form(); form.param(\u0026#34;empcode\u0026#34;, \u0026#34;1002\u0026#34;); form.param(\u0026#34;name\u0026#34;, \u0026#34;The Insane Techie\u0026#34;); form.param(\u0026#34;designation\u0026#34;, \u0026#34;Computer Scientist\u0026#34;); form.param(\u0026#34;basicpay\u0026#34;, \u0026#34;100000.00f\u0026#34;); String callResult = client.target(REST_SERVICE_URL).request(MediaType.APPLICATION_XML) .put(Entity.entity(form, MediaType.APPLICATION_FORM_URLENCODED_TYPE), String.class); String result = PASS; if (!SUCCESS.equals(callResult)) { result = FAIL; } System.out.println(\u0026#34;Test case name: testAdd, Result: \u0026#34; + result); } private void testDelete() { String callResult = client.target(REST_SERVICE_URL).path(\u0026#34;/{empcode}\u0026#34;).resolveTemplate(\u0026#34;empcode\u0026#34;, 1002) .request(MediaType.APPLICATION_XML).delete(String.class); String result = PASS; if (!SUCCESS.equals(callResult)) { result = FAIL; } System.out.println(\u0026#34;Test case name: testDelete, Result: \u0026#34; + result); } } web.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns=\u0026#34;http://java.sun.com/xml/ns/javaee\u0026#34; xsi:schemaLocation=\u0026#34;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\u0026#34; id=\u0026#34;WebApp_ID\u0026#34; version=\u0026#34;3.0\u0026#34;\u0026gt; \u0026lt;display-name\u0026gt;Employee Management\u0026lt;/display-name\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;Jersey RESTful Application\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.glassfish.jersey.servlet.ServletContainer\u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;jersey.config.server.provider.packages\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;in.theinsanetechie.rest\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;Jersey RESTful Application\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/rest/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt; ",
    "ref": "/blog/2016-08-22-restful-web-services-in-java/"
  },{
    "title": "Installing and Configuring phpMyAdmin in Ubuntu/Linux Mint",
    "date": "March 9, 2016",
    "description": "",
    "body": "Install phpmyadmin\nsudo apt-get install phpmyadmin  Configure phpmyadmin\nsudo dpkg-reconfigure -plow phpmyadmin  Then select Apache 2 for the webserver you wish to configure.\nTry hitting the URL http://localhost/phpmyadmin/\nIf this does not work, then you have to include the phpMyAdmin-shipped Apache configuration into Apache:\nsudo ln -s /etc/phpmyadmin/apache.conf /etc/apache2/conf.d/phpmyadmin.conf sudo /etc/init.d/apache2 reload  Since Ubuntu 13.10 (Saucy Salamander), Apache no longer loads configuration files from the /etc/apache2/conf.d directory.\nInstead, they are placed in the /etc/apache2/conf-available directory which is managed with the a2enconf command.\nTherefore, if you need to manually include the phpMyAdmin-shipped Apache configuration file, you must run the following:\nsudo ln -s /etc/phpmyadmin/apache.conf /etc/apache2/conf-available/phpmyadmin.conf sudo a2enconf phpmyadmin sudo /etc/init.d/apache2 reload  ",
    "ref": "/blog/2016-03-09-installing-and-configuring-phpmyadmin-in-ubuntu-linux-mint/"
  },{
    "title": "DNS Lookup - Implementation in C",
    "date": "February 14, 2016",
    "description": "",
    "body": "Read about DNS here\u0026hellip;\nDNS Lookup - Implementation in C\n/**dnsclient.c**/ #include\u0026#34;stdio.h\u0026#34;  #include\u0026#34;stdlib.h\u0026#34;  #include\u0026#34;sys/types.h\u0026#34;  #include\u0026#34;sys/socket.h\u0026#34;  #include\u0026#34;string.h\u0026#34;  #include\u0026#34;netinet/in.h\u0026#34;  #include\u0026#34;netdb.h\u0026#34; #include\u0026#34;arpa/inet.h\u0026#34; #define BUF_SIZE 512  #define SERVER \u0026#34;8.8.8.8\u0026#34;  #define PORT 53  #define WIDTH 16  int createSocket(); void createRequest(char * url); void hexdump (char *desc, void *addr, int len); void lookUp(); struct query { uint16_t length; char * url; unsigned char request[BUF_SIZE]; uint16_t reqType; }; struct query dnsQuery = { .length = 12, .url = \u0026#34;\u0026#34;, .reqType = 0x01, .request = { 0xDB, 0x42, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } }; int main(int argc, char** argv) { char * url; if (argc != 2) { fprintf(stderr,\u0026#34;usage: %s hostnameToResolve\\n\u0026#34;, argv[0]); exit(1); } url = argv[1]; createRequest(url); lookUp(); } int createSocket() { int sockfd; sockfd = socket(AF_INET, SOCK_DGRAM, 0); if (sockfd \u0026lt; 0) { printf(\u0026#34;Error creating socket!\\n\u0026#34;); exit(1); } //printf(\u0026#34;Socket created...\\n\u0026#34;);  return sockfd; } void createRequest(char * url) { char * word; int i; printf(\u0026#34;Asking DNS server %s about %s\\n\u0026#34;, SERVER, url); dnsQuery.url = strdup(url); dnsQuery.reqType = 0x01; word = strtok(url, \u0026#34;.\u0026#34;); while (word) { printf(\u0026#34;parsing hostname: \\\u0026#34;%s\\\u0026#34;is %d characters\\n\u0026#34;, word, strlen(word)); dnsQuery.request[dnsQuery.length++] = strlen(word); for (i = 0; i \u0026lt; strlen(word); i++) { dnsQuery.request[dnsQuery.length++] = word[i]; } word = strtok(NULL, \u0026#34;.\u0026#34;); } dnsQuery.request[dnsQuery.length++] = 0x00; // End of the host name  dnsQuery.request[dnsQuery.length++] = 0x00; // 0x0001 - Query is a Type A query (host address)  dnsQuery.request[dnsQuery.length++] = dnsQuery.reqType; dnsQuery.request[dnsQuery.length++] = 0x00; // 0x0001 - Query is class IN (Internet address)  dnsQuery.request[dnsQuery.length++] = 0x01; } // http://stackoverflow.com/questions/7775991/how-to-get-hexdump-of-a-structure-data  void hexdump (char *desc, void *addr, int len) { int i; unsigned char buff[17]; unsigned char *pc = addr; // Output description if given.  if (desc != NULL) printf (\u0026#34;%s:\\n\u0026#34;, desc); // Process every byte in the data.  for (i = 0; i \u0026lt; len; i++) { // Multiple of 16 means new line (with line offset).  if ((i % 16) == 0) { // Just don\u0026#39;t print ASCII for the zeroth line.  if (i != 0) printf (\u0026#34; %s\\n\u0026#34;, buff); // Output the offset.  printf (\u0026#34; %04x \u0026#34;, i); } // Now the hex code for the specific character.  printf (\u0026#34; %02x\u0026#34;, pc[i]); // And store a printable ASCII character for later.  if ((pc[i] \u0026lt; 0x20) || (pc[i] \u0026gt; 0x7e)) buff[i % 16] = \u0026#39;.\u0026#39;; else buff[i % 16] = pc[i]; buff[(i % 16) + 1] = \u0026#39;\\0\u0026#39;; } // Pad out last line if not exactly 16 characters.  while ((i % 16) != 0) { printf (\u0026#34; \u0026#34;); i++; } // And print the final ASCII bit.  printf (\u0026#34; %s\\n\u0026#34;, buff); } void lookUp() { struct sockaddr_in addr; int socket; int ret, rcode, size, i; int ip = 0, dom = 0; int length; unsigned char buffer[BUF_SIZE]; unsigned char tempBuf[3]; uint16_t QDCOUNT; //No. of items in Question Section  uint16_t ANCOUNT; //No. of items in Answer Section  uint16_t NSCOUNT; //No. of items in Authority Section  uint16_t ARCOUNT; //No. of items in Additional Section  uint16_t QCLASS; //Specifies the class of the query  uint16_t ATYPE; //Specifies the meaning of the data in the RDATA field  uint16_t ACLASS; //Specifies the class of the data in the RDATA field  uint32_t TTL; //The number of seconds the results can be cached  uint16_t RDLENGTH; //The length of the RDATA field  uint16_t MSGID; socket = createSocket(); memset(\u0026amp;addr, 0, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_addr.s_addr = inet_addr(SERVER); addr.sin_port = htons(PORT); size = sizeof(addr); hexdump(\u0026#34;sending packet\u0026#34;, \u0026amp;dnsQuery.request, dnsQuery.length); ret = sendto(socket, dnsQuery.request, dnsQuery.length, 0, (struct sockaddr*)\u0026amp;addr, size); if (ret \u0026lt; 0) { printf(\u0026#34;Error Sending Request\u0026#34;); exit(1); } //printf(\u0026#34;Sent\\n\u0026#34;);  memset(\u0026amp;buffer, 0, BUF_SIZE); ret = recvfrom(socket, buffer, BUF_SIZE, 0, (struct sockaddr*)\u0026amp;addr, \u0026amp;size); if (ret \u0026lt; 0) { printf(\u0026#34;Error Receiving Response\u0026#34;); exit(1); } hexdump(\u0026#34;received packet\u0026#34;, \u0026amp;buffer, ret); close(socket); rcode = (buffer[3] \u0026amp; 0x0F); //tempBuf[0] = buffer[4];  //tempBuf[1] = buffer[5];  //tempBuf[2] = \u0026#39;\\0\u0026#39;;  //printf(\u0026#34;%0x %0x %0x %0x\\n\u0026#34;, buffer[4], buffer[5], tempBuf[0], tempBuf[1]);  //QDCOUNT = (uint16_t) strtol(tempBuf, NULL, 16);  QDCOUNT = (uint16_t) buffer[4] * 0x100 + buffer[5]; printf(\u0026#34;entries in question section: %u\\n\u0026#34;, QDCOUNT); ANCOUNT = (uint16_t) buffer[6] * 0x100 + buffer[7]; printf(\u0026#34;records in answer section: %u\\n\u0026#34;, ANCOUNT); NSCOUNT = (uint16_t) buffer[8] * 0x100 + buffer[9]; printf(\u0026#34;name server resource record count: %u\\n\u0026#34;, NSCOUNT); ARCOUNT = (uint16_t) buffer[10] * 0x100 + buffer[11]; printf(\u0026#34;additional records count: %u\\n\u0026#34;, ARCOUNT); printf(\u0026#34;query type: %u\\n\u0026#34;, dnsQuery.reqType); QCLASS = (uint16_t) dnsQuery.request[dnsQuery.length - 2] * 0x100 + dnsQuery.request[dnsQuery.length - 1]; printf(\u0026#34;query class: %u\\n\u0026#34;, QCLASS); length = dnsQuery.length + 1; // to skip 0xc00c  ATYPE = (uint16_t) buffer[length + 1] * 0x100 + buffer[length + 2]; printf(\u0026#34;answer type: %u\\n\u0026#34;, ATYPE); ACLASS = (uint16_t) buffer[length + 3] * 0x100 + buffer[length + 4]; printf(\u0026#34;answer class: %u\\n\u0026#34;, ACLASS); TTL = (uint32_t) buffer[length + 5] * 0x1000000 + buffer[length + 6] * 0x10000 + buffer[length + 7] * 0x100 + buffer[length + 8]; printf(\u0026#34;seconds to cache: %u\\n\u0026#34;, TTL); RDLENGTH = (uint16_t) buffer[length + 9] * 0x100 + buffer[length + 10]; printf(\u0026#34;bytes in answer: %u\\n\u0026#34;, RDLENGTH); MSGID = (uint16_t) buffer[0] * 0x100 + buffer[1]; printf(\u0026#34;answer msg id: %u\\n\u0026#34;, MSGID); if (rcode == 2) { printf(\u0026#34;nameserver %s returned SERVFAIL:\\n\u0026#34;, SERVER); printf(\u0026#34; the name server was unable to process this query due to a\\nproblem with the name server.\\n\u0026#34;); exit(1); } else if (rcode == 3) { printf(\u0026#34;nameserver %s returned NXDOMAIN for %s:\\n\u0026#34;, SERVER, dnsQuery.url); printf(\u0026#34; the domain name referenced in the query does not exist\\n\u0026#34;); exit(1); } /* search for and print IPv4 addresses */ if (dnsQuery.reqType == 0x01) { printf(\u0026#34;DNS server\u0026#39;s answer is: (type#=%u):\u0026#34;, ATYPE); //printf(\u0026#34;IPv4 address(es) for %s:\\n\u0026#34;, dnsQuery.url);  for (i = 0 ; i \u0026lt; ret ; i++) { if (buffer[i] == 0xC0 \u0026amp;\u0026amp; buffer[i+3] == 0x01) { ip++; i += 12; /* ! += buf[i+1]; */ printf(\u0026#34; %u.%u.%u.%u\\n\u0026#34;, buffer[i], buffer[i+1], buffer[i+2], buffer[i+3]); } } if (!ip) { printf(\u0026#34; No IPv4 address found in the DNS response!\\n\u0026#34;); exit(1); } } } Output\ndhanoopbhaskar@dhanoop-laptop:~/workspace/Copy/_works$ gcc dnsclient.c dhanoopbhaskar@dhanoop-laptop:~/workspace/Copy/_works$ ./a.out www.theinsanetechie.in Asking DNS server 8.8.8.8 about www.theinsanetechie.in parsing hostname: \u0026quot;www\u0026quot; is 3 characters parsing hostname: \u0026quot;theinsanetechie\u0026quot; is 15 characters parsing hostname: \u0026quot;in\u0026quot; is 2 characters sending packet: 0000 db 42 01 00 00 01 00 00 00 00 00 00 03 77 77 77 .B...........www 0010 0f 74 68 65 69 6e 73 61 6e 65 74 65 63 68 69 65 .theinsanetechie 0020 02 69 6e 00 00 01 00 01 .in..... received packet: 0000 db 42 81 80 00 01 00 03 00 00 00 00 03 77 77 77 .B...........www 0010 0f 74 68 65 69 6e 73 61 6e 65 74 65 63 68 69 65 .theinsanetechie 0020 02 69 6e 00 00 01 00 01 c0 0c 00 05 00 01 00 00 .in............. 0030 32 c7 00 10 03 67 68 73 06 67 6f 6f 67 6c 65 03 2....ghs.google. 0040 63 6f 6d 00 c0 34 00 05 00 01 00 00 54 5f 00 08 com..4......T_.. 0050 03 67 68 73 01 6c c0 38 c0 50 00 01 00 01 00 00 .ghs.l.8.P...... 0060 01 2b 00 04 4a 7d 44 79 .+..J}Dy entries in question section: 1 records in answer section: 3 name server resource record count: 0 additional records count: 0 query type: 1 query class: 1 answer type: 5 answer class: 1 seconds to cache: 12999 bytes in answer: 16 answer msg id: 56130 DNS server's answer is: (type#=5): 74.125.68.121 dhanoopbhaskar@dhanoop-laptop:~/workspace/Copy/_works$  ",
    "ref": "/blog/2016-02-14-dns-lookup-implementation-in-c/"
  },{
    "title": "Java program to find the distance between two GPS locations.",
    "date": "March 11, 2015",
    "description": "",
    "body": "Location.java\npackage com.cables.gps; public class Location { private int latDegree; private int latMinutes; private int latSeconds; private char latDirection; private int longDegree; private int longMinutes; private int longSeconds; private char longDirection; private float latitude; private float longitude; private void init() throws Exception { latitude = latDegree + (latMinutes / 60.0f) + (latSeconds / 3600.0f); if (latDirection == \u0026#39;N\u0026#39;) { latitude *= 1f; } else if (latDirection == \u0026#39;S\u0026#39;) { latitude *= -1f; } else { throw new Exception(\u0026#34;Invalid Latitude Direction: \u0026#34; + latDirection); } longitude = longDegree + (longMinutes / 60.0f) + (longSeconds / 3600.0f); if (longDirection == \u0026#39;E\u0026#39;) { longitude *= 1f; } else if (longDirection == \u0026#39;W\u0026#39;) { longitude *= -1f; } else { throw new Exception(\u0026#34;Invalid Longitude Direction: \u0026#34; + longDirection); } } public String toString() { String returnString = \u0026#34;\u0026#34;; try { init(); } catch (Exception e) { e.printStackTrace(); return null; } returnString += \u0026#34;(\u0026#34; + latitude + \u0026#34;, \u0026#34; + longitude + \u0026#34;)\u0026#34;; return returnString; } public void setLatitude(int deg, int min, int sec, char dir) { latDegree = deg; latMinutes = min; latSeconds = sec; latDirection = dir; } public void setLongitude(int deg, int min, int sec, char dir) { longDegree = deg; longMinutes = min; longSeconds = sec; longDirection = dir; } public int getLatDegree() { return latDegree; } public void setLatDegree(int latDegree) { this.latDegree = latDegree; } public int getLatMinutes() { return latMinutes; } public void setLatMinutes(int latMinutes) { this.latMinutes = latMinutes; } public int getLatSeconds() { return latSeconds; } public void setLatSeconds(int latSeconds) { this.latSeconds = latSeconds; } public char getLatDirection() { return latDirection; } public void setLatDirection(char latDirection) throws Exception { if (latDirection != \u0026#39;N\u0026#39; \u0026amp;\u0026amp; latDirection != \u0026#39;S\u0026#39;) { throw new Exception(\u0026#34;Invalid Latitude Direction: \u0026#34; + latDirection); } this.latDirection = latDirection; } public int getLongDegree() { return longDegree; } public void setLongDegree(int longDegree) { this.longDegree = longDegree; } public int getLongMinutes() { return longMinutes; } public void setLongMinutes(int longMinutes) { this.longMinutes = longMinutes; } public int getLongSeconds() { return longSeconds; } public void setLongSeconds(int longSeconds) { this.longSeconds = longSeconds; } public char getLongDirection() { return longDirection; } public void setLongDirection(char longDirection) throws Exception { if (longDirection != \u0026#39;E\u0026#39; \u0026amp;\u0026amp; longDirection != \u0026#39;W\u0026#39;) { throw new Exception(\u0026#34;Invalid Longitude Direction: \u0026#34; + longDirection); } this.longDirection = longDirection; } public float getLatitude() throws Exception { init(); return latitude; } public void setLatitude(float latitude) { this.latitude = latitude; } public float getLongitude() throws Exception { init(); return longitude; } public void setLongitude(float longitude) { this.longitude = longitude; } public void setLatString(String latStr) throws Exception { latStr = latStr.trim(); String[] values = latStr.split(\u0026#34; \u0026#34;); latDegree = Integer.parseInt(values[0].trim()); latMinutes = Integer.parseInt(values[1].trim()); latSeconds = Integer.parseInt(values[2].trim()); latDirection = values[3].trim().charAt(0); if (latDirection != \u0026#39;N\u0026#39; \u0026amp;\u0026amp; latDirection != \u0026#39;S\u0026#39;) { throw new Exception(\u0026#34;Invalid Latitude Direction: \u0026#34; + latDirection); } } public void setLongString(String longStr) throws Exception { longStr = longStr.trim(); String[] values = longStr.split(\u0026#34; \u0026#34;); longDegree = Integer.parseInt(values[0].trim()); longMinutes = Integer.parseInt(values[1].trim()); longSeconds = Integer.parseInt(values[2].trim()); longDirection = values[3].trim().charAt(0); if (longDirection != \u0026#39;E\u0026#39; \u0026amp;\u0026amp; longDirection != \u0026#39;W\u0026#39;) { throw new Exception(\u0026#34;Invalid Longitude Direction: \u0026#34; + longDirection); } } } LocationOps.java\npackage com.cables.gps; public class LocationOps { private Location location1 = null; private Location location2 = null; private int radius = 6371; public LocationOps(Location location1, Location location2) { this.location1 = location1; this.location2 = location2; } public double calculateDistance() throws Exception { double distance = 0.0; double lat1 = degreesToRadians(location1.getLatitude()); double lat2 = degreesToRadians(location2.getLatitude()); double dLat = degreesToRadians(location2.getLatitude() - location1.getLatitude()); double dLong = degreesToRadians(location2.getLongitude() - location1.getLongitude()); double a = Math.sin(dLat / 2.0) * Math.sin(dLat / 2.0) + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLong / 2.0) * Math.sin(dLong / 2.0); double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); distance = radius * c; return distance; } public double degreesToRadians(double degrees) { double radians = 0.0; radians = degrees * Math.PI / 180.0; return radians; } public static void main(String[] args) throws Exception { Location loc1 = new Location(); loc1.setLatDegree(50); loc1.setLatMinutes(03); loc1.setLatSeconds(59); loc1.setLatDirection(\u0026#39;N\u0026#39;); loc1.setLongDegree(005); loc1.setLongMinutes(42); loc1.setLongSeconds(53); loc1.setLongDirection(\u0026#39;W\u0026#39;); Location loc2 = new Location(); loc2.setLatDegree(58); loc2.setLatMinutes(38); loc2.setLatSeconds(38); loc2.setLatDirection(\u0026#39;N\u0026#39;); loc2.setLongDegree(003); loc2.setLongMinutes(04); loc2.setLongSeconds(12); loc2.setLongDirection(\u0026#39;W\u0026#39;); System.out.println(new LocationOps(loc1, loc2).calculateDistance()); loc1.setLatString(\u0026#34;50 03 59 N\u0026#34;); loc1.setLongString(\u0026#34;005 42 53 W\u0026#34;); loc2.setLatString(\u0026#34;58 38 38 N\u0026#34;); loc2.setLongString(\u0026#34;003 04 12 W\u0026#34;); System.out.println(new LocationOps(loc1, loc2).calculateDistance()); } } ",
    "ref": "/blog/2015-03-11-java-program-to-find-the-distance-between-two-gps-locations/"
  },{
    "title": "Sum of Prime Numbers Between 1000000 and 1000100 Using Sieve of Eratosthenes",
    "date": "December 30, 2014",
    "description": "",
    "body": "For more information on Sieve of Eratosthenes please refer wikipedia page\n#include \u0026#34;stdio.h\u0026#34; #include \u0026#34;string.h\u0026#34; #include \u0026#34;stdlib.h\u0026#34; #include \u0026#34;assert.h\u0026#34; typedef unsigned long long biggerint; void findPrimeNumbers(biggerint start, biggerint end) { char * primeList = malloc(sizeof(unsigned char) * (end + 1)); int i; biggerint sum = 0; assert(primeList != NULL); /* set prime status */ for (i = 0; i \u0026lt;= end + 1 ; i++) { *(primeList + i) = 1; } primeList[0] = 0; primeList[1] = 0; /* mark all the non-prime numbers */ biggerint currentFactor = 2; biggerint lastSquare = 0; biggerint currentSquare = 0; while (currentFactor * currentFactor \u0026lt;= end) { /* mark all the multiples of the current factor */ biggerint mark = currentFactor + currentFactor; while (mark \u0026lt;= end) { *(primeList + mark) = 0; mark += currentFactor; } /* set currentFactor to next prime number */ currentFactor++; while (*(primeList+currentFactor) == 0) currentFactor++; assert(currentFactor \u0026lt;= end); } for(i = start; i \u0026lt;= end ; i++) { if(*(primeList + i)) sum += i; } free(primeList); printf(\u0026#34;%llu\\n\u0026#34;, sum); } int main(int argc, char *argv[]) { biggerint start = 1000000; biggerint end = 1000100; findPrimeNumbers(start, end); return 0; } ",
    "ref": "/blog/2014-12-30-sum-of-prime-numbers-between-1000000-and-1000100-using-sieve-of-eratosthenes/"
  },{
    "title": "AES Implementation In Java with ECB | CBC | OFB | CFB Modes Of Operation",
    "date": "July 30, 2014",
    "description": "",
    "body": "Note that these are ONLY basic level programs for easy understanding of the Advanced Encryption Standard (AES) algorithm\nKey Generation - AESkeygen.java\nimport java.io.File; import java.io.FileWriter; public class AESkeygen { private final File file = new File(\u0026#34;AESkey.txt\u0026#34;); private final int KEY_LENGTH = 32; private final static char[] hexArray = \u0026#34;0123456789ABCDEF\u0026#34;.toCharArray(); public AESkeygen() { try { FileWriter fileWriter = new FileWriter(file); fileWriter.write(\u0026#34;\u0026#34;); for (int i = 0; i \u0026lt; KEY_LENGTH; i++) { double random = Math.random(); int index = (int) (random * 16); fileWriter.append(hexArray[index]); fileWriter.flush(); } fileWriter.close(); System.out.println(\u0026#34;Key generated and saved in \u0026#34; + file.getName()); } catch (Exception exp) { exp.printStackTrace(); } } public static void main(String[] args) { new AESkeygen(); } } Word.java\npublic class Word { private byte[] word = null; public Word() { word = new byte[4]; } public Word(byte k0, byte k1, byte k2, byte k3) { this(); word[0] = k0; word[1] = k1; word[2] = k2; word[3] = k3; } public byte[] getWord() { return word; } public void setWord(byte[] word) { this.word = word; } public static byte[] wordToBytes(Word word) { return word.getWord(); } public static byte[] wordsToBytes(Word[] words) { byte[] out = new byte[4 * words.length]; for (int i = 0; i \u0026lt; words.length; i++) { byte[] temp = words[i].getWord(); out[4 * i] = temp[0]; out[4 * i + 1] = temp[1]; out[4 * i + 2] = temp[2]; out[4 * i + 3] = temp[3]; } return out; } public void rotWord() { byte[] temp = this.getWord(); byte[] newWord = new byte[4]; newWord[0] = temp[1]; newWord[1] = temp[2]; newWord[2] = temp[3]; newWord[3] = temp[0]; this.setWord(newWord); } public void subWord() { byte[] in = this.getWord(); byte[] out = new byte[4]; for (int i = 0; i \u0026lt; 4; i++) { byte a = in[i]; int row = (a \u0026gt;\u0026gt; 4) \u0026amp; 0x000F; int col = a \u0026amp; 0x000F; out[i] = (byte) AESencrypt.sBox[row * 16 + col]; } for (int i = 0; i \u0026lt; 4; i++) { this.word[i] = out[i]; } } public static Word XORWords(Word word1, Word word2) { Word outWord = new Word(); byte[] in1 = word1.getWord(); byte[] in2 = word2.getWord(); byte[] out = new byte[4]; for (int i = 0; i \u0026lt; 4; i++) { out[i] = (byte) ((in1[i] ^ in2[i]) \u0026amp; 0xff); } outWord.setWord(out); return outWord; } public String toString() { return AESencrypt.bytesToHex(this.getWord()); } }  Encryption - AESencrypt.java\nimport java.io.BufferedReader; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.FileReader; import java.util.Arrays; public class AESencrypt { private static final int BITS = 16; private static final int ROUNDS = 10; private static final int NO_OF_WORDS_IN_KEY = 44; private static final int KEY_LENGTH = 16; private static final int BLOCK_LENGTH = 16; final protected static char[] hexArray = \u0026#34;0123456789ABCDEF\u0026#34;.toCharArray(); int[] RC = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36 }; Word[] Rcon = new Word[ROUNDS]; private byte[] word = null; private String mode = null; static final int[] sBox = { 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 }; static final int[] invSBox = { 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d }; public AESencrypt(String mode) { this.mode = mode; for (int i = 0; i \u0026lt; ROUNDS; i++) { Rcon[i] = new Word(); byte[] temp = new byte[4]; temp[0] = (byte) (RC[i] \u0026amp; 0xff); temp[1] = 0; temp[2] = 0; temp[3] = 0; Rcon[i].setWord(temp); } word = new byte[NO_OF_WORDS_IN_KEY]; } /* Ref: http://www.samiam.org/galois.html */ /* Galois Addition */ byte gadd(byte a, byte b) { return (byte) ((a ^ b) \u0026amp; 0xff); } /* Galois Subtraction */ byte gsub(byte a, byte b) { return (byte) ((a ^ b) \u0026amp; 0xff); } /* Galois Multiplication */ byte gmul(byte a, byte b) { byte p = 0; int counter; byte high_bit_set; byte byte0x80 = hexStringToByteArray(\u0026#34;80\u0026#34;)[0]; for (counter = 0; counter \u0026lt; 8; counter++) { if ((b \u0026amp; 0x01) == 1) { // System.out.println(\u0026#34;lower bit of b is set\u0026#34;);  p = (byte) ((p ^ a) \u0026amp; 0xff); } high_bit_set = (byte) (a \u0026amp; 0x80); // printByte(\u0026#34;high_bit_set\u0026#34;, high_bit_set);  a \u0026lt;\u0026lt;= 1; if (high_bit_set == byte0x80) { // System.out.println(\u0026#34;higher bit of a is set\u0026#34;);  a = (byte) ((a ^ 0x1b) \u0026amp; 0xff); } b = (byte) ((b \u0026gt;\u0026gt; 1) \u0026amp; 0x7f); // printByte(\u0026#34;a\u0026#34;, a);  // printByte(\u0026#34;b\u0026#34;, b);  // printByte(\u0026#34;p\u0026#34;, p);  } return p; } byte gmul(byte a, int b) { byte t = (byte) (b \u0026amp; 0xff); return gmul(a, t); } /* Key Expansion */ private byte[] expandKey(byte[] key) throws Exception { // System.out.println(key.length);  // System.out.println(bytesToHex(key));  if (key.length != KEY_LENGTH) { throw new Exception(\u0026#34;Key should be of length, 128 bits\u0026#34;); } Word[] w = new Word[NO_OF_WORDS_IN_KEY]; Word temp; for (int i = 0; i \u0026lt; 4; i++) { w[i] = new Word(key[4 * i], key[4 * i + 1], key[4 * i + 2], key[4 * i + 3]); // System.out.println(\u0026#34;w\u0026#34; + i + \u0026#34; = \u0026#34; + w[i]);  } for (int i = 4; i \u0026lt; 44; i++) { temp = w[i - 1]; Word temp1 = new Word(); temp1.setWord(temp.getWord()); // System.out.println(\u0026#34;w\u0026#34; + (i-1) + \u0026#34; = \u0026#34; + temp);  if (i % 4 == 0) { temp1.rotWord(); // System.out.println(\u0026#34;Rot=\u0026#34; + temp1);  temp1.subWord(); // System.out.println(\u0026#34;Sub=\u0026#34; + temp1);  temp1 = Word.XORWords(temp1, Rcon[(i / 4) - 1]); // System.out.println(\u0026#34;Rcon\u0026#34; + temp1);  } w[i] = Word.XORWords(w[i - 4], temp1); // System.out.println(\u0026#34;w\u0026#34; + i + \u0026#34; = \u0026#34; + w[i]);  } return Word.wordsToBytes(w); } /* Substitute Bytes */ private byte[] subBytes(byte[] in) { byte[] out = new byte[BITS]; for (int i = 0; i \u0026lt; BITS; i++) { byte a = in[i]; int row = (a \u0026gt;\u0026gt; 4) \u0026amp; 0x000F; int col = a \u0026amp; 0x000F; out[i] = (byte) sBox[row * BITS + col]; } return out; } /* Inverse Substitute Bytes */ private byte[] inverseSubBytes(byte[] in) { byte[] out = new byte[BITS]; for (int i = 0; i \u0026lt; BITS; i++) { byte a = in[i]; int row = (a \u0026gt;\u0026gt; 4) \u0026amp; 0x000F; int col = a \u0026amp; 0x000F; out[i] = (byte) invSBox[row * BITS + col]; } return out; } /* Shift Rows */ private byte[] shiftRows(byte[] in) { byte[] out = new byte[BITS]; byte[] temp = new byte[BITS]; for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { temp[4 * j + i] = in[4 * i + j]; } } // System.out.println(\u0026#34;temp: \u0026#34; + bytesToHex(temp));  for (int i = 0; i \u0026lt; BITS / 4; i++) { byte[] a = Arrays.copyOfRange(temp, (4 * i), (4 * i + 4)); byte[] b = leftShift(a, i); in[4 * i] = b[0]; in[4 * i + 1] = b[1]; in[4 * i + 2] = b[2]; in[4 * i + 3] = b[3]; } for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { out[4 * j + i] = in[4 * i + j]; } } return out; } private byte[] leftShift(byte[] in, int times) { byte[] out = new byte[4]; out = Arrays.copyOfRange(in, 0, 4); for (int i = 0; i \u0026lt; times; i++) { out[0] = in[1]; out[1] = in[2]; out[2] = in[3]; out[3] = in[0]; in = Arrays.copyOfRange(out, 0, 4); } return out; } /* Inverse Shift Rows */ private byte[] inverseShiftRows(byte[] in) { byte[] out = new byte[BITS]; byte[] temp = new byte[BITS]; for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { temp[4 * j + i] = in[4 * i + j]; } } for (int i = 0; i \u0026lt; BITS / 4; i++) { byte[] a = Arrays.copyOfRange(temp, (4 * i), (4 * i + 4)); byte[] b = rightShift(a, i); in[4 * i] = b[0]; in[4 * i + 1] = b[1]; in[4 * i + 2] = b[2]; in[4 * i + 3] = b[3]; } for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { out[4 * j + i] = in[4 * i + j]; } } return out; } private byte[] rightShift(byte[] in, int times) { byte[] out = new byte[4]; out = Arrays.copyOfRange(in, 0, 4); for (int i = 0; i \u0026lt; times; i++) { out[0] = in[3]; out[1] = in[0]; out[2] = in[1]; out[3] = in[2]; in = Arrays.copyOfRange(out, 0, 4); } return out; } /* Mix Columns */ private byte[] mixColumns(byte[] in) { byte[] out = new byte[BITS]; byte[] temp = new byte[BITS]; for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { temp[4 * j + i] = in[4 * i + j]; } } in = temp; for (int j = 0; j \u0026lt; BITS / 4; j++) { out[4 * 0 + j] = (byte) ((gmul(in[4 * 0 + j], 2) ^ gmul(in[4 * 1 + j], 3) ^ in[4 * 2 + j] ^ in[4 * 3 + j]) \u0026amp; 0xff); out[4 * 1 + j] = (byte) ((in[4 * 0 + j] ^ gmul(in[4 * 1 + j], 2) ^ gmul(in[4 * 2 + j], 3) ^ in[4 * 3 + j]) \u0026amp; 0xff); out[4 * 2 + j] = (byte) ((in[4 * 0 + j] ^ in[4 * 1 + j] ^ gmul(in[4 * 2 + j], 2) ^ gmul(in[4 * 3 + j], 3)) \u0026amp; 0xff); out[4 * 3 + j] = (byte) ((gmul(in[4 * 0 + j], 3) ^ in[4 * 1 + j] ^ in[4 * 2 + j] ^ gmul(in[4 * 3 + j], 2)) \u0026amp; 0xff); } for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { temp[4 * j + i] = out[4 * i + j]; } } out = temp; return out; } /* Inverse Mix Columns */ private byte[] inverseMixColumns(byte[] in) { byte[] out = new byte[BITS]; byte[] temp = new byte[BITS]; for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { temp[4 * j + i] = in[4 * i + j]; } } in = temp; for (int j = 0; j \u0026lt; BITS / 4; j++) { out[4 * 0 + j] = (byte) ((gmul(in[4 * 0 + j], 14) ^ gmul(in[4 * 1 + j], 11) ^ gmul(in[4 * 2 + j], 13) ^ gmul(in[4 * 3 + j], 9)) \u0026amp; 0xff); out[4 * 1 + j] = (byte) ((gmul(in[4 * 0 + j], 9) ^ gmul(in[4 * 1 + j], 14) ^ gmul(in[4 * 2 + j], 11) ^ gmul(in[4 * 3 + j], 13)) \u0026amp; 0xff); out[4 * 2 + j] = (byte) ((gmul(in[4 * 0 + j], 13) ^ gmul(in[4 * 1 + j], 9) ^ gmul(in[4 * 2 + j], 14) ^ gmul(in[4 * 3 + j], 11)) \u0026amp; 0xff); out[4 * 3 + j] = (byte) ((gmul(in[4 * 0 + j], 11) ^ gmul(in[4 * 1 + j], 13) ^ gmul(in[4 * 2 + j], 9) ^ gmul(in[4 * 3 + j], 14)) \u0026amp; 0xff); } for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { temp[4 * j + i] = out[4 * i + j]; } } out = temp; return out; } private byte[] hexStringToByteArray(String string) { int length = string.length(); int n = (int) Math.ceil((length + 1) / 2); byte[] result = new byte[n]; for (int i = length - 1; i \u0026gt;= 0; i -= 2) { if (i == 0) { result[i / 2] = (byte) ((Character.digit(\u0026#39;0\u0026#39;, 16) \u0026lt;\u0026lt; 4) + Character.digit(string.charAt(i), 16)); } else { result[i / 2] = (byte) ((Character.digit(string.charAt(i - 1), 16) \u0026lt;\u0026lt; 4) + Character.digit(string.charAt(i), 16)); } } return result; } /* * http://stackoverflow.com/questions/9655181/convert-from-byte-array-to-hex- * string-in-java */ public static String bytesToHex(byte[] bytes) { char[] hexChars = new char[bytes.length * 2]; for (int j = 0; j \u0026lt; bytes.length; j++) { int v = bytes[j] \u0026amp; 0xFF; hexChars[j * 2] = hexArray[v \u0026gt;\u0026gt;\u0026gt; 4]; hexChars[j * 2 + 1] = hexArray[v \u0026amp; 0x0F]; } return new String(hexChars); } private void printBytes(byte[] input) { for (int i = 0; i \u0026lt; input.length; i++) { System.out.print(byteToBits(input[i]) + \u0026#34; \u0026#34;); } System.out.println(); } private void printByte(String msg, byte input) { byte[] temp = new byte[1]; temp[0] = input; System.out.println(msg + \u0026#34;: \u0026#34; + bytesToHex(temp)); } private String byteToBits(byte b) { StringBuffer buffer = new StringBuffer(); for (int i = 0; i \u0026lt; 8; i++) buffer.append((int) (b \u0026gt;\u0026gt; (8 - (i + 1)) \u0026amp; 0x0001)); return buffer.toString(); } private byte[] getRoundKey(int round) { byte[] out = new byte[KEY_LENGTH]; out = Arrays.copyOfRange(word, 16 * round, 16 * round + 16); return out; } public static byte[] XORBytes(byte[] in1, byte[] in2) { byte[] out = new byte[in1.length]; for (int i = 0; i \u0026lt; in1.length; i++) { out[i] = (byte) ((in1[i] ^ in2[i]) \u0026amp; 0xff); } return out; } public byte[] encryptText(byte[] plainText, byte[] key) throws Exception { byte[] cipher = new byte[BLOCK_LENGTH]; this.word = expandKey(key); byte[] roundKey = getRoundKey(0); /* Round 0 */ cipher = XORBytes(plainText, roundKey); // System.out.println(\u0026#34;Round 0\\n\u0026#34; + bytesToHex(cipher));  /* Rounds 1 to 9 */ for (int i = 1; i \u0026lt; 10; i++) { // System.out.println(\u0026#34;Round \u0026#34; + i);  cipher = subBytes(cipher); // System.out.println(\u0026#34;SubBytes: \u0026#34; + bytesToHex(cipher));  cipher = shiftRows(cipher); // System.out.println(\u0026#34;ShiftRows: \u0026#34; + bytesToHex(cipher));  cipher = mixColumns(cipher); // System.out.println(\u0026#34;MixColumns: \u0026#34; + bytesToHex(cipher));  roundKey = getRoundKey(i); // System.out.println(\u0026#34;RoundKey: \u0026#34; + bytesToHex(roundKey));  cipher = XORBytes(cipher, roundKey); // System.out.println(\u0026#34;CIPHER: \u0026#34; + bytesToHex(cipher));  } /* Round 10 */ // System.out.println(\u0026#34;Round 10\u0026#34;);  cipher = subBytes(cipher); // System.out.println(\u0026#34;SubBytes: \u0026#34; + bytesToHex(cipher));  cipher = shiftRows(cipher); // System.out.println(\u0026#34;ShiftRows: \u0026#34; + bytesToHex(cipher));  roundKey = getRoundKey(10); // System.out.println(\u0026#34;RoundKey: \u0026#34; + bytesToHex(roundKey));  cipher = XORBytes(cipher, roundKey); // System.out.println(\u0026#34;CIPHER: \u0026#34; + bytesToHex(cipher));  return cipher; } public byte[] decryptText(byte[] cipher, byte[] key) throws Exception { byte[] plainText = new byte[BLOCK_LENGTH]; this.word = expandKey(key); byte[] roundKey = getRoundKey(10); /* Round 0 */ plainText = XORBytes(cipher, roundKey); /* Rounds 1 to 9 */ for (int i = 9; i \u0026gt; 0; i--) { plainText = inverseShiftRows(plainText); plainText = inverseSubBytes(plainText); roundKey = getRoundKey(i); plainText = XORBytes(plainText, roundKey); plainText = inverseMixColumns(plainText); } /* Round 10 */ plainText = inverseShiftRows(plainText); plainText = inverseSubBytes(plainText); roundKey = getRoundKey(0); plainText = XORBytes(plainText, roundKey); return plainText; } public static void main(String[] args) throws Exception { try { if (args.length != 1) { System.out.println(\u0026#34;Usage: java \u0026lt; classname \u0026gt; \u0026lt; mode \u0026gt;\u0026#34; + \u0026#34;\\n\\t\u0026lt; mode \u0026gt; := (ECB|CBC|OFB|CFB)\u0026#34;); return; } /* ECB, CBC, OFB, or CFB */ String mode = args[0]; // String mode = \u0026#34;CFB\u0026#34;;  mode = mode.toUpperCase(); AESencrypt aes = new AESencrypt(mode); File keyFile = new File(\u0026#34;AESkey.txt\u0026#34;); File textFile = new File(\u0026#34;AESplaintext.txt\u0026#34;); File cipherFile = new File(\u0026#34;AESciphertext.txt\u0026#34;); FileReader keyFileReader = new FileReader(keyFile); BufferedReader bufferedReader = new BufferedReader(keyFileReader); FileInputStream textFileInputStream = new FileInputStream(textFile); FileOutputStream cipherFileOutputStream = new FileOutputStream(cipherFile); byte[] key = new byte[(int) keyFile.length()]; String keyString = bufferedReader.readLine(); key = aes.hexStringToByteArray(keyString); byte[] message = new byte[(int) textFile.length()]; textFileInputStream.read(message); byte[] cipher = aes.encrypt(message, key); cipherFileOutputStream.write(cipher); cipherFileOutputStream.flush(); cipherFileOutputStream.close(); bufferedReader.close(); textFileInputStream.close(); System.out.println(\u0026#34;Encryption done! Please check AESciphertext.txt for output!\u0026#34;); } catch (Exception exp) { exp.printStackTrace(); } } private byte[] encrypt(byte[] message, byte[] key) throws Exception { if (message.length \u0026lt; 16) { System.out.println(\u0026#34;Message should be atleast 64 bits\u0026#34;); System.exit(1); } if (key.length != 16) { System.out.println(\u0026#34;Key should be 64 bits\u0026#34;); System.exit(1); } int length = message.length; int n = (length + 15) / 16 * 16; byte[] cipher = new byte[n]; if (length == 16) { if (mode.equals(\u0026#34;ECB\u0026#34;)) { return encryptText(message, key); } else if (mode.equals(\u0026#34;CBC\u0026#34;)) { byte[] iv = getInitializationVector(); message = XORBytes(message, iv); return encryptText(message, key); } else if (mode.equals(\u0026#34;OFB\u0026#34;)) { byte[] nounce = getNounce(); byte[] temp = encryptText(nounce, key); byte[] result = XORBytes(temp, message); return result; } else if (mode.equals(\u0026#34;CFB\u0026#34;)) { } else { System.out.println(\u0026#34;Unsupported mode of operation!\u0026#34;); return null; } } int i = 0; int k = 0; byte[] feedback = new byte[16]; if (mode.equals(\u0026#34;CBC\u0026#34;)) { feedback = getInitializationVector(); } else if (mode.equals(\u0026#34;OFB\u0026#34;)) { feedback = getNounce(); } else if (mode.equals(\u0026#34;CFB\u0026#34;)) { feedback = getInitializationVectorCFB(); } while (i \u0026lt; length) { byte[] block = new byte[16]; byte[] result = new byte[16]; int j = 0; for (; j \u0026lt; 16 \u0026amp;\u0026amp; i \u0026lt; length; j++, i++) { block[j] = message[i]; } while (j \u0026lt; 16) { /* pad with white spaces */ block[j++] = 0x20; } // System.out.println(\u0026#34;BLOCK: \u0026#34;);  // printBytes(block);  if (mode.equals(\u0026#34;ECB\u0026#34;)) { result = encryptText(block, key); } else if (mode.equals(\u0026#34;CBC\u0026#34;)) { block = XORBytes(block, feedback); result = encryptText(block, key); feedback = Arrays.copyOfRange(result, 0, 16); } else if (mode.equals(\u0026#34;OFB\u0026#34;)) { result = encryptText(feedback, key); feedback = Arrays.copyOfRange(result, 0, 16); result = XORBytes(result, block); } else if (mode.equals(\u0026#34;CFB\u0026#34;)) { result = encryptText(feedback, key); byte[] resultPart = Arrays.copyOfRange(result, 0, 8); byte[] blockPart = Arrays.copyOfRange(block, 0, 8); byte[] temp1 = XORBytes(resultPart, blockPart); feedback = mergeBytes(Arrays.copyOfRange(result, 8, 16), temp1); resultPart = Arrays.copyOfRange(result, 8, 16); blockPart = Arrays.copyOfRange(block, 8, 16); result = encryptText(feedback, key); byte[] temp2 = XORBytes(resultPart, blockPart); feedback = mergeBytes(Arrays.copyOfRange(result, 8, 16), temp2); result = mergeBytes(temp1, temp2); } else { System.out.println(\u0026#34;Unsupported mode of operation!\u0026#34;); return null; } // System.out.println(\u0026#34;RESULT: \u0026#34;);  // printBytes(result);  for (j = 0; j \u0026lt; 16 \u0026amp;\u0026amp; k \u0026lt; cipher.length; j++, k++) { cipher[k] = result[j]; } } return cipher; } private byte[] getInitializationVector() { return hexStringToByteArray(\u0026#34;247D8AC4DDB1AA739DC593821D0BC432\u0026#34;); } private byte[] getInitializationVectorCFB() { return hexStringToByteArray(\u0026#34;247D8AC4DDB1AA739DC593821D0BC432\u0026#34;); } private byte[] getNounce() { // char[] hexArray = \u0026#34;0123456789ABCDEF\u0026#34;.toCharArray();  // String nounceStr = \u0026#34;\u0026#34;;  // for (int i = 0 ; i \u0026lt; 16 ; i++) {  // double random = Math.random();  // int index = (int) (random * 16);  // nounceStr += hexArray[index];  // }  // return hexStringToByteArray(nounceStr);  return hexStringToByteArray(\u0026#34;247D8AC4DDB1AA739DC593821D0BC432\u0026#34;); } private byte[] mergeBytes(byte[] in1, byte[] in2) { byte[] out = new byte[in1.length + in2.length]; int i = 0; for (int j = 0; j \u0026lt; in1.length; j++) { out[i++] = in1[j]; } for (int j = 0; j \u0026lt; in2.length; j++) { out[i++] = in2[j]; } return out; } } Decryption - AESdecrypt.java\nimport java.io.BufferedReader; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.FileReader; import java.util.Arrays; public class AESdecrypt { private static final int BITS = 16; private static final int ROUNDS = 10; private static final int NO_OF_WORDS_IN_KEY = 44; private static final int KEY_LENGTH = 16; private static final int BLOCK_LENGTH = 16; final protected static char[] hexArray = \u0026#34;0123456789ABCDEF\u0026#34;.toCharArray(); int[] RC = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36 }; Word[] Rcon = new Word[ROUNDS]; private byte[] word = null; private String mode = null; static final int[] sBox = { 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 }; static final int[] invSBox = { 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d }; public AESdecrypt(String mode) { this.mode = mode; for (int i = 0; i \u0026lt; ROUNDS; i++) { Rcon[i] = new Word(); byte[] temp = new byte[4]; temp[0] = (byte) (RC[i] \u0026amp; 0xff); temp[1] = 0; temp[2] = 0; temp[3] = 0; Rcon[i].setWord(temp); } word = new byte[NO_OF_WORDS_IN_KEY]; } /* Ref: http://www.samiam.org/galois.html */ /* Galois Addition */ byte gadd(byte a, byte b) { return (byte) ((a ^ b) \u0026amp; 0xff); } /* Galois Subtraction */ byte gsub(byte a, byte b) { return (byte) ((a ^ b) \u0026amp; 0xff); } /* Galois Multiplication */ byte gmul(byte a, byte b) { byte p = 0; int counter; byte high_bit_set; byte byte0x80 = hexStringToByteArray(\u0026#34;80\u0026#34;)[0]; for (counter = 0; counter \u0026lt; 8; counter++) { if ((b \u0026amp; 0x01) == 1) { // System.out.println(\u0026#34;lower bit of b is set\u0026#34;);  p = (byte) ((p ^ a) \u0026amp; 0xff); } high_bit_set = (byte) (a \u0026amp; 0x80); // printByte(\u0026#34;high_bit_set\u0026#34;, high_bit_set);  a \u0026lt;\u0026lt;= 1; if (high_bit_set == byte0x80) { // System.out.println(\u0026#34;higher bit of a is set\u0026#34;);  a = (byte) ((a ^ 0x1b) \u0026amp; 0xff); } b = (byte) ((b \u0026gt;\u0026gt; 1) \u0026amp; 0x7f); // printByte(\u0026#34;a\u0026#34;, a);  // printByte(\u0026#34;b\u0026#34;, b);  // printByte(\u0026#34;p\u0026#34;, p);  } return p; } byte gmul(byte a, int b) { byte t = (byte) (b \u0026amp; 0xff); return gmul(a, t); } /* Key Expansion */ private byte[] expandKey(byte[] key) throws Exception { // System.out.println(key.length);  // System.out.println(bytesToHex(key));  if (key.length != KEY_LENGTH) { throw new Exception(\u0026#34;Key should be of length, 128 bits\u0026#34;); } Word[] w = new Word[NO_OF_WORDS_IN_KEY]; Word temp; for (int i = 0; i \u0026lt; 4; i++) { w[i] = new Word(key[4 * i], key[4 * i + 1], key[4 * i + 2], key[4 * i + 3]); // System.out.println(\u0026#34;w\u0026#34; + i + \u0026#34; = \u0026#34; + w[i]);  } for (int i = 4; i \u0026lt; 44; i++) { temp = w[i - 1]; Word temp1 = new Word(); temp1.setWord(temp.getWord()); // System.out.println(\u0026#34;w\u0026#34; + (i-1) + \u0026#34; = \u0026#34; + temp);  if (i % 4 == 0) { temp1.rotWord(); // System.out.println(\u0026#34;Rot=\u0026#34; + temp1);  temp1.subWord(); // System.out.println(\u0026#34;Sub=\u0026#34; + temp1);  temp1 = Word.XORWords(temp1, Rcon[(i / 4) - 1]); // System.out.println(\u0026#34;Rcon\u0026#34; + temp1);  } w[i] = Word.XORWords(w[i - 4], temp1); // System.out.println(\u0026#34;w\u0026#34; + i + \u0026#34; = \u0026#34; + w[i]);  } return Word.wordsToBytes(w); } /* Substitute Bytes */ private byte[] subBytes(byte[] in) { byte[] out = new byte[BITS]; for (int i = 0; i \u0026lt; BITS; i++) { byte a = in[i]; int row = (a \u0026gt;\u0026gt; 4) \u0026amp; 0x000F; int col = a \u0026amp; 0x000F; out[i] = (byte) sBox[row * BITS + col]; } return out; } /* Inverse Substitute Bytes */ private byte[] inverseSubBytes(byte[] in) { byte[] out = new byte[BITS]; for (int i = 0; i \u0026lt; BITS; i++) { byte a = in[i]; int row = (a \u0026gt;\u0026gt; 4) \u0026amp; 0x000F; int col = a \u0026amp; 0x000F; out[i] = (byte) invSBox[row * BITS + col]; } return out; } /* Shift Rows */ private byte[] shiftRows(byte[] in) { byte[] out = new byte[BITS]; byte[] temp = new byte[BITS]; for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { temp[4 * j + i] = in[4 * i + j]; } } // System.out.println(\u0026#34;temp: \u0026#34; + bytesToHex(temp));  for (int i = 0; i \u0026lt; BITS / 4; i++) { byte[] a = Arrays.copyOfRange(temp, (4 * i), (4 * i + 4)); byte[] b = leftShift(a, i); in[4 * i] = b[0]; in[4 * i + 1] = b[1]; in[4 * i + 2] = b[2]; in[4 * i + 3] = b[3]; } for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { out[4 * j + i] = in[4 * i + j]; } } return out; } private byte[] leftShift(byte[] in, int times) { byte[] out = new byte[4]; out = Arrays.copyOfRange(in, 0, 4); for (int i = 0; i \u0026lt; times; i++) { out[0] = in[1]; out[1] = in[2]; out[2] = in[3]; out[3] = in[0]; in = Arrays.copyOfRange(out, 0, 4); } return out; } /* Inverse Shift Rows */ private byte[] inverseShiftRows(byte[] in) { byte[] out = new byte[BITS]; byte[] temp = new byte[BITS]; for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { temp[4 * j + i] = in[4 * i + j]; } } for (int i = 0; i \u0026lt; BITS / 4; i++) { byte[] a = Arrays.copyOfRange(temp, (4 * i), (4 * i + 4)); byte[] b = rightShift(a, i); in[4 * i] = b[0]; in[4 * i + 1] = b[1]; in[4 * i + 2] = b[2]; in[4 * i + 3] = b[3]; } for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { out[4 * j + i] = in[4 * i + j]; } } return out; } private byte[] rightShift(byte[] in, int times) { byte[] out = new byte[4]; out = Arrays.copyOfRange(in, 0, 4); for (int i = 0; i \u0026lt; times; i++) { out[0] = in[3]; out[1] = in[0]; out[2] = in[1]; out[3] = in[2]; in = Arrays.copyOfRange(out, 0, 4); } return out; } /* Mix Columns */ private byte[] mixColumns(byte[] in) { byte[] out = new byte[BITS]; byte[] temp = new byte[BITS]; for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { temp[4 * j + i] = in[4 * i + j]; } } in = temp; for (int j = 0; j \u0026lt; BITS / 4; j++) { out[4 * 0 + j] = (byte) ((gmul(in[4 * 0 + j], 2) ^ gmul(in[4 * 1 + j], 3) ^ in[4 * 2 + j] ^ in[4 * 3 + j]) \u0026amp; 0xff); out[4 * 1 + j] = (byte) ((in[4 * 0 + j] ^ gmul(in[4 * 1 + j], 2) ^ gmul(in[4 * 2 + j], 3) ^ in[4 * 3 + j]) \u0026amp; 0xff); out[4 * 2 + j] = (byte) ((in[4 * 0 + j] ^ in[4 * 1 + j] ^ gmul(in[4 * 2 + j], 2) ^ gmul(in[4 * 3 + j], 3)) \u0026amp; 0xff); out[4 * 3 + j] = (byte) ((gmul(in[4 * 0 + j], 3) ^ in[4 * 1 + j] ^ in[4 * 2 + j] ^ gmul(in[4 * 3 + j], 2)) \u0026amp; 0xff); } for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { temp[4 * j + i] = out[4 * i + j]; } } out = temp; return out; } /* Inverse Mix Columns */ private byte[] inverseMixColumns(byte[] in) { byte[] out = new byte[BITS]; byte[] temp = new byte[BITS]; for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { temp[4 * j + i] = in[4 * i + j]; } } in = temp; for (int j = 0; j \u0026lt; BITS / 4; j++) { out[4 * 0 + j] = (byte) ((gmul(in[4 * 0 + j], 14) ^ gmul(in[4 * 1 + j], 11) ^ gmul(in[4 * 2 + j], 13) ^ gmul(in[4 * 3 + j], 9)) \u0026amp; 0xff); out[4 * 1 + j] = (byte) ((gmul(in[4 * 0 + j], 9) ^ gmul(in[4 * 1 + j], 14) ^ gmul(in[4 * 2 + j], 11) ^ gmul(in[4 * 3 + j], 13)) \u0026amp; 0xff); out[4 * 2 + j] = (byte) ((gmul(in[4 * 0 + j], 13) ^ gmul(in[4 * 1 + j], 9) ^ gmul(in[4 * 2 + j], 14) ^ gmul(in[4 * 3 + j], 11)) \u0026amp; 0xff); out[4 * 3 + j] = (byte) ((gmul(in[4 * 0 + j], 11) ^ gmul(in[4 * 1 + j], 13) ^ gmul(in[4 * 2 + j], 9) ^ gmul(in[4 * 3 + j], 14)) \u0026amp; 0xff); } for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { temp[4 * j + i] = out[4 * i + j]; } } out = temp; return out; } private byte[] hexStringToByteArray(String string) { int length = string.length(); int n = (int) Math.ceil((length + 1) / 2); byte[] result = new byte[n]; for (int i = length - 1; i \u0026gt;= 0; i -= 2) { if (i == 0) { result[i / 2] = (byte) ((Character.digit(\u0026#39;0\u0026#39;, 16) \u0026lt;\u0026lt; 4) + Character.digit(string.charAt(i), 16)); } else { result[i / 2] = (byte) ((Character.digit(string.charAt(i - 1), 16) \u0026lt;\u0026lt; 4) + Character.digit(string.charAt(i), 16)); } } return result; } /* * http://stackoverflow.com/questions/9655181/convert-from-byte-array-to-hex- * string-in-java */ public static String bytesToHex(byte[] bytes) { char[] hexChars = new char[bytes.length * 2]; for (int j = 0; j \u0026lt; bytes.length; j++) { int v = bytes[j] \u0026amp; 0xFF; hexChars[j * 2] = hexArray[v \u0026gt;\u0026gt;\u0026gt; 4]; hexChars[j * 2 + 1] = hexArray[v \u0026amp; 0x0F]; } return new String(hexChars); } private void printBytes(byte[] input) { for (int i = 0; i \u0026lt; input.length; i++) { System.out.print(byteToBits(input[i]) + \u0026#34; \u0026#34;); } System.out.println(); } private void printByte(String msg, byte input) { byte[] temp = new byte[1]; temp[0] = input; System.out.println(msg + \u0026#34;: \u0026#34; + bytesToHex(temp)); } private String byteToBits(byte b) { StringBuffer buffer = new StringBuffer(); for (int i = 0; i \u0026lt; 8; i++) buffer.append((int) (b \u0026gt;\u0026gt; (8 - (i + 1)) \u0026amp; 0x0001)); return buffer.toString(); } private byte[] getRoundKey(int round) { byte[] out = new byte[KEY_LENGTH]; out = Arrays.copyOfRange(word, 16 * round, 16 * round + 16); return out; } public static byte[] XORBytes(byte[] in1, byte[] in2) { byte[] out = new byte[in1.length]; for (int i = 0; i \u0026lt; in1.length; i++) { out[i] = (byte) ((in1[i] ^ in2[i]) \u0026amp; 0xff); } return out; } public byte[] encryptText(byte[] plainText, byte[] key) throws Exception { byte[] cipher = new byte[BLOCK_LENGTH]; this.word = expandKey(key); byte[] roundKey = getRoundKey(0); /* Round 0 */ cipher = XORBytes(plainText, roundKey); // System.out.println(\u0026#34;Round 0\\n\u0026#34; + bytesToHex(cipher));  /* Rounds 1 to 9 */ for (int i = 1; i \u0026lt; 10; i++) { // System.out.println(\u0026#34;Round \u0026#34; + i);  cipher = subBytes(cipher); // System.out.println(\u0026#34;SubBytes: \u0026#34; + bytesToHex(cipher));  cipher = shiftRows(cipher); // System.out.println(\u0026#34;ShiftRows: \u0026#34; + bytesToHex(cipher));  cipher = mixColumns(cipher); // System.out.println(\u0026#34;MixColumns: \u0026#34; + bytesToHex(cipher));  roundKey = getRoundKey(i); // System.out.println(\u0026#34;RoundKey: \u0026#34; + bytesToHex(roundKey));  cipher = XORBytes(cipher, roundKey); // System.out.println(\u0026#34;CIPHER: \u0026#34; + bytesToHex(cipher));  } /* Round 10 */ // System.out.println(\u0026#34;Round 10\u0026#34;);  cipher = subBytes(cipher); // System.out.println(\u0026#34;SubBytes: \u0026#34; + bytesToHex(cipher));  cipher = shiftRows(cipher); // System.out.println(\u0026#34;ShiftRows: \u0026#34; + bytesToHex(cipher));  roundKey = getRoundKey(10); // System.out.println(\u0026#34;RoundKey: \u0026#34; + bytesToHex(roundKey));  cipher = XORBytes(cipher, roundKey); // System.out.println(\u0026#34;CIPHER: \u0026#34; + bytesToHex(cipher));  return cipher; } public byte[] decryptText(byte[] cipher, byte[] key) throws Exception { byte[] plainText = new byte[BLOCK_LENGTH]; this.word = expandKey(key); byte[] roundKey = getRoundKey(10); /* Round 0 */ plainText = XORBytes(cipher, roundKey); /* Rounds 1 to 9 */ for (int i = 9; i \u0026gt; 0; i--) { plainText = inverseShiftRows(plainText); plainText = inverseSubBytes(plainText); roundKey = getRoundKey(i); plainText = XORBytes(plainText, roundKey); plainText = inverseMixColumns(plainText); } /* Round 10 */ plainText = inverseShiftRows(plainText); plainText = inverseSubBytes(plainText); roundKey = getRoundKey(0); plainText = XORBytes(plainText, roundKey); return plainText; } public static void main(String[] args) throws Exception { try { if (args.length != 1) { System.out.println(\u0026#34;Usage: java \u0026lt; classname \u0026gt; \u0026lt; mode \u0026gt;\u0026#34; + \u0026#34;\\n\\t\u0026lt; mode \u0026gt; := (ECB|CBC|OFB|CFB)\u0026#34;); return; } /* ECB, CBC, OFB, or CFB */ String mode = args[0]; // String mode = \u0026#34;CFB\u0026#34;;  mode = mode.toUpperCase(); AESdecrypt aes = new AESdecrypt(mode); File keyFile = new File(\u0026#34;AESkey.txt\u0026#34;); File textFile = new File(\u0026#34;AESplaintext.txt\u0026#34;); File cipherFile = new File(\u0026#34;AESciphertext.txt\u0026#34;); FileReader keyFileReader = new FileReader(keyFile); BufferedReader bufferedReader = new BufferedReader(keyFileReader); FileInputStream cipherFileInputStream = new FileInputStream(cipherFile); FileOutputStream textFileOutputStream = new FileOutputStream(textFile); byte[] key = new byte[(int) keyFile.length()]; String keyString = bufferedReader.readLine(); key = aes.hexStringToByteArray(keyString); byte[] cipher = new byte[(int) cipherFile.length()]; cipherFileInputStream.read(cipher); byte[] message = aes.decrypt(cipher, key); textFileOutputStream.write(message); textFileOutputStream.flush(); textFileOutputStream.close(); bufferedReader.close(); cipherFileInputStream.close(); System.out.println(\u0026#34;Decryption done! Please check AESplaintext.txt for output!\u0026#34;); } catch (Exception exp) { exp.printStackTrace(); } } private byte[] decrypt(byte[] message, byte[] key) throws Exception { if (message.length \u0026lt; 16) { System.out.println(\u0026#34;Message should be atleast 64 bits\u0026#34;); System.exit(1); } if (key.length != 16) { System.out.println(\u0026#34;Key should be 64 bits\u0026#34;); System.exit(1); } int length = message.length; int n = (length + 15) / 16 * 16; byte[] cipher = new byte[n]; if (length == 16) { if (mode.equals(\u0026#34;ECB\u0026#34;)) { return decryptText(message, key); } else if (mode.equals(\u0026#34;CBC\u0026#34;)) { byte[] iv = getInitializationVector(); message = XORBytes(message, iv); return decryptText(message, key); } else if (mode.equals(\u0026#34;OFB\u0026#34;)) { byte[] nounce = getNounce(); byte[] temp = encryptText(nounce, key); byte[] result = XORBytes(temp, message); return result; } else if (mode.equals(\u0026#34;CFB\u0026#34;)) { } else { System.out.println(\u0026#34;Unsupported mode of operation!\u0026#34;); return null; } } int i = 0; int k = 0; byte[] feedback = new byte[16]; if (mode.equals(\u0026#34;CBC\u0026#34;)) { feedback = getInitializationVector(); } else if (mode.equals(\u0026#34;OFB\u0026#34;)) { feedback = getNounce(); } else if (mode.equals(\u0026#34;CFB\u0026#34;)) { feedback = getInitializationVectorCFB(); } while (i \u0026lt; length) { byte[] block = new byte[16]; byte[] result = new byte[16]; int j = 0; for (; j \u0026lt; 16 \u0026amp;\u0026amp; i \u0026lt; length; j++, i++) { block[j] = message[i]; } while (j \u0026lt; 16) { /* pad with white spaces */ block[j++] = 0x20; } // System.out.println(\u0026#34;BLOCK: \u0026#34;);  // printBytes(block);  if (mode.equals(\u0026#34;ECB\u0026#34;)) { result = decryptText(block, key); } else if (mode.equals(\u0026#34;CBC\u0026#34;)) { result = decryptText(block, key); result = XORBytes(result, feedback); feedback = Arrays.copyOfRange(block, 0, 16); } else if (mode.equals(\u0026#34;OFB\u0026#34;)) { result = encryptText(feedback, key); feedback = Arrays.copyOfRange(result, 0, 16); result = XORBytes(result, block); } else if (mode.equals(\u0026#34;CFB\u0026#34;)) { result = encryptText(feedback, key); byte[] resultPart = Arrays.copyOfRange(result, 0, 8); byte[] blockPart = Arrays.copyOfRange(block, 0, 8); byte[] temp1 = XORBytes(resultPart, blockPart); feedback = mergeBytes(Arrays.copyOfRange(result, 8, 16), blockPart); resultPart = Arrays.copyOfRange(result, 8, 16); blockPart = Arrays.copyOfRange(block, 8, 16); result = encryptText(feedback, key); byte[] temp2 = XORBytes(resultPart, blockPart); feedback = mergeBytes(Arrays.copyOfRange(result, 8, 16), blockPart); result = mergeBytes(temp1, temp2); } else { System.out.println(\u0026#34;Unsupported mode of operation!\u0026#34;); return null; } // System.out.println(\u0026#34;RESULT: \u0026#34;);  // printBytes(result);  for (j = 0; j \u0026lt; 16 \u0026amp;\u0026amp; k \u0026lt; cipher.length; j++, k++) { cipher[k] = result[j]; } } return cipher; } private byte[] getInitializationVector() { return hexStringToByteArray(\u0026#34;247D8AC4DDB1AA739DC593821D0BC432\u0026#34;); } private byte[] getInitializationVectorCFB() { return hexStringToByteArray(\u0026#34;247D8AC4DDB1AA739DC593821D0BC432\u0026#34;); } private byte[] getNounce() { // char[] hexArray = \u0026#34;0123456789ABCDEF\u0026#34;.toCharArray();  // String nounceStr = \u0026#34;\u0026#34;;  // for (int i = 0 ; i \u0026lt; 16 ; i++) {  // double random = Math.random();  // int index = (int) (random * 16);  // nounceStr += hexArray[index];  // }  // return hexStringToByteArray(nounceStr);  return hexStringToByteArray(\u0026#34;247D8AC4DDB1AA739DC593821D0BC432\u0026#34;); } private byte[] mergeBytes(byte[] in1, byte[] in2) { byte[] out = new byte[in1.length + in2.length]; int i = 0; for (int j = 0; j \u0026lt; in1.length; j++) { out[i++] = in1[j]; } for (int j = 0; j \u0026lt; in2.length; j++) { out[i++] = in2[j]; } return out; } } Output\ndhanoopbhaskar@dhanoop-laptop:~/workspace/Copy/crypto/run_aes$ java AESkeygen Key generated and saved in AESkey.txt dhanoopbhaskar@dhanoop-laptop:~/workspace/Copy/crypto/run_aes$ java AESencrypt Usage: java \u0026lt; classname \u0026gt; \u0026lt; mode \u0026gt; \u0026lt; mode \u0026gt; := (ECB|CBC|OFB|CFB) dhanoopbhaskar@dhanoop-laptop:~/workspace/Copy/crypto/run_aes$ java AESencrypt ecb Encryption done! Please check AESciphertext.txt for output! dhanoopbhaskar@dhanoop-laptop:~/workspace/Copy/crypto/run_aes$ java AESdecrypt ecb Decryption done! Please check AESplaintext.txt for output! dhanoopbhaskar@dhanoop-laptop:~/workspace/Copy/crypto/run_aes$ java AESencrypt cbc Encryption done! Please check AESciphertext.txt for output! dhanoopbhaskar@dhanoop-laptop:~/workspace/Copy/crypto/run_aes$ java AESdecrypt cbc Decryption done! Please check AESplaintext.txt for output! dhanoopbhaskar@dhanoop-laptop:~/workspace/Copy/crypto/run_aes$ java AESencrypt ofb Encryption done! Please check AESciphertext.txt for output! dhanoopbhaskar@dhanoop-laptop:~/workspace/Copy/crypto/run_aes$ java AESdecrypt ofb Decryption done! Please check AESplaintext.txt for output! dhanoopbhaskar@dhanoop-laptop:~/workspace/Copy/crypto/run_aes$ java AESencrypt cfb Encryption done! Please check AESciphertext.txt for output! dhanoopbhaskar@dhanoop-laptop:~/workspace/Copy/crypto/run_aes$ java AESdecrypt cfb Decryption done! Please check AESplaintext.txt for output! dhanoopbhaskar@dhanoop-laptop:~/workspace/Copy/crypto/run_aes$  About Input/Output Files\nAESkeygen.java - (output) AESkey.txt\nAESencrypt.java - (input) AESkey.txt \u0026amp; AESplaintext.txt (output) AESciphertext.txt\nAESdecrypt.java - (input) AESkey.txt \u0026amp; AESciphertext.txt (output) AESplaintext.txt\n",
    "ref": "/blog/2014-07-30-aes-implementation-in-java-with-ecb-cbc-ofb-cfb-modes-of-operation/"
  },{
    "title": "DES Implementation In Java with ECB | CBC | OFB | CFB Modes Of Operation",
    "date": "July 30, 2014",
    "description": "",
    "body": "Note that these are ONLY basic level programs for easy understanding of the Data Encryption Standard (DES) algorithm\nKey Generation - DESkeygen.java\nimport java.io.File; import java.io.FileWriter; public class DESkeygen { private final File file = new File(\u0026#34;DESkey.txt\u0026#34;); private final int KEY_LENGTH = 16; private final static char[] hexArray = \u0026#34;0123456789ABCDEF\u0026#34;.toCharArray(); public DESkeygen() { try { FileWriter fileWriter = new FileWriter(file); fileWriter.write(\u0026#34;\u0026#34;); for (int i = 0; i \u0026lt; KEY_LENGTH; i++) { double random = Math.random(); int index = (int) (random * 16); fileWriter.append(hexArray[index]); fileWriter.flush(); } fileWriter.close(); System.out.println(\u0026#34;Key generated and saved in \u0026#34; + file.getName()); } catch (Exception exp) { exp.printStackTrace(); } } public static void main(String[] args) { new DESkeygen(); } } Encryption - DESencrypt.java\nimport java.io.BufferedReader; import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.FileReader; import java.io.FileWriter; import java.util.Arrays; public class DESencrypt { private String mode = null; final protected static char[] hexArray = \u0026#34;0123456789ABCDEF\u0026#34;.toCharArray(); /* Initial Permutation */ static final int[] IP = { 58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8, 57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7 }; /* Inverse Initial Permutation */ static final int[] IIP = { 40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29, 36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25 }; /* Expansion Permutation */ static final int[] E = { 32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17, 16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1 }; /* Permutation Function */ static final int[] P = { 16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10, 2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25 }; /* S-Boxes*/ static final int[] S1 = { 14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7, 0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8, 4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0, 15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13 }; static final int[] S2 = { 15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10, 3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5, 0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15, 13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9 }; static final int[] S3 = { 10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8, 13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1, 13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7, 1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12 }; static final int[] S4 = { 7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15, 13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9, 10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4, 3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14 }; static final int[] S5 = { 2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9, 14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6, 4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14, 11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3 }; static final int[] S6 = { 12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11, 10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8, 9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6, 4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13 }; static final int[] S7 = { 4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1, 13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6, 1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2, 6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12 }; static final int[] S8 = { 13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7, 1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2, 7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8, 2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11 }; /* Permuted Choice One */ static final int[] PC1 = { 57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4 }; /* Permuted Choice Two */ static final int[] PC2 = { 14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32 }; /* Schedule of Left Shifts */ static final int[] SHIFTS = { 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1 }; public DESencrypt() { this.mode = \u0026#34;ECB\u0026#34;; } public DESencrypt(String mode) { this.mode = mode; } private byte[] performXOR(byte[] one, byte[] two) { byte[] result = new byte[one.length]; for (int i = 0; i \u0026lt; one.length; i++) { result[i] = (byte) (one[i] ^ two[i]); } return result; } private byte[] permute(byte[] input, int[] mapping) { int byteCount = 1 + (mapping.length - 1) / 8; byte[] output = new byte[byteCount]; int pos; for (int i = 0; i \u0026lt; mapping.length; i++) { pos = mapping[i] - 1; int value = getBitFromArray(input, pos); setBitInArray(output, i, value); } return output; } private int getBitFromArray(byte[] array, int pos) { int value; int bytePos = pos / 8; int bitPos = pos % 8; value = (array[bytePos] \u0026gt;\u0026gt; (8 - (bitPos + 1))) \u0026amp; 0x0001; /* * eg: right shift selected byte 5 times to get 3rd bit (bitPos = 2) at * rightmost position and then AND with 0x0001 */ return value; } private void setBitInArray(byte[] input, int pos, int value) { int bytePos = pos / 8; int bitPos = pos % 8; byte old = input[bytePos]; old = (byte) (((0xFF7F \u0026gt;\u0026gt; bitPos) \u0026amp; old) \u0026amp; 0x00FF); byte newByte = (byte) ((value \u0026lt;\u0026lt; (8 - (bitPos + 1))) | old); input[bytePos] = newByte; } private byte[] hexStringToByteArray(String string) { int length = string.length(); int n = (int) Math.ceil((length + 1) / 2); byte[] result = new byte[n]; for (int i = length - 1; i \u0026gt;= 0; i -= 2) { if (i == 0) { result[i / 2] = (byte) ((Character.digit(\u0026#39;0\u0026#39;, 16) \u0026lt;\u0026lt; 4) + Character.digit(string.charAt(i), 16)); } else { result[i / 2] = (byte) ((Character.digit(string.charAt(i - 1), 16) \u0026lt;\u0026lt; 4) + Character.digit(string.charAt(i), 16)); } } return result; } public static String bytesToHex(byte[] bytes) { char[] hexChars = new char[bytes.length * 2]; for (int j = 0; j \u0026lt; bytes.length; j++) { int v = bytes[j] \u0026amp; 0xFF; hexChars[j * 2] = hexArray[v \u0026gt;\u0026gt;\u0026gt; 4]; hexChars[j * 2 + 1] = hexArray[v \u0026amp; 0x0F]; } return new String(hexChars); } private void printBytes(byte[] input) { for (int i = 0; i \u0026lt; input.length; i++) { System.out.print(byteToBits(input[i]) + \u0026#34; \u0026#34;); } System.out.println(); } private String byteToBits(byte b) { StringBuffer buffer = new StringBuffer(); for (int i = 0; i \u0026lt; 8; i++) buffer.append((int) (b \u0026gt;\u0026gt; (8 - (i + 1)) \u0026amp; 0x0001)); return buffer.toString(); } private byte[] getBits(byte[] input, int startPos, int length) { int noOfBytes = (length - 1) / 8 + 1; byte[] output = new byte[noOfBytes]; for (int i = 0; i \u0026lt; length; i++) { int value = getBitFromArray(input, startPos + i); setBitInArray(output, i, value); } return output; } private byte[] rotateLeft(byte[] input, int step, int length) { int noOfBytes = (length - 1) / 8 + 1; byte[] output = new byte[noOfBytes]; for (int i = 0; i \u0026lt; length; i++) { int value = getBitFromArray(input, (i + step) % length); setBitInArray(output, i, value); } return output; } private byte[] concatBits(byte[] one, int oneLength, byte[] two, int twoLength) { int noOfBytes = (oneLength + twoLength - 1) / 8 + 1; byte[] output = new byte[noOfBytes]; int i = 0, j = 0; for (; i \u0026lt; oneLength; i++) { int value = getBitFromArray(one, i); setBitInArray(output, j, value); j++; } for (i = 0; i \u0026lt; twoLength; i++) { int value = getBitFromArray(two, i); setBitInArray(output, j, value); j++; } return output; } private byte[][] getSubKeys(byte[] masterKey) { int noOfSubKeys = SHIFTS.length; int keySize = PC1.length; byte[] key = permute(masterKey, PC1); byte[][] subKeys = new byte[noOfSubKeys][keySize]; byte[] leftHalf = getBits(key, 0, keySize / 2); byte[] rightHalf = getBits(key, keySize / 2, keySize / 2); for (int i = 0; i \u0026lt; noOfSubKeys; i++) { leftHalf = rotateLeft(leftHalf, SHIFTS[i], keySize / 2); rightHalf = rotateLeft(rightHalf, SHIFTS[i], keySize / 2); byte[] subKey = concatBits(leftHalf, keySize / 2, rightHalf, keySize / 2); subKeys[i] = permute(subKey, PC2); } return subKeys; } public byte[] crypt(byte[] message, byte[] key, String operation) { if (message.length \u0026lt; 8) { System.out.println(\u0026#34;Message should be atleast 64 bits\u0026#34;); System.exit(1); } if (key.length != 8) { System.out.println(\u0026#34;Key should be 64 bits\u0026#34;); System.exit(1); } int length = message.length; int n = (length + 7) / 8 * 8; byte[] cipher = new byte[n]; if (length == 8) { if (mode.equals(\u0026#34;ECB\u0026#34;)) { return cryptText(message, key, operation); } else if (mode.equals(\u0026#34;CBC\u0026#34;)) { byte[] iv = getInitializationVector(); message = XORBytes(message, iv); return cryptText(message, key, operation); } else if (mode.equals(\u0026#34;OFB\u0026#34;)) { byte[] nounce = getNounce(); byte[] temp = cryptText(nounce, key, operation); byte[] result = XORBytes(temp, message); return result; } else if (mode.equals(\u0026#34;CFB\u0026#34;)) { } else { System.out.println(\u0026#34;Unsupported mode of operation!\u0026#34;); return null; } } int i = 0; int k = 0; byte[] feedback = new byte[8]; if (mode.equals(\u0026#34;CBC\u0026#34;)) { feedback = getInitializationVector(); } else if (mode.equals(\u0026#34;OFB\u0026#34;)) { feedback = getNounce(); } else if (mode.equals(\u0026#34;CFB\u0026#34;)) { feedback = getInitializationVectorCFB(); } while (i \u0026lt; length) { byte[] block = new byte[8]; byte[] result = new byte[8]; int j = 0; for (; j \u0026lt; 8 \u0026amp;\u0026amp; i \u0026lt; length; j++, i++) { block[j] = message[i]; } while (j \u0026lt; 8) { /* pad with white spaces */ block[j++] = 0x20; } // System.out.println(\u0026#34;BLOCK: \u0026#34;);  // printBytes(block);  if (mode.equals(\u0026#34;ECB\u0026#34;)) { result = cryptText(block, key, operation); } else if (mode.equals(\u0026#34;CBC\u0026#34;)) { if (operation.equals(\u0026#34;encrypt\u0026#34;)) { block = XORBytes(block, feedback); result = cryptText(block, key, operation); feedback = Arrays.copyOfRange(result, 0, 8); } else if (operation.equals(\u0026#34;decrypt\u0026#34;)) { result = cryptText(block, key, operation); result = XORBytes(result, feedback); feedback = Arrays.copyOfRange(block, 0, 8); } } else if (mode.equals(\u0026#34;OFB\u0026#34;)) { result = cryptText(feedback, key, operation); feedback = Arrays.copyOfRange(result, 0, 8); result = XORBytes(result, block); } else if (mode.equals(\u0026#34;CFB\u0026#34;)) { if (operation.equals(\u0026#34;encrypt\u0026#34;)) { result = cryptText(feedback, key, operation); byte[] resultPart = Arrays.copyOfRange(result, 0, 4); byte[] blockPart = Arrays.copyOfRange(block, 0, 4); byte[] temp1 = XORBytes(resultPart, blockPart); feedback = mergeBytes(Arrays.copyOfRange(result, 4, 8), temp1); resultPart = Arrays.copyOfRange(result, 4, 8); blockPart = Arrays.copyOfRange(block, 4, 8); result = cryptText(feedback, key, operation); byte[] temp2 = XORBytes(resultPart, blockPart); feedback = mergeBytes(Arrays.copyOfRange(result, 4, 8), temp2); result = mergeBytes(temp1, temp2); } else if (operation.equals(\u0026#34;decrypt\u0026#34;)) { result = cryptText(feedback, key, \u0026#34;encrypt\u0026#34;); byte[] resultPart = Arrays.copyOfRange(result, 0, 4); byte[] blockPart = Arrays.copyOfRange(block, 0, 4); byte[] temp1 = XORBytes(resultPart, blockPart); feedback = mergeBytes(Arrays.copyOfRange(result, 4, 8), blockPart); resultPart = Arrays.copyOfRange(result, 4, 8); blockPart = Arrays.copyOfRange(block, 4, 8); result = cryptText(feedback, key, \u0026#34;encrypt\u0026#34;); byte[] temp2 = XORBytes(resultPart, blockPart); feedback = mergeBytes(Arrays.copyOfRange(result, 4, 8), blockPart); result = mergeBytes(temp1, temp2); } } else { System.out.println(\u0026#34;Unsupported mode of operation!\u0026#34;); return null; } // System.out.println(\u0026#34;RESULT: \u0026#34;);  // printBytes(result);  for (j = 0; j \u0026lt; 8 \u0026amp;\u0026amp; k \u0026lt; cipher.length; j++, k++) { cipher[k] = result[j]; } } return cipher; } private byte[] getInitializationVector() { return hexStringToByteArray(\u0026#34;DCBE6AE7EA5D5C61\u0026#34;); } private byte[] getInitializationVectorCFB() { return hexStringToByteArray(\u0026#34;A5D5C61EFADB4351\u0026#34;); } private byte[] getNounce() { // char[] hexArray = \u0026#34;0123456789ABCDEF\u0026#34;.toCharArray();  // String nounceStr = \u0026#34;\u0026#34;;  // for (int i = 0 ; i \u0026lt; 16 ; i++) {  // double random = Math.random();  // int index = (int) (random * 16);  // nounceStr += hexArray[index];  // }  // return hexStringToByteArray(nounceStr);  return hexStringToByteArray(\u0026#34;DCBE6AE7EA5D5C61\u0026#34;); } private byte[] mergeBytes(byte[] in1, byte[] in2) { byte[] out = new byte[in1.length + in2.length]; int i = 0; for (int j = 0; j \u0026lt; in1.length; j++) { out[i++] = in1[j]; } for (int j = 0; j \u0026lt; in2.length; j++) { out[i++] = in2[j]; } return out; } public byte[] cryptText(byte[] message, byte[] key, String operation) { if (message.length != 8) { System.out.println(\u0026#34;Message should be 64 bits\u0026#34;); System.exit(1); } if (key.length != 8) { System.out.println(\u0026#34;Key should be 64 bits\u0026#34;); System.exit(1); } byte[] result = null; int blockSize = IP.length; byte[][] subKeys = getSubKeys(key); int noOfRounds = subKeys.length; /** * Initial Permutation */ message = permute(message, IP); /** * Split message into two halves */ byte[] leftHalf = getBits(message, 0, blockSize / 2); byte[] rightHalf = getBits(message, blockSize / 2, blockSize / 2); for (int i = 0; i \u0026lt; noOfRounds; i++) { byte[] temp = rightHalf; /** * Expansion */ rightHalf = permute(rightHalf, E); /** * XOR rightHalf with roundKey */ byte[] roundKey = null; if (operation.equalsIgnoreCase(\u0026#34;encrypt\u0026#34;)) { roundKey = subKeys[i]; } else if (operation.equalsIgnoreCase(\u0026#34;decrypt\u0026#34;)) { roundKey = subKeys[noOfRounds - i - 1]; } else { System.out.println(\u0026#34;Unsupported operation\u0026#34;); System.exit(0); } rightHalf = performXOR(rightHalf, roundKey); /** * S-Box */ rightHalf = sBox(rightHalf); /** * Permutation */ rightHalf = permute(rightHalf, P); /** * XOR rightHalf with leftHalf */ rightHalf = performXOR(rightHalf, leftHalf); /** * L(i) = R(i-1) */ leftHalf = temp; } /** * 32 bit swap */ byte[] concatHalves = concatBits(rightHalf, blockSize / 2, leftHalf, blockSize / 2); /** * Inverse Initial Permutation */ result = permute(concatHalves, IIP); return result; } public static byte[] XORBytes(byte[] in1, byte[] in2) { byte[] out = new byte[in1.length]; for (int i = 0; i \u0026lt; in1.length; i++) { out[i] = (byte) ((in1[i] ^ in2[i]) \u0026amp; 0xff); } return out; } private byte[] sBox(byte[] input) { /** * Split input to 6-bit blocks */ input = split(input, 6); byte[] output = new byte[input.length / 2]; int leftHalf = 0; for (int i = 0; i \u0026lt; input.length; i++) { byte block = input[i]; /** * row - first and last bits column - 4 bits in the middle */ int row = 2 * (block \u0026gt;\u0026gt; 7 \u0026amp; 0x0001) + (block \u0026gt;\u0026gt; 2 \u0026amp; 0x0001); int col = block \u0026gt;\u0026gt; 3 \u0026amp; 0x000F; int[] selectedSBox = getSBox(i); int rightHalf = selectedSBox[16 * row + col]; if (i % 2 == 0) { leftHalf = rightHalf; } else { output[i / 2] = (byte) (16 * leftHalf + rightHalf); leftHalf = 0; } } return output; } private int[] getSBox(int i) { switch (i) { case 0: return S1; case 1: return S2; case 2: return S3; case 3: return S4; case 4: return S5; case 5: return S6; case 6: return S7; case 7: return S8; default: return null; } } private byte[] split(byte[] input, int length) { int noOfBytes = (8 * input.length - 1) / length + 1; byte[] output = new byte[noOfBytes]; for (int i = 0; i \u0026lt; noOfBytes; i++) { for (int j = 0; j \u0026lt; length; j++) { int value = getBitFromArray(input, length * i + j); setBitInArray(output, 8 * i + j, value); } } return output; } public static void main(String[] args) { try { if (args.length != 1) { System.out.println(\u0026#34;Usage: java \u0026lt; classname \u0026gt; \u0026lt; mode \u0026gt;\u0026#34; + \u0026#34;\\n\\t\u0026lt; mode \u0026gt; := (ECB|CBC|OFB|CFB)\u0026#34;); return; } /* ECB, CBC, OFB, or CFB */ String mode = args[0]; mode = mode.toUpperCase(); DESencrypt des = new DESencrypt(mode); File keyFile = new File(\u0026#34;DESkey.txt\u0026#34;); File textFile = new File(\u0026#34;DESplaintext.txt\u0026#34;); File cipherFile = new File(\u0026#34;DESciphertext.txt\u0026#34;); FileReader keyFileReader = new FileReader(keyFile); BufferedReader bufferedReader = new BufferedReader(keyFileReader); FileInputStream textFileInputStream = new FileInputStream(textFile); FileOutputStream cipherFileOutputStream = new FileOutputStream(cipherFile); byte[] key = new byte[(int) keyFile.length()]; String keyString = bufferedReader.readLine(); key = des.hexStringToByteArray(keyString); byte[] message = new byte[(int) textFile.length()]; textFileInputStream.read(message); byte[] cipher = des.crypt(message, key, \u0026#34;encrypt\u0026#34;); cipherFileOutputStream.write(cipher); cipherFileOutputStream.flush(); cipherFileOutputStream.close(); bufferedReader.close(); textFileInputStream.close(); System.out.println(\u0026#34;Encryption done! Please check DESciphertext.txt for output!\u0026#34;); } catch (Exception exp) { exp.printStackTrace(); } } } Decryption - DESdecrypt.java\nimport java.io.BufferedReader; import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.FileReader; import java.io.FileWriter; import java.util.Arrays; public class DESdecrypt { private String mode = null; final protected static char[] hexArray = \u0026#34;0123456789ABCDEF\u0026#34;.toCharArray(); /* Initial Permutation */ static final int[] IP = { 58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8, 57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7 }; /* Inverse Initial Permutation */ static final int[] IIP = { 40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29, 36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25 }; /* Expansion Permutation */ static final int[] E = { 32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17, 16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1 }; /* Permutation Function */ static final int[] P = { 16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10, 2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25 }; /* S-Boxes*/ static final int[] S1 = { 14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7, 0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8, 4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0, 15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13 }; static final int[] S2 = { 15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10, 3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5, 0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15, 13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9 }; static final int[] S3 = { 10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8, 13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1, 13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7, 1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12 }; static final int[] S4 = { 7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15, 13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9, 10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4, 3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14 }; static final int[] S5 = { 2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9, 14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6, 4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14, 11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3 }; static final int[] S6 = { 12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11, 10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8, 9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6, 4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13 }; static final int[] S7 = { 4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1, 13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6, 1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2, 6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12 }; static final int[] S8 = { 13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7, 1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2, 7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8, 2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11 }; /* Permuted Choice One */ static final int[] PC1 = { 57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4 }; /* Permuted Choice Two */ static final int[] PC2 = { 14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32 }; /* Schedule of Left Shifts */ static final int[] SHIFTS = { 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1 }; public DESdecrypt() { this.mode = \u0026#34;ECB\u0026#34;; } public DESdecrypt(String mode) { this.mode = mode; } private byte[] performXOR(byte[] one, byte[] two) { byte[] result = new byte[one.length]; for (int i = 0; i \u0026lt; one.length; i++) { result[i] = (byte) (one[i] ^ two[i]); } return result; } private byte[] permute(byte[] input, int[] mapping) { int byteCount = 1 + (mapping.length - 1) / 8; byte[] output = new byte[byteCount]; int pos; for (int i = 0; i \u0026lt; mapping.length; i++) { pos = mapping[i] - 1; int value = getBitFromArray(input, pos); setBitInArray(output, i, value); } return output; } private int getBitFromArray(byte[] array, int pos) { int value; int bytePos = pos / 8; int bitPos = pos % 8; value = (array[bytePos] \u0026gt;\u0026gt; (8 - (bitPos + 1))) \u0026amp; 0x0001; /* * eg: right shift selected byte 5 times to get 3rd bit (bitPos = 2) at * rightmost position and then AND with 0x0001 */ return value; } private void setBitInArray(byte[] input, int pos, int value) { int bytePos = pos / 8; int bitPos = pos % 8; byte old = input[bytePos]; old = (byte) (((0xFF7F \u0026gt;\u0026gt; bitPos) \u0026amp; old) \u0026amp; 0x00FF); byte newByte = (byte) ((value \u0026lt;\u0026lt; (8 - (bitPos + 1))) | old); input[bytePos] = newByte; } private byte[] hexStringToByteArray(String string) { int length = string.length(); int n = (int) Math.ceil((length + 1) / 2); byte[] result = new byte[n]; for (int i = length - 1; i \u0026gt;= 0; i -= 2) { if (i == 0) { result[i / 2] = (byte) ((Character.digit(\u0026#39;0\u0026#39;, 16) \u0026lt;\u0026lt; 4) + Character.digit(string.charAt(i), 16)); } else { result[i / 2] = (byte) ((Character.digit(string.charAt(i - 1), 16) \u0026lt;\u0026lt; 4) + Character.digit(string.charAt(i), 16)); } } return result; } public static String bytesToHex(byte[] bytes) { char[] hexChars = new char[bytes.length * 2]; for (int j = 0; j \u0026lt; bytes.length; j++) { int v = bytes[j] \u0026amp; 0xFF; hexChars[j * 2] = hexArray[v \u0026gt;\u0026gt;\u0026gt; 4]; hexChars[j * 2 + 1] = hexArray[v \u0026amp; 0x0F]; } return new String(hexChars); } private void printBytes(byte[] input) { for (int i = 0; i \u0026lt; input.length; i++) { System.out.print(byteToBits(input[i]) + \u0026#34; \u0026#34;); } System.out.println(); } private String byteToBits(byte b) { StringBuffer buffer = new StringBuffer(); for (int i = 0; i \u0026lt; 8; i++) buffer.append((int) (b \u0026gt;\u0026gt; (8 - (i + 1)) \u0026amp; 0x0001)); return buffer.toString(); } private byte[] getBits(byte[] input, int startPos, int length) { int noOfBytes = (length - 1) / 8 + 1; byte[] output = new byte[noOfBytes]; for (int i = 0; i \u0026lt; length; i++) { int value = getBitFromArray(input, startPos + i); setBitInArray(output, i, value); } return output; } private byte[] rotateLeft(byte[] input, int step, int length) { int noOfBytes = (length - 1) / 8 + 1; byte[] output = new byte[noOfBytes]; for (int i = 0; i \u0026lt; length; i++) { int value = getBitFromArray(input, (i + step) % length); setBitInArray(output, i, value); } return output; } private byte[] concatBits(byte[] one, int oneLength, byte[] two, int twoLength) { int noOfBytes = (oneLength + twoLength - 1) / 8 + 1; byte[] output = new byte[noOfBytes]; int i = 0, j = 0; for (; i \u0026lt; oneLength; i++) { int value = getBitFromArray(one, i); setBitInArray(output, j, value); j++; } for (i = 0; i \u0026lt; twoLength; i++) { int value = getBitFromArray(two, i); setBitInArray(output, j, value); j++; } return output; } private byte[][] getSubKeys(byte[] masterKey) { int noOfSubKeys = SHIFTS.length; int keySize = PC1.length; byte[] key = permute(masterKey, PC1); byte[][] subKeys = new byte[noOfSubKeys][keySize]; byte[] leftHalf = getBits(key, 0, keySize / 2); byte[] rightHalf = getBits(key, keySize / 2, keySize / 2); for (int i = 0; i \u0026lt; noOfSubKeys; i++) { leftHalf = rotateLeft(leftHalf, SHIFTS[i], keySize / 2); rightHalf = rotateLeft(rightHalf, SHIFTS[i], keySize / 2); byte[] subKey = concatBits(leftHalf, keySize / 2, rightHalf, keySize / 2); subKeys[i] = permute(subKey, PC2); } return subKeys; } public byte[] crypt(byte[] message, byte[] key, String operation) { if (message.length \u0026lt; 8) { System.out.println(\u0026#34;Message should be atleast 64 bits\u0026#34;); System.exit(1); } if (key.length != 8) { System.out.println(\u0026#34;Key should be 64 bits\u0026#34;); System.exit(1); } int length = message.length; int n = (length + 7) / 8 * 8; byte[] cipher = new byte[n]; if (length == 8) { if (mode.equals(\u0026#34;ECB\u0026#34;)) { return cryptText(message, key, operation); } else if (mode.equals(\u0026#34;CBC\u0026#34;)) { byte[] iv = getInitializationVector(); message = XORBytes(message, iv); return cryptText(message, key, operation); } else if (mode.equals(\u0026#34;OFB\u0026#34;)) { byte[] nounce = getNounce(); byte[] temp = cryptText(nounce, key, \u0026#34;encrypt\u0026#34;); byte[] result = XORBytes(temp, message); return result; } else if (mode.equals(\u0026#34;CFB\u0026#34;)) { } else { System.out.println(\u0026#34;Unsupported mode of operation!\u0026#34;); return null; } } int i = 0; int k = 0; byte[] feedback = new byte[8]; if (mode.equals(\u0026#34;CBC\u0026#34;)) { feedback = getInitializationVector(); } else if (mode.equals(\u0026#34;OFB\u0026#34;)) { feedback = getNounce(); } else if (mode.equals(\u0026#34;CFB\u0026#34;)) { feedback = getInitializationVectorCFB(); } while (i \u0026lt; length) { byte[] block = new byte[8]; byte[] result = new byte[8]; int j = 0; for (; j \u0026lt; 8 \u0026amp;\u0026amp; i \u0026lt; length; j++, i++) { block[j] = message[i]; } while (j \u0026lt; 8) { /* pad with white spaces */ block[j++] = 0x20; } // System.out.println(\u0026#34;BLOCK: \u0026#34;);  // printBytes(block);  if (mode.equals(\u0026#34;ECB\u0026#34;)) { result = cryptText(block, key, operation); } else if (mode.equals(\u0026#34;CBC\u0026#34;)) { if (operation.equals(\u0026#34;encrypt\u0026#34;)) { block = XORBytes(block, feedback); result = cryptText(block, key, operation); feedback = Arrays.copyOfRange(result, 0, 8); } else if (operation.equals(\u0026#34;decrypt\u0026#34;)) { result = cryptText(block, key, operation); result = XORBytes(result, feedback); feedback = Arrays.copyOfRange(block, 0, 8); } } else if (mode.equals(\u0026#34;OFB\u0026#34;)) { result = cryptText(feedback, key, \u0026#34;encrypt\u0026#34;); feedback = Arrays.copyOfRange(result, 0, 8); result = XORBytes(result, block); } else if (mode.equals(\u0026#34;CFB\u0026#34;)) { if (operation.equals(\u0026#34;encrypt\u0026#34;)) { result = cryptText(feedback, key, operation); byte[] resultPart = Arrays.copyOfRange(result, 0, 4); byte[] blockPart = Arrays.copyOfRange(block, 0, 4); byte[] temp1 = XORBytes(resultPart, blockPart); feedback = mergeBytes(Arrays.copyOfRange(result, 4, 8), temp1); resultPart = Arrays.copyOfRange(result, 4, 8); blockPart = Arrays.copyOfRange(block, 4, 8); result = cryptText(feedback, key, operation); byte[] temp2 = XORBytes(resultPart, blockPart); feedback = mergeBytes(Arrays.copyOfRange(result, 4, 8), temp2); result = mergeBytes(temp1, temp2); } else if (operation.equals(\u0026#34;decrypt\u0026#34;)) { result = cryptText(feedback, key, \u0026#34;encrypt\u0026#34;); byte[] resultPart = Arrays.copyOfRange(result, 0, 4); byte[] blockPart = Arrays.copyOfRange(block, 0, 4); byte[] temp1 = XORBytes(resultPart, blockPart); feedback = mergeBytes(Arrays.copyOfRange(result, 4, 8), blockPart); resultPart = Arrays.copyOfRange(result, 4, 8); blockPart = Arrays.copyOfRange(block, 4, 8); result = cryptText(feedback, key, \u0026#34;encrypt\u0026#34;); byte[] temp2 = XORBytes(resultPart, blockPart); feedback = mergeBytes(Arrays.copyOfRange(result, 4, 8), blockPart); result = mergeBytes(temp1, temp2); } } else { System.out.println(\u0026#34;Unsupported mode of operation!\u0026#34;); return null; } // System.out.println(\u0026#34;RESULT: \u0026#34;);  // printBytes(result);  for (j = 0; j \u0026lt; 8 \u0026amp;\u0026amp; k \u0026lt; cipher.length; j++, k++) { cipher[k] = result[j]; } } return cipher; } private byte[] getInitializationVector() { return hexStringToByteArray(\u0026#34;DCBE6AE7EA5D5C61\u0026#34;); } private byte[] getInitializationVectorCFB() { return hexStringToByteArray(\u0026#34;A5D5C61EFADB4351\u0026#34;); } private byte[] getNounce() { // char[] hexArray = \u0026#34;0123456789ABCDEF\u0026#34;.toCharArray();  // String nounceStr = \u0026#34;\u0026#34;;  // for (int i = 0 ; i \u0026lt; 16 ; i++) {  // double random = Math.random();  // int index = (int) (random * 16);  // nounceStr += hexArray[index];  // }  // return hexStringToByteArray(nounceStr);  return hexStringToByteArray(\u0026#34;DCBE6AE7EA5D5C61\u0026#34;); } private byte[] mergeBytes(byte[] in1, byte[] in2) { byte[] out = new byte[in1.length + in2.length]; int i = 0; for (int j = 0; j \u0026lt; in1.length; j++) { out[i++] = in1[j]; } for (int j = 0; j \u0026lt; in2.length; j++) { out[i++] = in2[j]; } return out; } public byte[] cryptText(byte[] message, byte[] key, String operation) { if (message.length != 8) { System.out.println(\u0026#34;Message should be 64 bits\u0026#34;); System.exit(1); } if (key.length != 8) { System.out.println(\u0026#34;Key should be 64 bits\u0026#34;); System.exit(1); } byte[] result = null; int blockSize = IP.length; byte[][] subKeys = getSubKeys(key); int noOfRounds = subKeys.length; /** * Initial Permutation */ message = permute(message, IP); /** * Split message into two halves */ byte[] leftHalf = getBits(message, 0, blockSize / 2); byte[] rightHalf = getBits(message, blockSize / 2, blockSize / 2); for (int i = 0; i \u0026lt; noOfRounds; i++) { byte[] temp = rightHalf; /** * Expansion */ rightHalf = permute(rightHalf, E); /** * XOR rightHalf with roundKey */ byte[] roundKey = null; if (operation.equalsIgnoreCase(\u0026#34;encrypt\u0026#34;)) { roundKey = subKeys[i]; } else if (operation.equalsIgnoreCase(\u0026#34;decrypt\u0026#34;)) { roundKey = subKeys[noOfRounds - i - 1]; } else { System.out.println(\u0026#34;Unsupported operation\u0026#34;); System.exit(0); } rightHalf = performXOR(rightHalf, roundKey); /** * S-Box */ rightHalf = sBox(rightHalf); /** * Permutation */ rightHalf = permute(rightHalf, P); /** * XOR rightHalf with leftHalf */ rightHalf = performXOR(rightHalf, leftHalf); /** * L(i) = R(i-1) */ leftHalf = temp; } /** * 32 bit swap */ byte[] concatHalves = concatBits(rightHalf, blockSize / 2, leftHalf, blockSize / 2); /** * Inverse Initial Permutation */ result = permute(concatHalves, IIP); return result; } public static byte[] XORBytes(byte[] in1, byte[] in2) { byte[] out = new byte[in1.length]; for (int i = 0; i \u0026lt; in1.length; i++) { out[i] = (byte) ((in1[i] ^ in2[i]) \u0026amp; 0xff); } return out; } private byte[] sBox(byte[] input) { /** * Split input to 6-bit blocks */ input = split(input, 6); byte[] output = new byte[input.length / 2]; int leftHalf = 0; for (int i = 0; i \u0026lt; input.length; i++) { byte block = input[i]; /** * row - first and last bits column - 4 bits in the middle */ int row = 2 * (block \u0026gt;\u0026gt; 7 \u0026amp; 0x0001) + (block \u0026gt;\u0026gt; 2 \u0026amp; 0x0001); int col = block \u0026gt;\u0026gt; 3 \u0026amp; 0x000F; int[] selectedSBox = getSBox(i); int rightHalf = selectedSBox[16 * row + col]; if (i % 2 == 0) { leftHalf = rightHalf; } else { output[i / 2] = (byte) (16 * leftHalf + rightHalf); leftHalf = 0; } } return output; } private int[] getSBox(int i) { switch (i) { case 0: return S1; case 1: return S2; case 2: return S3; case 3: return S4; case 4: return S5; case 5: return S6; case 6: return S7; case 7: return S8; default: return null; } } private byte[] split(byte[] input, int length) { int noOfBytes = (8 * input.length - 1) / length + 1; byte[] output = new byte[noOfBytes]; for (int i = 0; i \u0026lt; noOfBytes; i++) { for (int j = 0; j \u0026lt; length; j++) { int value = getBitFromArray(input, length * i + j); setBitInArray(output, 8 * i + j, value); } } return output; } public static void main(String[] args) { try { if (args.length != 1) { System.out.println(\u0026#34;Usage: java \u0026lt; classname \u0026gt; \u0026lt; mode \u0026gt;\u0026#34; + \u0026#34;\\n\\t\u0026lt; mode \u0026gt; := (ECB|CBC|OFB|CFB)\u0026#34;); return; } /* ECB, CBC, OFB, or CFB */ String mode = args[0]; mode = mode.toUpperCase(); DESdecrypt des = new DESdecrypt(mode); File keyFile = new File(\u0026#34;DESkey.txt\u0026#34;); File textFile = new File(\u0026#34;DESplaintext.txt\u0026#34;); File cipherFile = new File(\u0026#34;DESciphertext.txt\u0026#34;); FileReader keyFileReader = new FileReader(keyFile); BufferedReader bufferedReader = new BufferedReader(keyFileReader); FileInputStream cipherFileInputStream = new FileInputStream(cipherFile); FileOutputStream textFileOutputStream = new FileOutputStream(textFile); byte[] key = new byte[(int) keyFile.length()]; String keyString = bufferedReader.readLine(); key = des.hexStringToByteArray(keyString); byte[] cipher = new byte[(int) cipherFile.length()]; cipherFileInputStream.read(cipher); byte[] message = des.crypt(cipher, key, \u0026#34;decrypt\u0026#34;); textFileOutputStream.write(message); textFileOutputStream.flush(); textFileOutputStream.close(); bufferedReader.close(); cipherFileInputStream.close(); System.out.println(\u0026#34;Decryption done! Please check DESplaintext.txt for output!\u0026#34;); } catch (Exception exp) { exp.printStackTrace(); } } }  Output\ndhanoopbhaskar@dhanoop-laptop:~/workspace$ java DESkeygen Key generated and saved in DESkey.txt dhanoopbhaskar@dhanoop-laptop:~/workspace$ java DESencrypt Usage: java \u0026lt;classname\u0026gt; \u0026lt;mode\u0026gt; \u0026lt;mode\u0026gt; := (ECB|CBC|OFB|CFB) dhanoopbhaskar@dhanoop-laptop:~/workspace$ java DESencrypt ecb Encryption done! Please check DESciphertext.txt for output! dhanoopbhaskar@dhanoop-laptop:~/workspace$ java DESdecrypt ecb Decryption done! Please check DESplaintext.txt for output! dhanoopbhaskar@dhanoop-laptop:~/workspace$ java DESencrypt cbc Encryption done! Please check DESciphertext.txt for output! dhanoopbhaskar@dhanoop-laptop:~/workspace$ java DESdecrypt cbc Decryption done! Please check DESplaintext.txt for output! dhanoopbhaskar@dhanoop-laptop:~/workspace$ java DESencrypt ofb Encryption done! Please check DESciphertext.txt for output! dhanoopbhaskar@dhanoop-laptop:~/workspace$ java DESdecrypt ofb Decryption done! Please check DESplaintext.txt for output! dhanoopbhaskar@dhanoop-laptop:~/workspace$ java DESencrypt cfb Encryption done! Please check DESciphertext.txt for output! dhanoopbhaskar@dhanoop-laptop:~/workspace$ java DESdecrypt cfb Decryption done! Please check DESplaintext.txt for output! dhanoopbhaskar@dhanoop-laptop:~/workspace$ java DESdecrypt cfb Decryption done! Please check DESplaintext.txt for output! dhanoopbhaskar@dhanoop-laptop:~/workspace$  About Input/Output Files\nDESkeygen.java - (output) DESkey.txt\nDESencrypt.java - (input) DESkey.txt \u0026amp; DESplaintext.txt (output) DESciphertext.txtÂ DESdecrypt.java - (input) DESkey.txt \u0026amp; DESciphertext.txt (output) DESplaintext.txt\n",
    "ref": "/blog/2014-07-30-des-implementation-in-java-with-ecb-cbc-ofb-cfb-modes-of-operation/"
  },{
    "title": "AES Implementation in Java",
    "date": "July 30, 2014",
    "description": "",
    "body": "AES.java\nimport java.util.Arrays; public class AES { private static final int BITS = 16; private static final int ROUNDS = 10; private static final int NO_OF_WORDS_IN_KEY = 44; private static final int KEY_LENGTH = 16; private static final int BLOCK_LENGTH = 16; final protected static char[] hexArray = \u0026#34;0123456789ABCDEF\u0026#34;.toCharArray(); int[] RC = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36 }; Word[] Rcon = new Word[ROUNDS]; private byte[] word = null; static final int[] sBox = { 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 }; static final int[] invSBox = { 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d }; public AES() { for (int i = 0; i \u0026lt; ROUNDS; i++) { Rcon[i] = new Word(); byte[] temp = new byte[4]; temp[0] = (byte) (RC[i] \u0026amp; 0xff); temp[1] = 0; temp[2] = 0; temp[3] = 0; Rcon[i].setWord(temp); } word = new byte[NO_OF_WORDS_IN_KEY]; } /* Ref: http://www.samiam.org/galois.html */ /* Galois Addition */ byte gadd(byte a, byte b) { return (byte) ((a ^ b) \u0026amp; 0xff); } /* Galois Subtraction */ byte gsub(byte a, byte b) { return (byte) ((a ^ b) \u0026amp; 0xff); } /* Galois Multiplication */ byte gmul(byte a, byte b) { byte p = 0; int counter; byte high_bit_set; byte byte0x80 = hexStringToByteArray(\u0026#34;80\u0026#34;)[0]; for (counter = 0; counter \u0026lt; 8; counter++) { if ((b \u0026amp; 0x01) == 1) { // System.out.println(\u0026#34;lower bit of b is set\u0026#34;);  p = (byte) ((p ^ a) \u0026amp; 0xff); } high_bit_set = (byte) (a \u0026amp; 0x80); // printByte(\u0026#34;high_bit_set\u0026#34;, high_bit_set);  a \u0026lt;\u0026lt;= 1; if (high_bit_set == byte0x80) { // System.out.println(\u0026#34;higher bit of a is set\u0026#34;);  a = (byte) ((a ^ 0x1b) \u0026amp; 0xff); } b = (byte) ((b \u0026gt;\u0026gt; 1) \u0026amp; 0x7f); // printByte(\u0026#34;a\u0026#34;, a);  // printByte(\u0026#34;b\u0026#34;, b);  // printByte(\u0026#34;p\u0026#34;, p);  } return p; } byte gmul(byte a, int b) { byte t = (byte) (b \u0026amp; 0xff); return gmul(a, t); } /* Key Expansion */ private byte[] expandKey(byte[] key) throws Exception { // System.out.println(key.length);  // System.out.println(bytesToHex(key));  if (key.length != KEY_LENGTH) { throw new Exception(\u0026#34;Key should be of length, 128 bits\u0026#34;); } Word[] w = new Word[NO_OF_WORDS_IN_KEY]; Word temp; for (int i = 0; i \u0026lt; 4; i++) { w[i] = new Word(key[4 * i], key[4 * i + 1], key[4 * i + 2], key[4 * i + 3]); // System.out.println(\u0026#34;w\u0026#34; + i + \u0026#34; = \u0026#34; + w[i]);  } for (int i = 4; i \u0026lt; 44; i++) { temp = w[i - 1]; Word temp1 = new Word(); temp1.setWord(temp.getWord()); // System.out.println(\u0026#34;w\u0026#34; + (i-1) + \u0026#34; = \u0026#34; + temp);  if (i % 4 == 0) { temp1.rotWord(); // System.out.println(\u0026#34;Rot=\u0026#34; + temp1);  temp1.subWord(); // System.out.println(\u0026#34;Sub=\u0026#34; + temp1);  temp1 = Word.XORWords(temp1, Rcon[(i / 4) - 1]); // System.out.println(\u0026#34;Rcon\u0026#34; + temp1);  } w[i] = Word.XORWords(w[i - 4], temp1); // System.out.println(\u0026#34;w\u0026#34; + i + \u0026#34; = \u0026#34; + w[i]);  } return Word.wordsToBytes(w); } /* Substitute Bytes */ private byte[] subBytes(byte[] in) { byte[] out = new byte[BITS]; for (int i = 0; i \u0026lt; BITS; i++) { byte a = in[i]; int row = (a \u0026gt;\u0026gt; 4) \u0026amp; 0x000F; int col = a \u0026amp; 0x000F; out[i] = (byte) sBox[row * BITS + col]; } return out; } /* Inverse Substitute Bytes */ private byte[] inverseSubBytes(byte[] in) { byte[] out = new byte[BITS]; for (int i = 0; i \u0026lt; BITS; i++) { byte a = in[i]; int row = (a \u0026gt;\u0026gt; 4) \u0026amp; 0x000F; int col = a \u0026amp; 0x000F; out[i] = (byte) invSBox[row * BITS + col]; } return out; } /* Shift Rows */ private byte[] shiftRows(byte[] in) { byte[] out = new byte[BITS]; byte[] temp = new byte[BITS]; for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { temp[4 * j + i] = in[4 * i + j]; } } // System.out.println(\u0026#34;temp: \u0026#34; + bytesToHex(temp));  for (int i = 0; i \u0026lt; BITS / 4; i++) { byte[] a = Arrays.copyOfRange(temp, (4 * i), (4 * i + 4)); byte[] b = leftShift(a, i); in[4 * i] = b[0]; in[4 * i + 1] = b[1]; in[4 * i + 2] = b[2]; in[4 * i + 3] = b[3]; } for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { out[4 * j + i] = in[4 * i + j]; } } return out; } private byte[] leftShift(byte[] in, int times) { byte[] out = new byte[4]; out = Arrays.copyOfRange(in, 0, 4); for (int i = 0; i \u0026lt; times; i++) { out[0] = in[1]; out[1] = in[2]; out[2] = in[3]; out[3] = in[0]; in = Arrays.copyOfRange(out, 0, 4); } return out; } /* Inverse Shift Rows */ private byte[] inverseShiftRows(byte[] in) { byte[] out = new byte[BITS]; byte[] temp = new byte[BITS]; for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { temp[4 * j + i] = in[4 * i + j]; } } for (int i = 0; i \u0026lt; BITS / 4; i++) { byte[] a = Arrays.copyOfRange(temp, (4 * i), (4 * i + 4)); byte[] b = rightShift(a, i); in[4 * i] = b[0]; in[4 * i + 1] = b[1]; in[4 * i + 2] = b[2]; in[4 * i + 3] = b[3]; } for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { out[4 * j + i] = in[4 * i + j]; } } return out; } private byte[] rightShift(byte[] in, int times) { byte[] out = new byte[4]; out = Arrays.copyOfRange(in, 0, 4); for (int i = 0; i \u0026lt; times; i++) { out[0] = in[3]; out[1] = in[0]; out[2] = in[1]; out[3] = in[2]; in = Arrays.copyOfRange(out, 0, 4); } return out; } /* Mix Columns */ private byte[] mixColumns(byte[] in) { byte[] out = new byte[BITS]; byte[] temp = new byte[BITS]; for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { temp[4 * j + i] = in[4 * i + j]; } } in = temp; for (int j = 0; j \u0026lt; BITS / 4; j++) { out[4 * 0 + j] = (byte) ((gmul(in[4 * 0 + j], 2) ^ gmul(in[4 * 1 + j], 3) ^ in[4 * 2 + j] ^ in[4 * 3 + j]) \u0026amp; 0xff); out[4 * 1 + j] = (byte) ((in[4 * 0 + j] ^ gmul(in[4 * 1 + j], 2) ^ gmul(in[4 * 2 + j], 3) ^ in[4 * 3 + j]) \u0026amp; 0xff); out[4 * 2 + j] = (byte) ((in[4 * 0 + j] ^ in[4 * 1 + j] ^ gmul(in[4 * 2 + j], 2) ^ gmul(in[4 * 3 + j], 3)) \u0026amp; 0xff); out[4 * 3 + j] = (byte) ((gmul(in[4 * 0 + j], 3) ^ in[4 * 1 + j] ^ in[4 * 2 + j] ^ gmul(in[4 * 3 + j], 2)) \u0026amp; 0xff); } for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { temp[4 * j + i] = out[4 * i + j]; } } out = temp; return out; } /* Inverse Mix Columns */ private byte[] inverseMixColumns(byte[] in) { byte[] out = new byte[BITS]; byte[] temp = new byte[BITS]; for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { temp[4 * j + i] = in[4 * i + j]; } } in = temp; for (int j = 0; j \u0026lt; BITS / 4; j++) { out[4 * 0 + j] = (byte) ((gmul(in[4 * 0 + j], 14) ^ gmul(in[4 * 1 + j], 11) ^ gmul(in[4 * 2 + j], 13) ^ gmul(in[4 * 3 + j], 9)) \u0026amp; 0xff); out[4 * 1 + j] = (byte) ((gmul(in[4 * 0 + j], 9) ^ gmul(in[4 * 1 + j], 14) ^ gmul(in[4 * 2 + j], 11) ^ gmul(in[4 * 3 + j], 13)) \u0026amp; 0xff); out[4 * 2 + j] = (byte) ((gmul(in[4 * 0 + j], 13) ^ gmul(in[4 * 1 + j], 9) ^ gmul(in[4 * 2 + j], 14) ^ gmul(in[4 * 3 + j], 11)) \u0026amp; 0xff); out[4 * 3 + j] = (byte) ((gmul(in[4 * 0 + j], 11) ^ gmul(in[4 * 1 + j], 13) ^ gmul(in[4 * 2 + j], 9) ^ gmul(in[4 * 3 + j], 14)) \u0026amp; 0xff); } for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { temp[4 * j + i] = out[4 * i + j]; } } out = temp; return out; } private byte[] hexStringToByteArray(String string) { int length = string.length(); int n = (int) Math.ceil((length + 1) / 2); byte[] result = new byte[n]; for (int i = length - 1; i \u0026gt;= 0; i -= 2) { if (i == 0) { result[i / 2] = (byte) ((Character.digit(\u0026#39;0\u0026#39;, 16) \u0026lt;\u0026lt; 4) + Character.digit(string.charAt(i), 16)); } else { result[i / 2] = (byte) ((Character.digit(string.charAt(i - 1), 16) \u0026lt;\u0026lt; 4) + Character.digit(string.charAt(i), 16)); } } return result; } /* * http://stackoverflow.com/questions/9655181/convert-from-byte-array-to-hex- * string-in-java */ public static String bytesToHex(byte[] bytes) { char[] hexChars = new char[bytes.length * 2]; for (int j = 0; j \u0026lt; bytes.length; j++) { int v = bytes[j] \u0026amp; 0xFF; hexChars[j * 2] = hexArray[v \u0026gt;\u0026gt;\u0026gt; 4]; hexChars[j * 2 + 1] = hexArray[v \u0026amp; 0x0F]; } return new String(hexChars); } private void printBytes(byte[] input) { for (int i = 0; i \u0026lt; input.length; i++) { System.out.print(byteToBits(input[i]) + \u0026#34; \u0026#34;); } System.out.println(); } private void printByte(String msg, byte input) { byte[] temp = new byte[1]; temp[0] = input; System.out.println(msg + \u0026#34;: \u0026#34; + bytesToHex(temp)); } private String byteToBits(byte b) { StringBuffer buffer = new StringBuffer(); for (int i = 0; i \u0026lt; 8; i++) buffer.append((int) (b \u0026gt;\u0026gt; (8 - (i + 1)) \u0026amp; 0x0001)); return buffer.toString(); } private byte[] getRoundKey(int round) { byte[] out = new byte[KEY_LENGTH]; out = Arrays.copyOfRange(word, 16 * round, 16 * round + 16); return out; } public static byte[] XORBytes(byte[] in1, byte[] in2) { byte[] out = new byte[BLOCK_LENGTH]; for (int i = 0; i \u0026lt; BLOCK_LENGTH; i++) { out[i] = (byte) ((in1[i] ^ in2[i]) \u0026amp; 0xff); } return out; } public byte[] encrypt(byte[] plainText, byte[] key) throws Exception { byte[] cipher = new byte[BLOCK_LENGTH]; this.word = expandKey(key); byte[] roundKey = getRoundKey(0); /* Round 0 */ cipher = XORBytes(plainText, roundKey); // System.out.println(\u0026#34;Round 0\\n\u0026#34; + bytesToHex(cipher));  /* Rounds 1 to 9 */ for (int i = 1; i \u0026lt; 10; i++) { // System.out.println(\u0026#34;Round \u0026#34; + i);  cipher = subBytes(cipher); // System.out.println(\u0026#34;SubBytes: \u0026#34; + bytesToHex(cipher));  cipher = shiftRows(cipher); // System.out.println(\u0026#34;ShiftRows: \u0026#34; + bytesToHex(cipher));  cipher = mixColumns(cipher); // System.out.println(\u0026#34;MixColumns: \u0026#34; + bytesToHex(cipher));  roundKey = getRoundKey(i); // System.out.println(\u0026#34;RoundKey: \u0026#34; + bytesToHex(roundKey));  cipher = XORBytes(cipher, roundKey); // System.out.println(\u0026#34;CIPHER: \u0026#34; + bytesToHex(cipher));  } /* Round 10 */ // System.out.println(\u0026#34;Round 10\u0026#34;);  cipher = subBytes(cipher); // System.out.println(\u0026#34;SubBytes: \u0026#34; + bytesToHex(cipher));  cipher = shiftRows(cipher); // System.out.println(\u0026#34;ShiftRows: \u0026#34; + bytesToHex(cipher));  roundKey = getRoundKey(10); // System.out.println(\u0026#34;RoundKey: \u0026#34; + bytesToHex(roundKey));  cipher = XORBytes(cipher, roundKey); // System.out.println(\u0026#34;CIPHER: \u0026#34; + bytesToHex(cipher));  return cipher; } public byte[] decrypt(byte[] cipher, byte[] key) throws Exception { byte[] plainText = new byte[BLOCK_LENGTH]; this.word = expandKey(key); byte[] roundKey = getRoundKey(10); /* Round 0 */ plainText = XORBytes(cipher, roundKey); /* Rounds 1 to 9 */ for (int i = 9; i \u0026gt; 0; i--) { plainText = inverseShiftRows(plainText); plainText = inverseSubBytes(plainText); roundKey = getRoundKey(i); plainText = XORBytes(plainText, roundKey); plainText = inverseMixColumns(plainText); } /* Round 10 */ plainText = inverseShiftRows(plainText); plainText = inverseSubBytes(plainText); roundKey = getRoundKey(0); plainText = XORBytes(plainText, roundKey); return plainText; } public static void main(String[] args) throws Exception { AES aes = new AES(); byte[] plainText = aes.hexStringToByteArray(\u0026#34;0123456789abcdeffedcba9876543210\u0026#34;); System.out.println(\u0026#34;PLAIN TEXT: \u0026#34; + bytesToHex(plainText)); byte[] key = aes.hexStringToByteArray(\u0026#34;0f1571c947d9e8590cb7add6af7f6798\u0026#34;); System.out.println(\u0026#34;KEY: \u0026#34; + bytesToHex(key)); byte[] cipher = aes.encrypt(plainText, key); System.out.println(\u0026#34;CIPHER TEXT: \u0026#34; + bytesToHex(cipher)); plainText = aes.decrypt(cipher, key); System.out.println(\u0026#34;DECRYPTED CIPHER TEXT: \u0026#34; + bytesToHex(plainText)); } } Word.java\npublic class Word { private byte[] word = null; public Word() { word = new byte[4]; } public Word(byte k0, byte k1, byte k2, byte k3) { this(); word[0] = k0; word[1] = k1; word[2] = k2; word[3] = k3; } public byte[] getWord() { return word; } public void setWord(byte[] word) { this.word = word; } public static byte[] wordToBytes(Word word) { return word.getWord(); } public static byte[] wordsToBytes(Word[] words) { byte[] out = new byte[4 * words.length]; for (int i = 0; i \u0026lt; words.length; i++) { byte[] temp = words[i].getWord(); out[4 * i] = temp[0]; out[4 * i + 1] = temp[1]; out[4 * i + 2] = temp[2]; out[4 * i + 3] = temp[3]; } return out; } public void rotWord() { byte[] temp = this.getWord(); byte[] newWord = new byte[4]; newWord[0] = temp[1]; newWord[1] = temp[2]; newWord[2] = temp[3]; newWord[3] = temp[0]; this.setWord(newWord); } public void subWord() { byte[] in = this.getWord(); byte[] out = new byte[4]; for (int i = 0; i \u0026lt; 4; i++) { byte a = in[i]; int row = (a \u0026gt;\u0026gt; 4) \u0026amp; 0x000F; int col = a \u0026amp; 0x000F; out[i] = (byte) AES.sBox[row * 16 + col]; } for (int i = 0; i \u0026lt; 4; i++) { this.word[i] = out[i]; } } public static Word XORWords(Word word1, Word word2) { Word outWord = new Word(); byte[] in1 = word1.getWord(); byte[] in2 = word2.getWord(); byte[] out = new byte[4]; for (int i = 0; i \u0026lt; 4; i++) { out[i] = (byte) ((in1[i] ^ in2[i]) \u0026amp; 0xff); } outWord.setWord(out); return outWord; } public String toString() { return AES.bytesToHex(this.getWord()); } } Output\nPLAIN TEXT: 0123456789ABCDEFFEDCBA9876543210 KEY: 0F1571C947D9E8590CB7ADD6AF7F6798 CIPHER TEXT: FF0B844A0853BF7C6934AB4364148FB9 DECRYPTED CIPHER TEXT: 0123456789ABCDEFFEDCBA9876543210  ",
    "ref": "/blog/2014-07-30-aes-implementation-in-java/"
  },{
    "title": "DES Implementation In Java",
    "date": "June 20, 2014",
    "description": "",
    "body": "DES.java\npublic class DES { /* Initial Permutation */ static final int[] IP = { 58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8, 57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7 }; /* Inverse Initial Permutation */ static final int[] IIP = { 40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29, 36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25 }; /* Expansion Permutation */ static final int[] E = { 32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17, 16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1 }; /* Permutation Function */ static final int[] P = { 16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10, 2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25 }; /* S-Boxes*/ static final int[] S1 = { 14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7, 0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8, 4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0, 15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13 }; static final int[] S2 = { 15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10, 3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5, 0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15, 13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9 }; static final int[] S3 = { 10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8, 13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1, 13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7, 1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12 }; static final int[] S4 = { 7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15, 13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9, 10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4, 3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14 }; static final int[] S5 = { 2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9, 14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6, 4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14, 11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3 }; static final int[] S6 = { 12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11, 10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8, 9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6, 4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13 }; static final int[] S7 = { 4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1, 13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6, 1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2, 6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12 }; static final int[] S8 = { 13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7, 1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2, 7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8, 2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11 }; /* Permuted Choice One */ static final int[] PC1 = { 57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4 }; /* Permuted Choice Two */ static final int[] PC2 = { 14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32 }; /* Schedule of Left Shifts */ static final int[] SHIFTS = { 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1 }; public DES() { } private byte[] performXOR(byte[] one, byte[] two) { byte[] result = new byte[one.length]; for (int i = 0 ; i \u0026lt; one.length ; i++) { result[i] = (byte) (one[i] ^ two[i]); } return result; } private byte[] permute(byte[] input, int[] mapping) { int byteCount = 1 + (mapping.length - 1) / 8; byte[] output = new byte[byteCount]; int pos; for (int i = 0 ; i \u0026lt; mapping.length ; i++) { pos = mapping[i] - 1; int value = getBitFromArray(input, pos); setBitInArray(output, i, value); } return output; } private int getBitFromArray(byte[] array, int pos) { int value; int bytePos = pos / 8; int bitPos = pos % 8; value = (array[bytePos] \u0026gt;\u0026gt; (8 - (bitPos + 1))) \u0026amp; 0x0001; /* eg: right shift selected byte 5 times to get 3rd bit * (bitPos = 2) at rightmost position and * then AND with 0x0001*/ return value; } private void setBitInArray(byte[] input, int pos, int value) { int bytePos = pos / 8; int bitPos = pos % 8; byte old = input[bytePos]; old = (byte) (((0xFF7F \u0026gt;\u0026gt; bitPos) \u0026amp; old) \u0026amp; 0x00FF); byte newByte = (byte) ((value \u0026lt;\u0026lt; (8 - (bitPos + 1))) | old); input[bytePos] = newByte; } private byte[] hexStringToByteArray(String string) { int length = string.length(); int n = (int)Math.ceil((length + 1) / 2); byte[] result = new byte[n]; for (int i = length - 1; i \u0026gt;= 0 ; i -= 2) { if (i == 0) { result[i / 2] = (byte) ((Character.digit(\u0026#39;0\u0026#39;, 16) \u0026lt;\u0026lt; 4) + Character.digit(string.charAt(i), 16)); } else { result[i / 2] = (byte) ((Character.digit(string.charAt(i - 1), 16) \u0026lt;\u0026lt; 4) + Character.digit(string.charAt(i), 16)); } } return result; } private void printBytes(byte[] input) { for (int i = 0 ; i \u0026lt; input.length; i++) { System.out.print(byteToBits(input[i]) + \u0026#34; \u0026#34;); } System.out.println(); } private String byteToBits(byte b) { StringBuffer buffer = new StringBuffer(); for (int i = 0 ; i \u0026lt; 8 ; i++) buffer.append((int)(b \u0026gt;\u0026gt; (8-(i+1)) \u0026amp; 0x0001)); return buffer.toString(); } private byte[] getBits(byte[] input, int startPos, int length) { int noOfBytes = (length-1)/8 + 1; byte[] output = new byte[noOfBytes]; for (int i = 0 ; i \u0026lt; length ; i++) { int value = getBitFromArray(input, startPos + i); setBitInArray(output, i, value); } return output; } private byte[] rotateLeft(byte[] input, int step, int length) { int noOfBytes = (length - 1) / 8 + 1; byte[] output = new byte[noOfBytes]; for (int i = 0 ; i \u0026lt; length ; i++) { int value = getBitFromArray(input, (i + step) % length); setBitInArray(output, i, value); } return output; } private byte[] concatBits(byte[] one, int oneLength, byte[] two, int twoLength) { int noOfBytes = (oneLength + twoLength - 1) / 8 + 1; byte[] output = new byte[noOfBytes]; int i = 0, j = 0; for (; i \u0026lt; oneLength ; i++) { int value = getBitFromArray(one, i); setBitInArray(output, j, value); j++; } for (i = 0 ; i \u0026lt; twoLength ; i++) { int value = getBitFromArray(two, i); setBitInArray(output, j, value); j++; } return output; } private byte[][] getSubKeys(byte[] masterKey) { int noOfSubKeys = SHIFTS.length; int keySize = PC1.length; byte[] key = permute(masterKey, PC1); byte[][] subKeys = new byte[noOfSubKeys][keySize]; byte[] leftHalf = getBits(key, 0, keySize/2); byte[] rightHalf = getBits(key, keySize/2, keySize/2); for (int i = 0 ; i \u0026lt; noOfSubKeys ; i++) { leftHalf = rotateLeft(leftHalf, SHIFTS[i], keySize/2); rightHalf = rotateLeft(rightHalf, SHIFTS[i], keySize/2); byte[] subKey = concatBits(leftHalf, keySize/2, rightHalf, keySize/2); subKeys[i] = permute(subKey, PC2); } return subKeys; } public byte[] crypt(byte[] message, byte[] key, String operation) { if (message.length \u0026lt; 8) { System.out.println(\u0026#34;Message should be atleast 64 bits\u0026#34;); System.exit(1); } if (key.length != 8) { System.out.println(\u0026#34;Key should be 64 bits\u0026#34;); System.exit(1); } int length = message.length; int n = (length + 7)/8 * 8; byte[] cipher = new byte[n]; if (length == 8) { return cryptText(message, key, operation); } int i = 0; int k = 0; while (i \u0026lt; length) { byte[] block = new byte[8]; byte[] result = new byte[8]; int j = 0; for (; j \u0026lt; 8 \u0026amp;\u0026amp; i \u0026lt; length; j++, i++) { block[j] = message[i]; } while (j \u0026lt; 8) { block[j++] = 0x00; } System.out.println(\u0026#34;BLOCK: \u0026#34;); printBytes(block); result = cryptText(block, key, operation); System.out.println(\u0026#34;RESULT: \u0026#34;); printBytes(result); for (j = 0 ; j \u0026lt; 8 \u0026amp;\u0026amp; k \u0026lt; cipher.length; j++, k++) { cipher[k] = result[j]; } } return cipher; } public byte[] cryptText(byte[] message, byte[] key, String operation) { if (message.length != 8) { System.out.println(\u0026#34;Message should be 64 bits\u0026#34;); System.exit(1); } if (key.length != 8) { System.out.println(\u0026#34;Key should be 64 bits\u0026#34;); System.exit(1); } byte[] result = null; int blockSize = IP.length; byte[][] subKeys = getSubKeys(key); int noOfRounds = subKeys.length; /** * Initial Permutation */ message = permute(message, IP); /** * Split message into two halves */ byte[] leftHalf = getBits(message, 0, blockSize/2); byte[] rightHalf = getBits(message, blockSize/2, blockSize/2); for (int i = 0 ; i \u0026lt; noOfRounds ; i++) { byte[] temp = rightHalf; /** * Expansion */ rightHalf = permute(rightHalf, E); /** * XOR rightHalf with roundKey */ byte[] roundKey = null; if (operation.equalsIgnoreCase(\u0026#34;encrypt\u0026#34;)) { roundKey = subKeys[i]; } else if (operation.equalsIgnoreCase(\u0026#34;decrypt\u0026#34;)) { roundKey = subKeys[noOfRounds - i - 1]; } else { System.out.println(\u0026#34;Unsupported operation\u0026#34;); System.exit(0); } rightHalf = performXOR(rightHalf, roundKey); /** * S-Box */ rightHalf = sBox(rightHalf); /** * Permutation */ rightHalf = permute(rightHalf, P); /** * XOR rightHalf with leftHalf */ rightHalf = performXOR(rightHalf, leftHalf); /** * L(i) = R(i-1) */ leftHalf = temp; } /** * 32 bit swap */ byte[] concatHalves = concatBits(rightHalf, blockSize/2, leftHalf, blockSize/2); /** * Inverse Initial Permutation */ result = permute(concatHalves, IIP); return result; } private byte[] sBox(byte[] input) { /** * Split input to 6-bit blocks */ input = split(input,6); byte[] output = new byte[input.length/2]; int leftHalf = 0; for (int i = 0; i \u0026lt; input.length ; i++) { byte block = input[i]; /** * row - first and last bits * column - 4 bits in the middle */ int row = 2 * (block \u0026gt;\u0026gt; 7 \u0026amp; 0x0001) + (block \u0026gt;\u0026gt; 2 \u0026amp; 0x0001); int col = block \u0026gt;\u0026gt; 3 \u0026amp; 0x000F; int[] selectedSBox = getSBox(i); int rightHalf = selectedSBox[16 * row + col]; if (i % 2 == 0) { leftHalf = rightHalf; } else { output[i/2] = (byte) (16 * leftHalf + rightHalf); leftHalf = 0; } } return output; } private int[] getSBox(int i) { switch (i) { case 0: return S1; case 1: return S2; case 2: return S3; case 3: return S4; case 4: return S5; case 5: return S6; case 6: return S7; case 7: return S8; default: return null; } } private byte[] split(byte[] input, int length) { int noOfBytes = (8 * input.length - 1) / length + 1; byte[] output = new byte[noOfBytes]; for (int i = 0 ; i \u0026lt; noOfBytes ; i++) { for (int j = 0; j \u0026lt; length ; j++) { int value = getBitFromArray(input, length * i + j); setBitInArray(output, 8 * i + j, value); } } return output; } public static void main(String[] args) { DES des = new DES(); byte[] message = des.hexStringToByteArray(\u0026#34;123456789ABCDEF\u0026#34;); System.out.println(\u0026#34;PLAIN TEXT:\u0026#34;); des.printBytes(message); byte[] key = des.hexStringToByteArray(\u0026#34;133457799BBCDFF1\u0026#34;); System.out.println(\u0026#34;KEY:\u0026#34;); des.printBytes(key); byte[] cipher = des.crypt(message, key, \u0026#34;encrypt\u0026#34;); System.out.println(\u0026#34;CIPHER TEXT:\u0026#34;); des.printBytes(cipher); byte[] result = des.crypt(cipher, key, \u0026#34;decrypt\u0026#34;); System.out.println(\u0026#34;DECRYPTED TEXT:\u0026#34;); des.printBytes(result); } } Output\ndhanoopbhaskar@dhanoop-laptop:~$ javac DES.java dhanoopbhaskar@dhanoop-laptop:~$ java DES PLAIN TEXT: 00000001 00100011 01000101 01100111 10001001 10101011 11001101 11101111 KEY: 00010011 00110100 01010111 01111001 10011011 10111100 11011111 11110001 CIPHER TEXT: 10000101 11101000 00010011 01010100 00001111 00001010 10110100 00000101 DECRYPTED TEXT: 00000001 00100011 01000101 01100111 10001001 10101011 11001101 11101111 dhanoopbhaskar@dhanoop-laptop:~$ ",
    "ref": "/blog/2014-06-20-des-implementation-in-java/"
  },{
    "title": "Total Views Crossed 50K !! Thanks for your support !!",
    "date": "May 19, 2014",
    "description": "",
    "body": " Today, the total page views crossed 50K :-)\nThanks for your support!\n ",
    "ref": "/blog/2014-05-19-total-views-crossed-50k-thanks-for-your-support/"
  },{
    "title": "Java - Common Problems (and Their Solutions)",
    "date": "April 26, 2014",
    "description": "",
    "body": "Original Link:\nhttp://docs.oracle.com/javase/tutorial/getStarted/problems/\nCheck the license before redistribution: http://docs.oracle.com/javase/tutorial/information/license.html\n",
    "ref": "/blog/2014-04-26-java-common-problems-and-their-solutions/"
  },{
    "title": "Java - Encryption and Decryption of an Image Using Another Image (Blowfish Algorithm)",
    "date": "April 9, 2014",
    "description": "",
    "body": "Here an image file is encrypted and decrypted using another image file as the password\n/* EncryptFile.java */ import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.IllegalBlockSizeException; import javax.crypto.NoSuchPaddingException; import javax.crypto.SecretKey; import javax.crypto.spec.SecretKeySpec; /** * * @author dhanoopbhaskar */ public class EncryptFile { SecretKey secretKey = null; Cipher cipher = null; String filePath = null; public EncryptFile(String filePath) { this.filePath = filePath; try { /** * Create a Blowfish key */ byte[] password = getPasswordFromFile(filePath); if (password == null) { System.out.println(\u0026#34;Unable to read the password file!\u0026#34;); System.exit(0); } secretKey = new SecretKeySpec(password, \u0026#34;Blowfish\u0026#34;); /** * Create an instance of cipher mentioning the name of algorithm * - Blowfish */ cipher = Cipher.getInstance(\u0026#34;Blowfish\u0026#34;); } catch (NoSuchPaddingException ex) { System.out.println(ex); } catch (NoSuchAlgorithmException ex) { System.out.println(ex); } } /** * * @param filePath * @return password * * Encrypts the file in srcPath and creates a file in destPath */ private byte[] getPasswordFromFile(String filePath) { File file = new File(filePath); InputStream inStream; /** * maximum allowable key size for blowfish is 56 bytes, * but java supports only upto 16 bytes. */ byte[] buffer = new byte[16]; try { inStream = new FileInputStream(file); int len = inStream.read(buffer); if (len \u0026lt;= 0) buffer = null; } catch (FileNotFoundException ex) { System.out.println(ex); } catch (IOException ex) { System.out.println(ex); } return buffer; } public static void main(String[] args) { String fileToEncrypt = \u0026#34;fileToEncrypt.jpg\u0026#34;; String encryptedFile = \u0026#34;encryptedFile.jpg\u0026#34;; String decryptedFile = \u0026#34;decryptedFile.jpg\u0026#34;; String directoryPath = \u0026#34;/home/dhanoopbhaskar/Desktop/blowfish/\u0026#34;; String passwordFile = \u0026#34;password.jpg\u0026#34;; EncryptFile encryptFile = new EncryptFile(directoryPath + passwordFile); System.out.println(\u0026#34;Starting Encryption...\u0026#34;); encryptFile.encrypt(directoryPath + fileToEncrypt, directoryPath + encryptedFile); System.out.println(\u0026#34;Encryption completed...\u0026#34;); encryptFile = new EncryptFile(directoryPath + passwordFile); System.out.println(\u0026#34;Starting Decryption...\u0026#34;); encryptFile.decrypt(directoryPath + encryptedFile, directoryPath + decryptedFile); System.out.println(\u0026#34;Decryption completed...\u0026#34;); } /** * * @param srcPath * @param destPath * * Encrypts the file in srcPath and creates a file in destPath */ private void encrypt(String srcPath, String destPath) { File rawFile = new File(srcPath); File encryptedFile = new File(destPath); InputStream inStream = null; OutputStream outStream = null; try { /** * Initialize the cipher for encryption */ cipher.init(Cipher.ENCRYPT_MODE, secretKey); /** * Initialize input and output streams */ inStream = new FileInputStream(rawFile); outStream = new FileOutputStream(encryptedFile); byte[] buffer = new byte[1024]; int len; while ((len = inStream.read(buffer)) \u0026gt; 0) { outStream.write(cipher.update(buffer, 0, len)); outStream.flush(); } outStream.write(cipher.doFinal()); inStream.close(); outStream.close(); } catch (IllegalBlockSizeException ex) { System.out.println(ex); } catch (BadPaddingException ex) { System.out.println(ex); } catch (InvalidKeyException ex) { System.out.println(ex); } catch (FileNotFoundException ex) { System.out.println(ex); } catch (IOException ex) { System.out.println(ex); } } /** * * @param srcPath * @param destPath * * Decrypts the file in srcPath and creates a file in destPath */ private void decrypt(String srcPath, String destPath) { File encryptedFile = new File(srcPath); File decryptedFile = new File(destPath); InputStream inStream = null; OutputStream outStream = null; try { /** * Initialize the cipher for decryption */ cipher.init(Cipher.DECRYPT_MODE, secretKey); /** * Initialize input and output streams */ inStream = new FileInputStream(encryptedFile); outStream = new FileOutputStream(decryptedFile); byte[] buffer = new byte[1024]; int len; while ((len = inStream.read(buffer)) \u0026gt; 0) { outStream.write(cipher.update(buffer, 0, len)); outStream.flush(); } outStream.write(cipher.doFinal()); inStream.close(); outStream.close(); } catch (IllegalBlockSizeException ex) { System.out.println(ex); } catch (BadPaddingException ex) { System.out.println(ex); } catch (InvalidKeyException ex) { System.out.println(ex); } catch (FileNotFoundException ex) { System.out.println(ex); } catch (IOException ex) { System.out.println(ex); } } } \n",
    "ref": "/blog/2014-04-09-java-encryption-and-decryption-of-an-image-using-another-image-blowfish-algorithm/"
  },{
    "title": "Java - Encryption and Decryption of an Image Using Blowfish Algorithm (using password)",
    "date": "April 5, 2014",
    "description": "",
    "body": "package com.java.blowfish; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.IllegalBlockSizeException; import javax.crypto.KeyGenerator; import javax.crypto.NoSuchPaddingException; import javax.crypto.SecretKey; import javax.crypto.spec.SecretKeySpec; /** * * @author dhanoopbhaskar */ public class EncryptFile { KeyGenerator keyGenerator = null; SecretKey secretKey = null; Cipher cipher = null; String masterPassword = null; public EncryptFile(String masterPassword) { this.masterPassword = masterPassword; try { /** * Create a Blowfish key */ keyGenerator = KeyGenerator.getInstance(\u0026#34;Blowfish\u0026#34;); secretKey = new SecretKeySpec(masterPassword.getBytes(), \u0026#34;Blowfish\u0026#34;); /** * Create an instance of cipher mentioning the name of algorithm * - Blowfish */ cipher = Cipher.getInstance(\u0026#34;Blowfish\u0026#34;); } catch (NoSuchPaddingException ex) { System.out.println(ex); } catch (NoSuchAlgorithmException ex) { System.out.println(ex); } } public static void main(String[] args) { String fileToEncrypt = \u0026#34;fileToEncrypt.jpg\u0026#34;; String encryptedFile = \u0026#34;encryptedFile.jpg\u0026#34;; String decryptedFile = \u0026#34;decryptedFile.jpg\u0026#34;; String directoryPath = \u0026#34;/home/dhanoopbhaskar/Desktop/blowfish/\u0026#34;; EncryptFile encryptFile = new EncryptFile(\u0026#34;thisismypassword\u0026#34;); System.out.println(\u0026#34;Starting Encryption...\u0026#34;); encryptFile.encrypt(directoryPath + fileToEncrypt, directoryPath + encryptedFile); System.out.println(\u0026#34;Encryption completed...\u0026#34;); encryptFile = new EncryptFile(\u0026#34;thisismypassword\u0026#34;); System.out.println(\u0026#34;Starting Decryption...\u0026#34;); encryptFile.decrypt(directoryPath + encryptedFile, directoryPath + decryptedFile); System.out.println(\u0026#34;Decryption completed...\u0026#34;); } /** * * @param srcPath * @param destPath * * Encrypts the file in srcPath and creates a file in destPath */ private void encrypt(String srcPath, String destPath) { File rawFile = new File(srcPath); File encryptedFile = new File(destPath); InputStream inStream = null; OutputStream outStream = null; try { /** * Initialize the cipher for encryption */ cipher.init(Cipher.ENCRYPT_MODE, secretKey); /** * Initialize input and output streams */ inStream = new FileInputStream(rawFile); outStream = new FileOutputStream(encryptedFile); byte[] buffer = new byte[1024]; int len; while ((len = inStream.read(buffer)) \u0026gt; 0) { outStream.write(cipher.update(buffer, 0, len)); outStream.flush(); } outStream.write(cipher.doFinal()); inStream.close(); outStream.close(); } catch (IllegalBlockSizeException ex) { System.out.println(ex); } catch (BadPaddingException ex) { System.out.println(ex); } catch (InvalidKeyException ex) { System.out.println(ex); } catch (FileNotFoundException ex) { System.out.println(ex); } catch (IOException ex) { System.out.println(ex); } } /** * * @param srcPath * @param destPath * * Decrypts the file in srcPath and creates a file in destPath */ private void decrypt(String srcPath, String destPath) { File encryptedFile = new File(srcPath); File decryptedFile = new File(destPath); InputStream inStream = null; OutputStream outStream = null; try { /** * Initialize the cipher for decryption */ cipher.init(Cipher.DECRYPT_MODE, secretKey); /** * Initialize input and output streams */ inStream = new FileInputStream(encryptedFile); outStream = new FileOutputStream(decryptedFile); byte[] buffer = new byte[1024]; int len; while ((len = inStream.read(buffer)) \u0026gt; 0) { outStream.write(cipher.update(buffer, 0, len)); outStream.flush(); } outStream.write(cipher.doFinal()); inStream.close(); outStream.close(); } catch (IllegalBlockSizeException ex) { System.out.println(ex); } catch (BadPaddingException ex) { System.out.println(ex); } catch (InvalidKeyException ex) { System.out.println(ex); } catch (FileNotFoundException ex) { System.out.println(ex); } catch (IOException ex) { System.out.println(ex); } } } \n",
    "ref": "/blog/2014-04-05-java-encryption-and-decryption-of-an-image-using-blowfish-algorithm-using-password/"
  },{
    "title": "A simple HTTP client and a server in C",
    "date": "February 13, 2014",
    "description": "",
    "body": "The HTTP server sends the files requested by the client, if it is available at the server. The HTTP client uses GET method for requesting files from the server. Only .html, .txt and .pdf files are implemented. On receiving the file, the client program opens it using firefox or gedit or acrobat reader, as per the file type. Note that the given programs were done in Linux (Debian) environment.\nhttpserver.c\n/**httpserver.c**/ #include\u0026#34;stdio.h\u0026#34; #include\u0026#34;stdlib.h\u0026#34; #include\u0026#34;sys/types.h\u0026#34; #include\u0026#34;sys/socket.h\u0026#34; #include\u0026#34;string.h\u0026#34; #include\u0026#34;netinet/in.h\u0026#34; #include\u0026#34;time.h\u0026#34; #include\u0026#34;dirent.h\u0026#34; #include\u0026#34;netdb.h\u0026#34; #define BUF_SIZE 1024  #define CLADDR_LEN 100  int createSocket(char * host, int port); int listenForRequest(int sockfd); char * getFileType(char * file); int main(int argc, char **argv) { DIR * dirptr; FILE * fileptr; time_t timenow; struct tm * timeinfo; time (\u0026amp;timenow); timeinfo = localtime(\u0026amp;timenow); char * header, * request, * path, * newpath, * host; char * dir, * temp; int port, sockfd, connfd; char get[3], http[9]; char filepath[BUF_SIZE]; char http_not_found[] = \u0026#34;HTTP/1.0 404 Not Found\\n\u0026#34;; char http_ok[] = \u0026#34;HTTP/1.0 200 OK\\n\u0026#34;; char buffer[BUF_SIZE]; char * contentType; if (argc != 4) { printf(\u0026#34;usage: [host] [directory] [portnumber]\\n\u0026#34;); exit(1); } header = (char*)malloc(BUF_SIZE*sizeof(char)); request = (char*)malloc(BUF_SIZE*sizeof(char)); path = (char*)malloc(BUF_SIZE*sizeof(char)); newpath = (char*)malloc(BUF_SIZE*sizeof(char)); host = argv[1]; dir = argv[2]; port = atoi(argv[3]); if ((dirptr = opendir(dir)) == NULL) { printf(\u0026#34;Directory Not Found!\\n\u0026#34;); exit(1); } sockfd = createSocket(host, port); for (;;) { printf(\u0026#34;--------------------------------------------------------\\n\u0026#34;); printf(\u0026#34;Waiting for a connection...\\n\u0026#34;); connfd = listenForRequest(sockfd); //gets the request from the connection  recv(connfd, request, 100, 0); printf(\u0026#34;Processing request...\\n\u0026#34;); //parses request  sscanf(request, \u0026#34;%s %s %s\u0026#34;, get, path, http); newpath = path + 1; //ignores the first slash  sprintf(filepath,\u0026#34;%s/%s\u0026#34;, dir, newpath); contentType = getFileType(newpath); sprintf(header, \u0026#34;Date: %sHostname: %s:%d\\nLocation: %s\\nContent-Type: %s\\n\\n\u0026#34;, asctime(timeinfo), host, port, newpath, contentType); if ((fileptr = fopen(filepath, \u0026#34;r\u0026#34;)) == NULL ) { printf(\u0026#34;File not found!\\n\u0026#34;); send(connfd, http_not_found, strlen(http_not_found), 0); //sends HTTP 404  } else { printf(\u0026#34;Sending the file...\\n\u0026#34;); send(connfd, http_ok, strlen(http_ok), 0); //sends HTTP 200 OK  recv(connfd, buffer, BUF_SIZE, 0); if ((temp = strstr(buffer, \u0026#34;OK\u0026#34;)) == NULL) { printf(\u0026#34;Operation aborted by the user!\\n\u0026#34;); break; } send(connfd, header, strlen(header), 0); //sends the header  recv(connfd, buffer, BUF_SIZE, 0); if ((temp = strstr(buffer, \u0026#34;OK\u0026#34;)) == NULL) { printf(\u0026#34;Operation aborted by the user!\\n\u0026#34;); break; } memset(\u0026amp;buffer, 0, sizeof(buffer)); while (!feof(fileptr)) { //sends the file  fread(\u0026amp;buffer, sizeof(buffer), 1, fileptr); send(connfd, buffer, sizeof(buffer), 0); memset(\u0026amp;buffer, 0, sizeof(buffer)); } printf(\u0026#34;File sent...\\n\u0026#34;); } printf(\u0026#34;Processing completed...\\n\u0026#34;); close(connfd); } close(sockfd); free(header); free(request); free(path); free(newpath); return 0; } int createSocket(char * host, int port) { int sockfd; struct sockaddr_in addr; struct hostent * host_ent; char * hostAddr; memset(\u0026amp;addr, 0, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_addr.s_addr = INADDR_ANY; addr.sin_port = htons((short)port); sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd \u0026lt; 0) { printf(\u0026#34;Error creating socket!\\n\u0026#34;); exit(1); } printf(\u0026#34;Socket created...\\n\u0026#34;); if (bind(sockfd, (struct sockaddr *)\u0026amp;addr, sizeof(addr)) \u0026lt; 0) { printf(\u0026#34;Error binding socket to port!\\n\u0026#34;); exit(1); } printf(\u0026#34;Binding done...\\n\u0026#34;); return sockfd; } int listenForRequest(int sockfd) { int conn; char hostip[32]; struct sockaddr_in addr; struct hostent * host; struct in_addr inAddr; int len; addr.sin_family = AF_INET; listen(sockfd, 5); //maximum 5 connections  len = sizeof(addr); if ((conn = accept(sockfd, (struct sockaddr *)\u0026amp;addr, \u0026amp;len)) \u0026lt; 0) { printf(\u0026#34;Error accepting connection!\\n\u0026#34;); exit(1); } printf(\u0026#34;Connection accepted...\\n\u0026#34;); inet_ntop(AF_INET, \u0026amp;(addr.sin_addr), hostip, 32); inet_pton(AF_INET, hostip, \u0026amp;inAddr); host = gethostbyaddr(\u0026amp;inAddr, sizeof(inAddr), AF_INET); printf(\u0026#34;---Connection received from: %s [IP= %s]---\\n\u0026#34;, host-\u0026gt;h_name, hostip); return conn; } char * getFileType(char * file) { char * temp; if ((temp = strstr(file, \u0026#34;.html\u0026#34;)) != NULL) { return \u0026#34;text/html\u0026#34;; } else if ((temp = strstr(file, \u0026#34;.pdf\u0026#34;)) != NULL) { return \u0026#34;application/pdf\u0026#34;; } else if ((temp = strstr(file, \u0026#34;.txt\u0026#34;)) != NULL) { return \u0026#34;text/html\u0026#34;; } } httpclient.c\n/**httpclient.c**/ #include\u0026#34;stdio.h\u0026#34;  #include\u0026#34;stdlib.h\u0026#34;  #include\u0026#34;sys/types.h\u0026#34;  #include\u0026#34;sys/socket.h\u0026#34;  #include\u0026#34;string.h\u0026#34;  #include\u0026#34;netinet/in.h\u0026#34;  #include\u0026#34;netdb.h\u0026#34; #define BUF_SIZE 1024  int get_request(char * url, char * port); int isValidIP(char * ip); int parseHeader(char * header); char * splitKeyValue(char * line, int index); void openFile(); FILE * fileptr; char keys[][25] = {\u0026#34;Date: \u0026#34;, \u0026#34;Hostname: \u0026#34;, \u0026#34;Location: \u0026#34;, \u0026#34;Content-Type: \u0026#34;}; char status[4] = {0, 0, 0, 0}; char contentFileType[100]; char path[1000]; int main(int argc, char**argv) { struct sockaddr_in addr, cl_addr; int sockfd, ret; struct hostent * server; char * url, * temp; int portNumber; char * fileName; char status_ok[] = \u0026#34;OK\u0026#34;; char buffer[BUF_SIZE]; char http_not_found[] = \u0026#34;HTTP/1.0 404 Not Found\u0026#34;; char http_ok[] = \u0026#34;HTTP/1.0 200 OK\u0026#34;; char location[] = \u0026#34;Location: \u0026#34;; char contentType[] = \u0026#34;Content-Type: \u0026#34;; int sPos, ePos; if (argc \u0026lt; 3) { printf(\u0026#34;usage: [URL] [port number]\\n\u0026#34;); exit(1); } url = argv[1]; portNumber = atoi(argv[2]); //checking the protocol specified  if ((temp = strstr(url, \u0026#34;http://\u0026#34;)) != NULL) { url = url + 7; } else if ((temp = strstr(url, \u0026#34;https://\u0026#34;)) != NULL) { url = url + 8; } //checking the port number  if (portNumber \u0026gt; 65536 || portNumber \u0026lt; 0) { printf(\u0026#34;Invalid Port Number!\u0026#34;); exit(1); } sockfd = get_request(url, argv[2]); memset(\u0026amp;buffer, 0, sizeof(buffer)); ret = recv(sockfd, buffer, BUF_SIZE, 0); if (ret \u0026lt; 0) { printf(\u0026#34;Error receiving HTTP status!\\n\u0026#34;); } else { printf(\u0026#34;%s\\n\u0026#34;, buffer); if ((temp = strstr(buffer, http_ok)) != NULL) { send(sockfd, status_ok, strlen(status_ok), 0); } else { close(sockfd); return 0; } } memset(\u0026amp;buffer, 0, sizeof(buffer)); ret = recv(sockfd, buffer, BUF_SIZE, 0); if (ret \u0026lt; 0) { printf(\u0026#34;Error receiving HTTP header!\\n\u0026#34;); } else { printf(\u0026#34;%s\\n\u0026#34;, buffer); if (parseHeader(buffer) == 0) { send(sockfd, status_ok, strlen(status_ok), 0); } else { printf(\u0026#34;Error in HTTP header!\\n\u0026#34;); close(sockfd); return 0; } } //printf(\u0026#34;file: [%s]\\n\u0026#34;, fileName);  fileptr = fopen(path, \u0026#34;w\u0026#34;); if (fileptr == NULL) { printf(\u0026#34;Error opening file!\\n\u0026#34;); close(sockfd); return 0; } memset(\u0026amp;buffer, 0, sizeof(buffer)); while (recv(sockfd, buffer, BUF_SIZE, 0) \u0026gt; 0) { //receives the file  if ((strstr(contentFileType, \u0026#34;text/html\u0026#34;)) != NULL) { fprintf(fileptr, \u0026#34;%s\u0026#34;, buffer); } else { fwrite(\u0026amp;buffer, sizeof(buffer), 1, fileptr); } memset(\u0026amp;buffer, 0, sizeof(buffer)); } fclose(fileptr); close(sockfd); openFile(); return 0; } int get_request(char * url, char * port) { int sockfd, bindfd; char * ptr, * host; char getrequest[1024]; struct sockaddr_in addr; if (isValidIP(url)) { //when an IP address is given  sprintf(getrequest, \u0026#34;GET / HTTP/1.0\\nHOST: %s\\n\\n\u0026#34;, url); } else { //when a host name is given  if ((ptr = strstr(url, \u0026#34;/\u0026#34;)) == NULL) { //when hostname does not contain a slash  sprintf(getrequest, \u0026#34;GET / HTTP/1.0\\nHOST: %s\\n\\n\u0026#34;, url); } else { //when hostname contains a slash, it is a path to file  strcpy(path, ptr); host = strtok(url, \u0026#34;/\u0026#34;); sprintf(getrequest, \u0026#34;GET %s HTTP/1.0\\nHOST: %s\\n\\n\u0026#34;, path, url); } } // creates a socket to the host  sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd \u0026lt; 0) { printf(\u0026#34;Error creating socket!\\n\u0026#34;); exit(1); } printf(\u0026#34;Socket created...\\n\u0026#34;); memset(\u0026amp;addr, 0, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_addr.s_addr = inet_addr(url); addr.sin_port = htons(atoi(port)); if (connect(sockfd, (struct sockaddr *) \u0026amp;addr, sizeof(addr)) \u0026lt; 0 ) { printf(\u0026#34;Connection Error!\\n\u0026#34;); exit(1); } printf(\u0026#34;Connection successful...\\n\\n\\n\u0026#34;); ptr = strtok(path, \u0026#34;/\u0026#34;); strcpy(path, ptr); //printf(\u0026#34;path=%s\\n\u0026#34;, path);  //fileptr = fopen(path, \u0026#34;w\u0026#34;);  //strcpy(fileName, path);  //sprintf(fileName, \u0026#34;%s\u0026#34;, path);  //int optval = 1;  //setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, \u0026amp;optval, sizeof optval);  // writes the HTTP GET Request to the sockfd  write(sockfd, getrequest, strlen(getrequest)); return sockfd; } int isValidIP(char * ip) { struct sockaddr_in addr; int valid = inet_pton(AF_INET, ip, \u0026amp;(addr.sin_addr)); return valid != 0; } int parseHeader(char * header) { //\u0026#34;Date: %sHostname: %s:%d\\nLocation: %s\\nContent-Type: %s\\n\\n\u0026#34;  char * line, * key, * value; char temp[100]; int i = 0; line = strtok(header, \u0026#34;\\n\u0026#34;); while (line != NULL) { //printf(\u0026#34;%s\\n\u0026#34;, line);  strcpy(temp, line); value = splitKeyValue(line, i); if (i == 3) { strcpy(contentFileType, value); } //printf(\u0026#34;value=%s\\n\u0026#34;, value);  line = strtok(NULL, \u0026#34;\\n\u0026#34;); i++; } for (i = 0; i \u0026lt; 4; i++) { if (status[i] == 0) return 1; //printf(\u0026#34;status[%d]=%d\\n\u0026#34;, i, status[i]);  } return 0; } char * splitKeyValue(char * line, int index) { char * temp; if ((temp = strstr(line, keys[index])) != NULL) { temp = temp + strlen(keys[index]); status[index] = 1; } return temp; } void openFile() { char * temp; char command[100]; char fileName[1000]; strcpy(fileName, path); //printf(\u0026#34;File Name: %s\\n\u0026#34;, fileName);  //printf(\u0026#34;Content Type: %s\\n\u0026#34;, contentFileType);  if ((temp = strstr(contentFileType, \u0026#34;text/html\u0026#34;)) != NULL) { if ((temp = strstr(fileName, \u0026#34;.txt\u0026#34;)) != NULL) { sprintf(command, \u0026#34;gedit %s\u0026#34;, fileName); } else { sprintf(command, \u0026#34;firefox %s\u0026#34;, fileName); } system(command); } else if ((temp = strstr(contentFileType, \u0026#34;application/pdf\u0026#34;)) != NULL) { sprintf(command, \u0026#34;acroread %s\u0026#34;, fileName); system(command); } else { printf(\u0026#34;The filetype %s is not supported. Failed to open %s!\\n\u0026#34;, contentFileType, fileName); } } Execution:\n(terminal 1)\ngcc httpserver.c -o server ./server 'www.dhanoop.com' '/home/dhanoopbhaskar/coding/http/dir/' 4444  (terminal 2)\ngcc httpclient.c -o client ./client '192.168.0.6/abc.txt' 4444 ./client '192.168.0.6/abc.html' 4444 ./client '192.168.0.6/abc.pdf' 4444  NB: The requested files abc.txt, abc.html and abc.pdf should be present in the path /home/dhanoopbhaskar/coding/http/dir/ (or whatever is given while running server).\n",
    "ref": "/blog/2014-02-13-a-simple-http-client-and-a-server-in-c/"
  },{
    "title": "A simple chat program in C (TCP)",
    "date": "January 22, 2014",
    "description": "",
    "body": "tcpserver.c\n#include\u0026#34;stdio.h\u0026#34; #include\u0026#34;stdlib.h\u0026#34; #include\u0026#34;sys/types.h\u0026#34; #include\u0026#34;sys/socket.h\u0026#34; #include\u0026#34;string.h\u0026#34; #include\u0026#34;netinet/in.h\u0026#34; #include\u0026#34;pthread.h\u0026#34; #define PORT 4444  #define BUF_SIZE 2000  #define CLADDR_LEN 100  void * receiveMessage(void * socket) { int sockfd, ret; char buffer[BUF_SIZE]; sockfd = (int) socket; memset(buffer, 0, BUF_SIZE); for (;;) { ret = recvfrom(sockfd, buffer, BUF_SIZE, 0, NULL, NULL); if (ret \u0026lt; 0) { printf(\u0026#34;Error receiving data!\\n\u0026#34;); } else { printf(\u0026#34;client: \u0026#34;); fputs(buffer, stdout); //printf(\u0026#34;\\n\u0026#34;);  } } } void main() { struct sockaddr_in addr, cl_addr; int sockfd, len, ret, newsockfd; char buffer[BUF_SIZE]; pid_t childpid; char clientAddr[CLADDR_LEN]; pthread_t rThread; sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd \u0026lt; 0) { printf(\u0026#34;Error creating socket!\\n\u0026#34;); exit(1); } printf(\u0026#34;Socket created...\\n\u0026#34;); memset(\u0026amp;addr, 0, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_addr.s_addr = INADDR_ANY; addr.sin_port = PORT; ret = bind(sockfd, (struct sockaddr *) \u0026amp;addr, sizeof(addr)); if (ret \u0026lt; 0) { printf(\u0026#34;Error binding!\\n\u0026#34;); exit(1); } printf(\u0026#34;Binding done...\\n\u0026#34;); printf(\u0026#34;Waiting for a connection...\\n\u0026#34;); listen(sockfd, 5); len = sizeof(cl_addr); newsockfd = accept(sockfd, (struct sockaddr *) \u0026amp;cl_addr, \u0026amp;len); if (newsockfd \u0026lt; 0) { printf(\u0026#34;Error accepting connection!\\n\u0026#34;); exit(1); } inet_ntop(AF_INET, \u0026amp;(cl_addr.sin_addr), clientAddr, CLADDR_LEN); printf(\u0026#34;Connection accepted from %s...\\n\u0026#34;, clientAddr); memset(buffer, 0, BUF_SIZE); printf(\u0026#34;Enter your messages one by one and press return key!\\n\u0026#34;); //creating a new thread for receiving messages from the client  ret = pthread_create(\u0026amp;rThread, NULL, receiveMessage, (void *) newsockfd); if (ret) { printf(\u0026#34;ERROR: Return Code from pthread_create() is %d\\n\u0026#34;, ret); exit(1); } while (fgets(buffer, BUF_SIZE, stdin) != NULL) { ret = sendto(newsockfd, buffer, BUF_SIZE, 0, (struct sockaddr *) \u0026amp;cl_addr, len); if (ret \u0026lt; 0) { printf(\u0026#34;Error sending data!\\n\u0026#34;); exit(1); } } close(newsockfd); close(sockfd); pthread_exit(NULL); return; } tcpclient.c\n#include\u0026#34;stdio.h\u0026#34;  #include\u0026#34;stdlib.h\u0026#34;  #include\u0026#34;sys/types.h\u0026#34;  #include\u0026#34;sys/socket.h\u0026#34;  #include\u0026#34;string.h\u0026#34;  #include\u0026#34;netinet/in.h\u0026#34;  #include\u0026#34;netdb.h\u0026#34; #include\u0026#34;pthread.h\u0026#34; #define PORT 4444  #define BUF_SIZE 2000  void * receiveMessage(void * socket) { int sockfd, ret; char buffer[BUF_SIZE]; sockfd = (int) socket; memset(buffer, 0, BUF_SIZE); for (;;) { ret = recvfrom(sockfd, buffer, BUF_SIZE, 0, NULL, NULL); if (ret \u0026lt; 0) { printf(\u0026#34;Error receiving data!\\n\u0026#34;); } else { printf(\u0026#34;server: \u0026#34;); fputs(buffer, stdout); //printf(\u0026#34;\\n\u0026#34;);  } } } int main(int argc, char**argv) { struct sockaddr_in addr, cl_addr; int sockfd, ret; char buffer[BUF_SIZE]; char * serverAddr; pthread_t rThread; if (argc \u0026lt; 2) { printf(\u0026#34;usage: client \u0026lt; ip address \u0026gt;\\n\u0026#34;); exit(1); } serverAddr = argv[1]; sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd \u0026lt; 0) { printf(\u0026#34;Error creating socket!\\n\u0026#34;); exit(1); } printf(\u0026#34;Socket created...\\n\u0026#34;); memset(\u0026amp;addr, 0, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_addr.s_addr = inet_addr(serverAddr); addr.sin_port = PORT; ret = connect(sockfd, (struct sockaddr *) \u0026amp;addr, sizeof(addr)); if (ret \u0026lt; 0) { printf(\u0026#34;Error connecting to the server!\\n\u0026#34;); exit(1); } printf(\u0026#34;Connected to the server...\\n\u0026#34;); memset(buffer, 0, BUF_SIZE); printf(\u0026#34;Enter your messages one by one and press return key!\\n\u0026#34;); //creating a new thread for receiving messages from the server  ret = pthread_create(\u0026amp;rThread, NULL, receiveMessage, (void *) sockfd); if (ret) { printf(\u0026#34;ERROR: Return Code from pthread_create() is %d\\n\u0026#34;, ret); exit(1); } while (fgets(buffer, BUF_SIZE, stdin) != NULL) { ret = sendto(sockfd, buffer, BUF_SIZE, 0, (struct sockaddr *) \u0026amp;addr, sizeof(addr)); if (ret \u0026lt; 0) { printf(\u0026#34;Error sending data!\\n\\t-%s\u0026#34;, buffer); } } close(sockfd); pthread_exit(NULL); return 0; }  (terminal 1)\ngcc tcpserver.c -o server -pthread ./server  (terminal 2)\ngcc tcpclient.c -o client -pthread ./client 192.168.0.4  NB: Here 192.168.0.4 is the IP address of the system where server code is running\n",
    "ref": "/blog/2014-01-22-a-simple-chat-program-in-c-tcp/"
  },{
    "title": "TCP in C (one server and multiple clients) ",
    "date": "January 16, 2014",
    "description": "",
    "body": "tcpserver.c\n#include\u0026#34;stdio.h\u0026#34; #include\u0026#34;stdlib.h\u0026#34; #include\u0026#34;sys/types.h\u0026#34; #include\u0026#34;sys/socket.h\u0026#34; #include\u0026#34;string.h\u0026#34; #include\u0026#34;netinet/in.h\u0026#34; #define PORT 4444  #define BUF_SIZE 2000  #define CLADDR_LEN 100  void main() { struct sockaddr_in addr, cl_addr; int sockfd, len, ret, newsockfd; char buffer[BUF_SIZE]; pid_t childpid; char clientAddr[CLADDR_LEN]; sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd \u0026lt; 0) { printf(\u0026#34;Error creating socket!\\n\u0026#34;); exit(1); } printf(\u0026#34;Socket created...\\n\u0026#34;); memset(\u0026amp;addr, 0, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_addr.s_addr = INADDR_ANY; addr.sin_port = PORT; ret = bind(sockfd, (struct sockaddr *) \u0026amp;addr, sizeof(addr)); if (ret \u0026lt; 0) { printf(\u0026#34;Error binding!\\n\u0026#34;); exit(1); } printf(\u0026#34;Binding done...\\n\u0026#34;); printf(\u0026#34;Waiting for a connection...\\n\u0026#34;); listen(sockfd, 5); for (;;) { //infinite loop  len = sizeof(cl_addr); newsockfd = accept(sockfd, (struct sockaddr *) \u0026amp;cl_addr, \u0026amp;len); if (newsockfd \u0026lt; 0) { printf(\u0026#34;Error accepting connection!\\n\u0026#34;); exit(1); } printf(\u0026#34;Connection accepted...\\n\u0026#34;); inet_ntop(AF_INET, \u0026amp;(cl_addr.sin_addr), clientAddr, CLADDR_LEN); if ((childpid = fork()) == 0) { //creating a child process  close(sockfd); //stop listening for new connections by the main process.  //the child will continue to listen.  //the main process now handles the connected client.  for (;;) { memset(buffer, 0, BUF_SIZE); ret = recvfrom(newsockfd, buffer, BUF_SIZE, 0, (struct sockaddr *) \u0026amp;cl_addr, \u0026amp;len); if(ret \u0026lt; 0) { printf(\u0026#34;Error receiving data!\\n\u0026#34;); exit(1); } printf(\u0026#34;Received data from %s: %s\\n\u0026#34;, clientAddr, buffer); ret = sendto(newsockfd, buffer, BUF_SIZE, 0, (struct sockaddr *) \u0026amp;cl_addr, len); if (ret \u0026lt; 0) { printf(\u0026#34;Error sending data!\\n\u0026#34;); exit(1); } printf(\u0026#34;Sent data to %s: %s\\n\u0026#34;, clientAddr, buffer); } } close(newsockfd); } } tcpclient.c\n#include\u0026#34;stdio.h\u0026#34;  #include\u0026#34;stdlib.h\u0026#34;  #include\u0026#34;sys/types.h\u0026#34;  #include\u0026#34;sys/socket.h\u0026#34;  #include\u0026#34;string.h\u0026#34;  #include\u0026#34;netinet/in.h\u0026#34;  #include\u0026#34;netdb.h\u0026#34; #define PORT 4444  #define BUF_SIZE 2000  int main(int argc, char**argv) { struct sockaddr_in addr, cl_addr; int sockfd, ret; char buffer[BUF_SIZE]; struct hostent * server; char * serverAddr; if (argc \u0026lt; 2) { printf(\u0026#34;usage: client \u0026lt; ip address \u0026gt;\\n\u0026#34;); exit(1); } serverAddr = argv[1]; sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd \u0026lt; 0) { printf(\u0026#34;Error creating socket!\\n\u0026#34;); exit(1); } printf(\u0026#34;Socket created...\\n\u0026#34;); memset(\u0026amp;addr, 0, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_addr.s_addr = inet_addr(serverAddr); addr.sin_port = PORT; ret = connect(sockfd, (struct sockaddr *) \u0026amp;addr, sizeof(addr)); if (ret \u0026lt; 0) { printf(\u0026#34;Error connecting to the server!\\n\u0026#34;); exit(1); } printf(\u0026#34;Connected to the server...\\n\u0026#34;); memset(buffer, 0, BUF_SIZE); printf(\u0026#34;Enter your message(s): \u0026#34;); while (fgets(buffer, BUF_SIZE, stdin) != NULL) { ret = sendto(sockfd, buffer, BUF_SIZE, 0, (struct sockaddr *) \u0026amp;addr, sizeof(addr)); if (ret \u0026lt; 0) { printf(\u0026#34;Error sending data!\\n\\t-%s\u0026#34;, buffer); } ret = recvfrom(sockfd, buffer, BUF_SIZE, 0, NULL, NULL); if (ret \u0026lt; 0) { printf(\u0026#34;Error receiving data!\\n\u0026#34;); } else { printf(\u0026#34;Received: \u0026#34;); fputs(buffer, stdout); printf(\u0026#34;\\n\u0026#34;); } } return 0; } First run the tcpserver code and then run multiple instances of the tcpclient code (i.e., in different terminal windows/tabs)\n",
    "ref": "/blog/2014-01-16-tcp-in-c-one-server-and-multiple-clients/"
  },{
    "title": "Socket Programming in C, TCP over a network (2 systems)",
    "date": "January 16, 2014",
    "description": "",
    "body": "tcpserver.c\n#include\u0026#34;stdio.h\u0026#34; #include\u0026#34;stdlib.h\u0026#34; #include\u0026#34;sys/types.h\u0026#34; #include\u0026#34;sys/socket.h\u0026#34; #include\u0026#34;string.h\u0026#34; #include\u0026#34;netinet/in.h\u0026#34; #define PORT 4444  #define BUF_SIZE 2000  void main() { struct sockaddr_in addr, cl_addr; int sockfd, len, ret, newsockfd; char buffer[BUF_SIZE]; sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd \u0026lt; 0) { printf(\u0026#34;Error creating socket!\\n\u0026#34;); exit(1); } printf(\u0026#34;Socket created...\\n\u0026#34;); memset(\u0026amp;addr, 0, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_addr.s_addr = INADDR_ANY; addr.sin_port = PORT; ret = bind(sockfd, (struct sockaddr *) \u0026amp;addr, sizeof(addr)); if (ret \u0026lt; 0) { printf(\u0026#34;Error binding!\\n\u0026#34;); exit(1); } printf(\u0026#34;Binding done...\\n\u0026#34;); printf(\u0026#34;Waiting for a connection...\\n\u0026#34;); listen(sockfd, 5); len = sizeof(cl_addr); newsockfd = accept(sockfd, (struct sockaddr *) \u0026amp;cl_addr, \u0026amp;len); if (newsockfd \u0026lt; 0) { printf(\u0026#34;Error accepting connection!\\n\u0026#34;); exit(1); } printf(\u0026#34;Connection accepted...\\n\u0026#34;); memset(buffer, 0, BUF_SIZE); ret = recv(newsockfd, buffer, BUF_SIZE, 0); if(ret \u0026lt; 0) { printf(\u0026#34;Error receiving data!\\n\u0026#34;); exit(1); } printf(\u0026#34;Received data: %s\\n\u0026#34;, buffer); ret = send(newsockfd, buffer, strlen(buffer), 0); if (ret \u0026lt; 0) { printf(\u0026#34;Error sending data!\\n\u0026#34;); exit(1); } printf(\u0026#34;Sent data: %s\\n\u0026#34;, buffer); close(sockfd); close(newsockfd); } tcpclient.c\n#include\u0026#34;stdio.h\u0026#34;  #include\u0026#34;stdlib.h\u0026#34;  #include\u0026#34;sys/types.h\u0026#34;  #include\u0026#34;sys/socket.h\u0026#34;  #include\u0026#34;string.h\u0026#34;  #include\u0026#34;netinet/in.h\u0026#34;  #include\u0026#34;netdb.h\u0026#34; #define PORT 4444  #define BUF_SIZE 2000  int main(int argc, char**argv) { struct sockaddr_in addr, cl_addr; int sockfd, ret; char buffer[BUF_SIZE]; struct hostent * server; char * serverAddr; if (argc \u0026lt; 2) { printf(\u0026#34;usage: client \u0026lt; ip address \u0026gt;\\n\u0026#34;); exit(1); } serverAddr = argv[1]; sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd \u0026lt; 0) { printf(\u0026#34;Error creating socket!\\n\u0026#34;); exit(1); } printf(\u0026#34;Socket created...\\n\u0026#34;); memset(\u0026amp;addr, 0, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_addr.s_addr = inet_addr(serverAddr); addr.sin_port = PORT; ret = connect(sockfd, (struct sockaddr *) \u0026amp;addr, sizeof(addr)); if (ret \u0026lt; 0) { printf(\u0026#34;Error connecting to the server!\\n\u0026#34;); exit(1); } printf(\u0026#34;Connected to the server...\\n\u0026#34;); memset(buffer, 0, BUF_SIZE); printf(\u0026#34;Enter your message: \u0026#34;); scanf(\u0026#34;%s\u0026#34;, buffer); ret = send(sockfd, buffer, strlen(buffer), 0); if (ret \u0026lt; 0) { printf(\u0026#34;Error sending data!\\n\u0026#34;); exit(1); } printf(\u0026#34;Sent data: %s\\n\u0026#34;, buffer); memset(buffer, 0, BUF_SIZE); ret = recv(sockfd, buffer, BUF_SIZE, 0); if(ret \u0026lt; 0) { printf(\u0026#34;Error receiving data!\\n\u0026#34;); exit(1); } printf(\u0026#34;Received data: %s\\n\u0026#34;, buffer); return 0; }  Output:\nterminal 1\ndhanoopbhaskar@dhanoop-laptop:~/coding/tcp_2sys$ gcc tcpserver.c -o server dhanoopbhaskar@dhanoop-laptop:~/coding/tcp_2sys$ gcc tcpclient.c -o client dhanoopbhaskar@dhanoop-laptop:~/coding/tcp_2sys$ ./server Socket created... Binding done... Waiting for a connection... Connection accepted... Received data: hi Sent data: hi dhanoopbhaskar@dhanoop-laptop:~/coding/tcp_2sys$ p-laptop:~/coding/tcp_2sys$ gcc tcpclient.c -o client dhanoopbhaskar@dhanoop-laptop:~/coding/tcp_2sys$ ./server Socket created... Binding done... Waiting for a connection... Connection accepted... Received data: hi Sent data: hi dhanoopbhaskar@dhanoop-laptop:~/coding/tcp_2sys$  terminal 2\ndhanoopbhaskar@dhanoop-laptop:~/coding/tcp_2sys$ ./client usage: client dhanoopbhaskar@dhanoop-laptop:~/coding/tcp_2sys$ ./client 192.168.0.4 Socket created... Connected to the server... Enter your message: hi Sent data: hi Received data: hi dhanoopbhaskar@dhanoop-laptop:~/coding/tcp_2sys$  NB: Here 192.168.0.4 is the IP address of the system where tcpserver code is running\n",
    "ref": "/blog/2014-01-16-socket-programming-in-c-tcp-over-a-network-2-systems/"
  },{
    "title": "Socket Programming In C (TCP)",
    "date": "January 5, 2014",
    "description": "",
    "body": "tcpserver.c\n#include\u0026#34;stdio.h\u0026#34; #include\u0026#34;stdlib.h\u0026#34; #include\u0026#34;sys/types.h\u0026#34; #include\u0026#34;sys/socket.h\u0026#34; #include\u0026#34;string.h\u0026#34; #include\u0026#34;netinet/in.h\u0026#34; #define PORT 4444  #define BUF_SIZE 20  void main() { struct sockaddr_in addr, cl_addr; int sockfd, len, ret, newsockfd; char buffer[BUF_SIZE]; sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd \u0026lt; 0) { printf(\u0026#34;Error creating socket!\\n\u0026#34;); exit(1); } printf(\u0026#34;Socket created...\\n\u0026#34;); memset(\u0026amp;addr, 0, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_addr.s_addr = INADDR_ANY; addr.sin_port = PORT; ret = bind(sockfd, (struct sockaddr *) \u0026amp;addr, sizeof(addr)); if (ret \u0026lt; 0) { printf(\u0026#34;Error binding!\\n\u0026#34;); exit(1); } printf(\u0026#34;Binding done...\\n\u0026#34;); printf(\u0026#34;Waiting for a connection...\\n\u0026#34;); listen(sockfd, 5); len = sizeof(cl_addr); newsockfd = accept(sockfd, (struct sockaddr *) \u0026amp;cl_addr, \u0026amp;len); if (newsockfd \u0026lt; 0) { printf(\u0026#34;Error accepting connection!\\n\u0026#34;); exit(1); } printf(\u0026#34;Connection accepted...\\n\u0026#34;); memset(buffer, 0, BUF_SIZE); ret = recv(newsockfd, buffer, BUF_SIZE, 0); if(ret \u0026lt; 0) { printf(\u0026#34;Error receiving data!\\n\u0026#34;); exit(1); } printf(\u0026#34;Received data: %s\\n\u0026#34;, buffer); } tcpclient.c\n#include\u0026#34;stdio.h\u0026#34; #include\u0026#34;stdlib.h\u0026#34; #include\u0026#34;sys/types.h\u0026#34; #include\u0026#34;sys/socket.h\u0026#34; #include\u0026#34;string.h\u0026#34; #include\u0026#34;netinet/in.h\u0026#34; #define PORT 4444  void main() { struct sockaddr_in addr, cl_addr; int sockfd, ret; char * buffer=\u0026#34;hi there?\u0026#34;; sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd \u0026lt; 0) { printf(\u0026#34;Error creating socket!\\n\u0026#34;); exit(1); } printf(\u0026#34;Socket created...\\n\u0026#34;); memset(\u0026amp;addr, 0, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_addr.s_addr = INADDR_ANY; addr.sin_port = PORT; ret = connect(sockfd, (struct sockaddr *) \u0026amp;addr, sizeof(addr)); if (ret \u0026lt; 0) { printf(\u0026#34;Error connecting to the server!\\n\u0026#34;); exit(1); } printf(\u0026#34;Connected to the server...\\n\u0026#34;); ret = send(sockfd, buffer, strlen(buffer), 0); if (ret \u0026lt; 0) { printf(\u0026#34;Error sending data!\\n\u0026#34;); exit(1); } printf(\u0026#34;Sent data: %s\\n\u0026#34;, buffer); } Executing the program\n(in first terminal)\ngcc tcpserver.c -o server ./server  (in second terminal)\ngcc tcpclient.c -o client ./client  ",
    "ref": "/blog/2014-01-05-socket-programming-in-c-tcp/"
  },{
    "title": "Initialization-on-demand holder idiom",
    "date": "August 31, 2013",
    "description": "",
    "body": "See Singleton PatternÂ here\u0026hellip;\npackage me.dhanoop.singleton; /** * * @author dhanoopbhaskar */ public class Singleton { private static class HelperHolder { public static Helper helper = new Helper(); } public static Helper getHelper() { return HelperHolder.helper; } public static void main(String[] args) { Runnable runnable = new Runnable() { @Override public void run() { Singleton.getHelper(); } }; new Thread(runnable).start(); new Thread(runnable).start(); new Thread(runnable).start(); } }  Here, as the helper object is static, an alternative is used - initialization-on-demand holder idiom. This is based on the fact that inner classes are not loaded until they are referenced.\n",
    "ref": "/blog/2013-08-31-initialization-on-demand-holder-idiom/"
  },{
    "title": "Eager initialization",
    "date": "August 31, 2013",
    "description": "",
    "body": "See Singleton Pattern here\u0026hellip;\nIf the program will always need an instance, or if the cost of creating the instance is not too large in terms of time/resources, the programmer can switch to eager initialization, which always creates an instance.\nSingleton.java\npackage me.dhanoop.singleton; /** * * @author dhanoopbhaskar */ public class Singleton { private static final Helper helper = new Helper(); public static Helper getHelper() { return helper; } public static void main(String[] args) { Runnable runnable = new Runnable() { @Override public void run() { Singleton.getHelper(); } }; new Thread(runnable).start(); new Thread(runnable).start(); new Thread(runnable).start(); } } Output:\nCreated Helper Object  Advantages:\n The instance is not constructed until the class is used. There is no need of synchronization, which means all the threads will see the same instance even without expensive locking mechanism. The final keyword means that the instance cannot be redefined, ensuring that one (and only one) instance ever exists.  ",
    "ref": "/blog/2013-08-31-eager-initialization/"
  },{
    "title": "Double-checked locking and Lazy initialization",
    "date": "August 31, 2013",
    "description": "",
    "body": "Lazy initialization is the tactic of delaying the creation of an object, the calculation of a value, or some other expensive process until the first time it is needed.\nThis is generally accomplished by maintaining a flag indicating whether the process has taken place. Each time the desired object is summoned, the flag is tested. If it is ready, it is returned. If not, it is initialized on the spot. In multithreaded code, access to the flag must be synchronized to guard against a race condition.\nRead more about lazy initialization here\u0026hellip;\nLet us consider Singleton Pattern again.\nSingleton.java\npackage me.dhanoop.singleton; /** * * @author dhanoopbhaskar */ public class Singleton { private static Helper helper = null; public static Helper getHelper() { if (helper == null) { synchronized (Singleton.class) { if (helper == null) { helper = new Helper(); } } } return helper; } public static void main(String[] args) { Runnable runnable = new Runnable() { @Override public void run() { Singleton.getHelper(); } }; new Thread(runnable).start(); new Thread(runnable).start(); new Thread(runnable).start(); } } Note: This method uses double-checked locking, which should NOT be used prior to JSE 5.0, as it is vulnerable to subtle bugs. The problem is that an out-of-order write may allow the instance reference to be returned before the Singleton constructor is executed.\nThe above code does NOT work in the presence of either optimizing compilers or shared memory multiprocessors.\nThe helper field can have a reference before completely creating an object of Helper class. Thus, a thread which invokes getHelper() could see a non-null reference to a Helper object, but see the default values for fields of the Helper object, rather than the values set in the constructor. This occurs due to compiler based re-orderings (for optimization) or on a multi-processor system, the memory writes may get re-ordered.\nFixing Double-Checked Locking using Volatile JDK5 and later extends the semantics for volatile so that the system will not allow a write of a volatile to be reordered with respect to any previous read or write, and a read of a volatile cannot be reordered with respect to any following read or write.\nWith this change, the Double-Checked Locking idiom can be made to work by declaring the helper field to be volatile. This does not work under JDK4 and earlier.\nSingleton.java\npackage me.dhanoop.singleton; /** * * @author dhanoopbhaskar */ public class Singleton { private static volatile Helper helper = null; public static Helper getHelper() { if (helper == null) { synchronized (Singleton.class) { if (helper == null) { helper = new Helper(); } } } return helper; } public static void main(String[] args) { Runnable runnable = new Runnable() { @Override public void run() { Singleton.getHelper(); } }; new Thread(runnable).start(); new Thread(runnable).start(); new Thread(runnable).start(); } }  Another solution:\nHereÂ the local variable result, which seems unnecessary, ensures that in cases where helper is already initialized, the volatile field is only accessed once, which can improve the method\u0026rsquo;s overall performance by as much as 25 percent.\npackage me.dhanoop.singleton; /** * * @author dhanoopbhaskar */ public class Singleton { private static volatile Helper helper = null; public static Helper getHelper() { Helper result = helper; if (result == null) { synchronized (Singleton.class) { result = helper; if (result == null) { helper = result = new Helper(); } } } return result; } public static void main(String[] args) { Runnable runnable = new Runnable() { @Override public void run() { Singleton.getHelper(); } }; new Thread(runnable).start(); new Thread(runnable).start(); new Thread(runnable).start(); } } Read more aboutÂ Double-Checked Locking here\u0026hellip;\n",
    "ref": "/blog/2013-08-31-double-checked-locking-and-lazy-initialization/"
  },{
    "title": "Singleton Pattern",
    "date": "August 31, 2013",
    "description": "",
    "body": "In software engineering, the singleton pattern is a design pattern that restricts a class from creating more than one object (Instantiation is restricted to one object).Â Such a design is generally used in a software system which operates more efficiently when only one object exists. It is useful when exactly one object is needed to coordinate actions across the system.\nRead more about singleton pattern here\u0026hellip;\nJava implementation\n1. Single Threaded version\nHelper.java\npackage me.dhanoop.singleton; /** * * @author dhanoopbhaskar */ public class Helper { public Helper() { System.out.println(\u0026#34;Created Helper Object\u0026#34;); } }  Singleton.java\npackage me.dhanoop.singleton; /** * * @author dhanoopbhaskar */ public class Singleton { private Helper helper = null; public Helper getHelper() { if (helper == null) { helper = new Helper(); } return helper; } public static void main(String[] args) { Singleton instance1 = new Singleton(); Helper helper1 = instance1.getHelper(); Helper helper2 = instance1.getHelper(); Helper helper3 = instance1.getHelper(); } } Output:\nCreated Helper Object  2. Multi-threaded version\nSingleton.java\npackage me.dhanoop.singleton; /** * * @author dhanoopbhaskar */ public class Singleton { private static Helper helper = null; public static Helper getHelper() { if (helper == null) { helper = new Helper(); } return helper; } public static void main(String[] args) { Runnable runnable = new Runnable() { @Override public void run() { Singleton.getHelper(); } }; new Thread(runnable).start(); new Thread(runnable).start(); new Thread(runnable).start(); } } Output:\nCreated Helper Object Created Helper Object Created Helper Object  Note: The output may vary depending on the execution of threads. Sometimes you will get only two lines in the output.\n The above is not a desired output. The Helper object should be created only once.\n 3. Corrected multi-threaded version\nSingleton.java\npackage me.dhanoop.singleton; /** * * @author dhanoopbhaskar */ public class Singleton { private static Helper helper = null; public static synchronized Helper getHelper() { if (helper == null) { helper = new Helper(); } return helper; } public static void main(String[] args) { Runnable runnable = new Runnable() { @Override public void run() { Singleton.getHelper(); } }; new Thread(runnable).start(); new Thread(runnable).start(); new Thread(runnable).start(); } } Output:\nCreated Helper Object  Note:Â The code above performs synchronization every timeÂ getHelper()Â is called. The double-checked locking idiom tries to avoid synchronization after the helper is allocated.\n",
    "ref": "/blog/2013-08-31-singleton-pattern/"
  },{
    "title": "Software Design Pattern",
    "date": "August 31, 2013",
    "description": "",
    "body": " A software design pattern is a general reusable solution to a commonly occurring problem within a given context in software design. A design pattern is not a finished or completed design. It is actually a description or template for solution to a problem.\n Design patterns are of many types, such as:\n Algorithm strategy patterns Computational design patterns Execution patterns Implementation strategy patterns Structural design patterns  Read more about design patterns here\u0026hellip;\n",
    "ref": "/blog/2013-08-31-software-design-pattern/"
  },{
    "title": "[SOLVED] Missing verify.dll",
    "date": "August 29, 2013",
    "description": "",
    "body": "Error: The program can\u0026rsquo;t start because verify.dll is missing from your computer. TryÂ reinstallingÂ the program to fix this problem.\nThis error also occurred when I tried to run a program using Java Virtual Machine Launcher.\nThe permanent solution to this error is adding the pathÂ JDK_HOME\\jre\\binÂ (e.g. C:\\Java\\jdk1.7.0\\jre\\bin; - in my case) to theÂ System Environment Variable -Â PATH\n",
    "ref": "/blog/2013-08-29-solved-missing-verify-dll/"
  },{
    "title": "[SOLVED] Could not open jvm.cfg",
    "date": "August 29, 2013",
    "description": "",
    "body": "Error: could not open \u0026lsquo;C:\\Java\\jre7\\lib\\i386\\jvm.cfg\u0026rsquo; This error occurred when I tried to run a program using Java Virtual Machine Launcher.\nSolution: As a temporary fix what I did was searching for the file jvm.cfg (which was found somewhere under JDK_HOME) and made the file available in the path mentioned in the error message.\nThe following is the content of the file jvm.cfg\n-client KNOWN -server KNOWN -hotspot ALIASED_TO -client -classic WARN -native ERROR -green ERROR  The permanent solution to this error is adding the path JDK_HOME\\jre\\bin (e.g. C:\\Java\\jdk1.7.0\\jre\\bin; - in my case) to the System Environment Variable - PATH\n",
    "ref": "/blog/2013-08-29-solved-could-not-open-jvm-cfg/"
  },{
    "title": "Java - Avoid multiple occurrence of some character in a String",
    "date": "August 29, 2013",
    "description": "",
    "body": "The following is a Java method/function which avoids multiple occurrence (in a row) of some character in an input String. The parameters to the method (i.e., inputs) to the method/function include:\n input - The parent String under consideration character - The character of which multiple occurrence (in a row) should be avoided.  public static String avoidMultipleOccurrence(String input, char character) { if (input == null) { return null; } if (input.length() == 0) { return \u0026#34;\u0026#34;; } StringBuilder output = new StringBuilder(); output.append(input.charAt(0)); for (int idx = 1; idx \u0026lt; input.length(); idx++) { if (Character.toString(input.charAt(idx)).equals( \u0026#34;\u0026#34; + character)) { if(input.charAt(idx) != input.charAt(idx-1)) { output.append(input.charAt(idx)); } } else { output.append(input.charAt(idx)); } } return output.toString(); } Sample Input: \u0026ldquo;theeee insaneeeee teeeeechieeeee\u0026rdquo;\nCharacter selected: \u0026lsquo;e\u0026rsquo;\npublic static void main(String[] args) { System.out.println(avoidMultipleOccurrence( \u0026#34;theeee insaneeeee teeeeechieeeee\u0026#34;, \u0026#39;e\u0026#39;)); } Output:Â the insane techie\n",
    "ref": "/blog/2013-08-29-java-avoid-multiple-occurrence-of-some-character-in-a-string/"
  },{
    "title": "Another Milestone",
    "date": "August 20, 2013",
    "description": "",
    "body": " Within the time period from Aug 19, 2013 12:30 AM IST to Aug 19, 2013 11:30 PM IST, the blog had 1K+ hits :) Out of which 900+ were from United States!!!\n \nFrom today, the 20th of August 2013, onwards the blog will be available under another domain - https://theinsanetechie.in\n",
    "ref": "/blog/2013-08-20-another-milestone/"
  },{
    "title": "Independence Day Wishes",
    "date": "August 15, 2013",
    "description": "",
    "body": "à´µà´¨àµà´¦àµ‡ à´®à´¾à´¤à´°à´‚!\nà´¸àµà´œà´²à´¾à´‚ à´¸àµà´«à´²à´¾à´‚, à´®à´²à´¯à´œ à´¶àµ€à´¤à´³à´¾à´‚,\nà´¸à´¸àµà´¯ à´¶àµà´¯à´¾à´®à´³à´¾à´‚, à´®à´¾à´¤à´°à´‚!\nà´¶àµà´­àµà´°à´œàµà´¯àµ‹à´¤àµà´¸àµà´¨ à´ªàµà´³à´•à´¿à´¤à´¯à´¾à´®à´¿à´£à´¿à´‚,\nà´«àµà´²àµà´²à´•àµà´¸àµà´®à´¿à´¤ à´¦àµà´°àµà´®à´¤à´² à´¶àµ‹à´­à´¿à´£à´¿à´‚,\nà´¸àµà´¹à´¾à´¸à´¿à´¨à´¿à´‚, à´¸àµà´®à´¦àµà´° à´­à´¾à´·à´¿à´£à´¿à´‚ ,\nà´¸àµà´–à´¦à´¾à´‚, à´µà´°à´¦à´¾à´‚ ,à´®à´¾à´¤à´°à´‚!\nà´¸à´ªàµà´¤à´•àµ‹à´Ÿà´¿à´•à´¾à´¨àµà´¤ à´•à´³ à´•à´³ à´¨à´¿à´¨à´¾à´¦ à´•à´°à´¾à´³àµ†\nà´¦àµà´µà´¿à´¸à´ªàµà´¤à´•àµ‹à´Ÿà´¿ à´­àµà´œàµˆà´°àµâ€ à´§àµƒà´¤-à´–à´¾à´° à´•à´°à´µà´²àµ†\nà´…à´¬à´² à´•àµ‡à´£ à´®à´¾ à´‡à´¤à´¾ à´¬à´²àµ†\nà´¬à´¹àµà´¬à´² à´§à´°à´¿à´£à´¿à´‚, à´¨à´®à´¾à´®à´¿ à´¤à´°à´¿à´£à´¿à´‚,\nà´°à´¿à´ªàµà´¤à´³à´µà´¾à´°à´¿à´£à´¿à´‚ à´®à´¾à´¤à´°à´‚ !\nà´¤àµà´®à´¿ à´µà´¿à´¦àµà´¯, à´¤àµà´®à´¿ à´§à´°àµâ€à´®àµà´®,\nà´¤àµà´®à´¿ à´¹àµƒà´¦à´¿ , à´¤àµà´®à´¿ à´®à´°àµâ€à´®àµà´® ,\nà´¤àµà´µà´‚ à´¹à´¿ à´ªàµà´°à´¾à´£ à´¶à´¾à´°à´¿à´°àµ†!\nà´¬à´¾à´¹àµà´¤àµ† à´¤àµà´®à´¿ à´®à´¾ à´¶à´•àµà´¤à´¿ ,\nà´¹àµƒà´¦à´¯àµ‡ à´¤àµà´®à´¿ à´®à´¾ à´­à´•àµà´¤à´¿,\nà´¤àµ‹à´®à´°àµà´¯ à´ªàµà´°à´¤à´¿à´® à´—à´¾à´°à´¿ à´®à´¨àµà´¦à´¿à´°àµ‡ à´®à´¨àµà´¦à´¿à´°àµ‡!\nà´¤àµà´µà´‚ à´¹à´¿ à´¦àµà´°àµâ€à´—àµà´— à´¦à´¶à´ªàµà´°à´¹à´°à´£ à´§à´°à´¿à´£à´¿,\nà´•à´®à´², à´•à´®à´²à´¾à´¦à´³à´µà´¿à´¹à´¾à´°à´¿à´£à´¿,\nà´µà´¾à´£à´¿, à´µà´¿à´¦àµà´¯à´¦à´¾à´¯à´¿à´¨à´¿ à´¨à´®à´¾à´®à´¿ à´¤àµà´µà´‚,\nà´¨à´®à´¾à´®à´¿ à´•à´®à´²à´‚, à´…à´®à´²à´‚, à´…à´¤àµà´²à´¾à´‚,\nà´¸àµà´œà´²à´¾à´‚, à´¸àµà´«à´²à´¾à´‚, à´®à´¾à´¤à´°à´‚,\nà´µà´¨àµà´¦àµ‡ à´®à´¾à´¤à´°à´‚!\nà´¶àµà´¯à´¾à´®à´³à´‚, à´¸à´°à´³à´‚, à´¸àµà´¸àµà´®à´¿à´¤à´‚, à´­àµ‚à´·à´¿à´¤à´‚,\nà´§à´°à´£à´¿à´‚, à´­à´°à´£à´¿à´‚, à´®à´¾à´¤à´°à´‚!\nà´œà´¯àµâ€Œ à´¹à´¿à´¨àµà´¦àµâ€Œ !\n\nMother, I bow to thee!\nRich with thy hurrying streams,\nbright with orchard gleams,\nCool with thy winds of delight,\nDark fields waving Mother of might,\nMother free.\nGlory of moonlight dreams,\nOver thy branches and lordly streams,\nClad in thy blossoming trees,\nMother, giver of ease\nLaughing low and sweet!\nMother I kiss thy feet,\nSpeaker sweet and low!\nMother, to thee I bow.\nWho hath said thou art weak in thy lands\nWhen the sword flesh out in the seventy million hands\nAnd seventy million voices roar\nThy dreadful name from shore to shore?\nWith many strengths who art mighty and stored,\nTo thee I call Mother and Lord!\nThough who savest, arise and save!\nTo her I cry who ever her foeman drove\nBack from plain and Sea\nAnd shook herself free.\nThou art wisdom, thou art law,\nThou art heart, our soul, our breath\nThough art love divine, the awe\nIn our hearts that conquers death.\nThine the strength that nerves the arm,\nThine the beauty, thine the charm.\nEvery image made divine\nIn our temples is but thine.\nThou art Durga, Lady and Queen,\nWith her hands that strike and her\nswords of sheen,\nThou art Lakshmi lotus-throned,\nAnd the Muse a hundred-toned,\nPure and perfect without peer,\nMother lend thine ear,\nRich with thy hurrying streams,\nBright with thy orchard gleems,\nDark of hue O candid-fair\nIn thy soul, with jewelled hair\nAnd thy glorious smile divine,\nLovilest of all earthly lands,\nShowering wealth from well-stored hands!\nMother, mother mine!\nMother sweet, I bow to thee,\nMother great and free!\nJai Hind!\n",
    "ref": "/blog/2013-08-15-independence-day-wishes/"
  },{
    "title": "Java - Encryption and Decryption of an Image Using Blowfish Algorithm",
    "date": "August 11, 2013",
    "description": "",
    "body": "EncryptFile.java\npackage com.java.blowfish; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.IllegalBlockSizeException; import javax.crypto.KeyGenerator; import javax.crypto.NoSuchPaddingException; import javax.crypto.SecretKey; /** * * @author dhanoopbhaskar */ public class EncryptFile { KeyGenerator keyGenerator = null; SecretKey secretKey = null; Cipher cipher = null; public EncryptFile() { try { /** * Create a Blowfish key */ keyGenerator = KeyGenerator.getInstance(\u0026#34;Blowfish\u0026#34;); secretKey = keyGenerator.generateKey(); /** * Create an instance of cipher mentioning the name of algorithm * - Blowfish */ cipher = Cipher.getInstance(\u0026#34;Blowfish\u0026#34;); } catch (NoSuchPaddingException ex) { System.out.println(ex); } catch (NoSuchAlgorithmException ex) { System.out.println(ex); } } public static void main(String[] args) { String fileToEncrypt = \u0026#34;fileToEncrypt.jpg\u0026#34;; String encryptedFile = \u0026#34;encryptedFile.jpg\u0026#34;; String decryptedFile = \u0026#34;decryptedFile.jpg\u0026#34;; String directoryPath = \u0026#34;C:/Users/dhanoopbhaskar/Desktop/blowfish/\u0026#34;; EncryptFile encryptFile = new EncryptFile(); System.out.println(\u0026#34;Starting Encryption...\u0026#34;); encryptFile.encrypt(directoryPath + fileToEncrypt, directoryPath + encryptedFile); System.out.println(\u0026#34;Encryption completed...\u0026#34;); System.out.println(\u0026#34;Starting Decryption...\u0026#34;); encryptFile.decrypt(directoryPath + encryptedFile, directoryPath + decryptedFile); System.out.println(\u0026#34;Decryption completed...\u0026#34;); } /** * * @param srcPath * @param destPath * * Encrypts the file in srcPath and creates a file in destPath */ private void encrypt(String srcPath, String destPath) { File rawFile = new File(srcPath); File encryptedFile = new File(destPath); InputStream inStream = null; OutputStream outStream = null; try { /** * Initialize the cipher for encryption */ cipher.init(Cipher.ENCRYPT_MODE, secretKey); /** * Initialize input and output streams */ inStream = new FileInputStream(rawFile); outStream = new FileOutputStream(encryptedFile); byte[] buffer = new byte[1024]; int len; while ((len = inStream.read(buffer)) \u0026gt; 0) { outStream.write(cipher.update(buffer, 0, len)); outStream.flush(); } outStream.write(cipher.doFinal()); inStream.close(); outStream.close(); } catch (IllegalBlockSizeException ex) { System.out.println(ex); } catch (BadPaddingException ex) { System.out.println(ex); } catch (InvalidKeyException ex) { System.out.println(ex); } catch (FileNotFoundException ex) { System.out.println(ex); } catch (IOException ex) { System.out.println(ex); } } /** * * @param srcPath * @param destPath * * Decrypts the file in srcPath and creates a file in destPath */ private void decrypt(String srcPath, String destPath) { File encryptedFile = new File(srcPath); File decryptedFile = new File(destPath); InputStream inStream = null; OutputStream outStream = null; try { /** * Initialize the cipher for decryption */ cipher.init(Cipher.DECRYPT_MODE, secretKey); /** * Initialize input and output streams */ inStream = new FileInputStream(encryptedFile); outStream = new FileOutputStream(decryptedFile); byte[] buffer = new byte[1024]; int len; while ((len = inStream.read(buffer)) \u0026gt; 0) { outStream.write(cipher.update(buffer, 0, len)); outStream.flush(); } outStream.write(cipher.doFinal()); inStream.close(); outStream.close(); } catch (IllegalBlockSizeException ex) { System.out.println(ex); } catch (BadPaddingException ex) { System.out.println(ex); } catch (InvalidKeyException ex) { System.out.println(ex); } catch (FileNotFoundException ex) { System.out.println(ex); } catch (IOException ex) { System.out.println(ex); } } } Output:\nStarting Encryptionâ€¦ Encryption completedâ€¦ Starting Decryptionâ€¦ Decryption completedâ€¦  Before Encryption\n\nAfter Encryption\n\nThe method doFinal() should not be used in loop or repeatedly. If we have to encrypt/decrypt multiple blocks we use update() method.\noutStream.write(cipher.update(buffer, 0, len));  After everything is done we call doFinal() method.\noutStream.write(cipher.doFinal());  If we use doFinal repeatedly, the encryption will work without errors. But decryption will fail throwing exception - javax.crypto.BadPaddingException\nSee related posts:\n  Java - Encryption and Decryption of an Image Using Blowfish Algorithm (using password)\n  Java - Encryption and Decryption of an Image Using Another Image (Blowfish Algorithm)\n  ",
    "ref": "/blog/2013-08-11-java-encryption-and-decryption-of-an-image-using-blowfish-algorithm/"
  },{
    "title": "Java - Blowfish Encryption Algorithm",
    "date": "August 11, 2013",
    "description": "",
    "body": "BlowfishAlgorithm.java\npackage com.java.blowfish; import com.sun.org.apache.xml.internal.security.exceptions.Base64DecodingException; import com.sun.org.apache.xml.internal.security.utils.Base64; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.IllegalBlockSizeException; import javax.crypto.KeyGenerator; import javax.crypto.NoSuchPaddingException; import javax.crypto.SecretKey; /** * * @author dhanoopbhaskar */ public class BlowfishAlgorithm { KeyGenerator keyGenerator = null; SecretKey secretKey = null; Cipher cipher = null; public BlowfishAlgorithm() { try { /** * Create a Blowfish key */ keyGenerator = KeyGenerator.getInstance(\u0026#34;Blowfish\u0026#34;); secretKey = keyGenerator.generateKey(); /** * Create an instance of cipher mentioning the name of algorithm * - Blowfish */ cipher = Cipher.getInstance(\u0026#34;Blowfish\u0026#34;); } catch (NoSuchPaddingException ex) { System.out.println(ex); } catch (NoSuchAlgorithmException ex) { System.out.println(ex); } } /** * * @param plainText * @return cipherBytes */ public byte[] encryptText(String plainText) { byte[] cipherBytes = null; try { /** * Initialize the cipher for encryption */ cipher.init(Cipher.ENCRYPT_MODE, secretKey); /** * Convert the text string to byte format */ byte[] plainBytes = plainText.getBytes(); /** * Perform encryption with method doFinal() */ cipherBytes = cipher.doFinal(plainBytes); } catch (IllegalBlockSizeException ex) { System.out.println(ex); } catch (BadPaddingException ex) { System.out.println(ex); } catch (InvalidKeyException ex) { System.out.println(ex); } return cipherBytes; } /** * * @param cipherBytes * @return plainText */ public String decryptText(byte[] cipherBytes) { String plainText = null; try { /** * Initialize the cipher for decryption */ cipher.init(Cipher.DECRYPT_MODE, secretKey); /** * Perform decryption with method doFinal() */ byte[] plainBytes = cipher.doFinal(cipherBytes); /** * Convert encrypted text to string format */ plainText = new String(plainBytes); } catch (IllegalBlockSizeException ex) { System.out.println(ex); } catch (BadPaddingException ex) { System.out.println(ex); } catch (InvalidKeyException ex) { System.out.println(ex); } return plainText; } /** * * @param plainText * @return cipherText */ public String encrypt(String plainText) { String cipherText = null; byte[] cipherBytes = encryptText(plainText); cipherText = bytesToString(cipherBytes); return cipherText; } /** * * @param cipherText * @return plainText */ public String decrypt(String cipherText) { String plainText = null; byte[] cipherBytes = stringToBytes(cipherText); plainText = decryptText(cipherBytes); return plainText; } public static void main(String[] args) { BlowfishAlgorithm blowfishAlgorithm = new BlowfishAlgorithm(); String textToEncrypt = \u0026#34;Blowfish Algorithm\u0026#34;; System.out.println(\u0026#34;Text before Encryption: \u0026#34; + textToEncrypt); String cipherText = blowfishAlgorithm.encrypt(textToEncrypt); System.out.println(\u0026#34;Cipher Text: \u0026#34; + cipherText); System.out.println(\u0026#34;Text after Decryption: \u0026#34; + blowfishAlgorithm.decrypt(cipherText)); } /** * * @param rawText * @return plainText * * Perform Base64 encoding */ private String bytesToString(byte[] rawText) { String plainText = null; plainText = Base64.encode(rawText); return plainText; } /** * * @param plainText * @return rawText * * Perform Base64 decoding */ private byte[] stringToBytes(String plainText) { byte[] rawText = null; try { rawText = Base64.decode(plainText); } catch (Base64DecodingException ex) { System.out.println(ex); } return rawText; } } Output:\nText before Encryption: Blowfish Algorithm Cipher Text: tsNKEZdUIivNDDN287v9NIl8vCHTPrlT Text after Decryption: Blowfish Algorithm  ",
    "ref": "/blog/2013-08-11-java-blowfish-encryption-algorithm/"
  },{
    "title": "Java - Advanced Encryption Standard (AES) Algorithm",
    "date": "August 11, 2013",
    "description": "",
    "body": "AESAlgorithm.java\npackage com.java.aes; import com.sun.org.apache.xml.internal.security.exceptions.Base64DecodingException; import com.sun.org.apache.xml.internal.security.utils.Base64; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.IllegalBlockSizeException; import javax.crypto.KeyGenerator; import javax.crypto.NoSuchPaddingException; import javax.crypto.SecretKey; /** * * @author dhanoopbhaskar */ public class AESAlgorithm { KeyGenerator keyGenerator = null; SecretKey secretKey = null; Cipher cipher = null; public AESAlgorithm() { try { /** * Create a AES key */ keyGenerator = KeyGenerator.getInstance(\u0026#34;AES\u0026#34;); secretKey = keyGenerator.generateKey(); /** * Create an instance of cipher providing the following info * separated by slash. * * - Algorithm name * - Mode (optional) * - Padding scheme (optional) * * NB: * AES = Advanced Encryption Standard. * ECB = Electronic Codebook mode. * PKCS5Padding = PKCS #5-style padding. */ cipher = Cipher.getInstance(\u0026#34;AES/ECB/PKCS5Padding\u0026#34;); } catch (NoSuchPaddingException ex) { System.out.println(ex); } catch (NoSuchAlgorithmException ex) { System.out.println(ex); } } /** * * @param plainText * @return cipherBytes */ public byte[] encryptText(String plainText) { byte[] cipherBytes = null; try { /** * Initialize the cipher for encryption */ cipher.init(Cipher.ENCRYPT_MODE, secretKey); /** * Convert the text string to byte format */ byte[] plainBytes = plainText.getBytes(); /** * Perform encryption with method doFinal() */ cipherBytes = cipher.doFinal(plainBytes); } catch (IllegalBlockSizeException ex) { System.out.println(ex); } catch (BadPaddingException ex) { System.out.println(ex); } catch (InvalidKeyException ex) { System.out.println(ex); } return cipherBytes; } /** * * @param cipherBytes * @return plainText */ public String decryptText(byte[] cipherBytes) { String plainText = null; try { /** * Initialize the cipher for decryption */ cipher.init(Cipher.DECRYPT_MODE, secretKey); /** * Perform decryption with method doFinal() */ byte[] plainBytes = cipher.doFinal(cipherBytes); /** * Convert encrypted text to string format */ plainText = new String(plainBytes); } catch (IllegalBlockSizeException ex) { System.out.println(ex); } catch (BadPaddingException ex) { System.out.println(ex); } catch (InvalidKeyException ex) { System.out.println(ex); } return plainText; } /** * * @param plainText * @return cipherText */ public String encrypt(String plainText) { String cipherText = null; byte[] cipherBytes = encryptText(plainText); cipherText = bytesToString(cipherBytes); return cipherText; } /** * * @param cipherText * @return plainText */ public String decrypt(String cipherText) { String plainText = null; byte[] cipherBytes = stringToBytes(cipherText); plainText = decryptText(cipherBytes); return plainText; } public static void main(String[] args) { AESAlgorithm desAlgorithm = new AESAlgorithm(); String textToEncrypt = \u0026#34;AES Algorithm\u0026#34;; System.out.println(\u0026#34;Text before Encryption: \u0026#34; + textToEncrypt); String cipherText = desAlgorithm.encrypt(textToEncrypt); System.out.println(\u0026#34;Cipher Text: \u0026#34; + cipherText); System.out.println(\u0026#34;Text after Decryption: \u0026#34; + desAlgorithm.decrypt(cipherText)); } /** * * @param rawText * @return plainText * * Perform Base64 encoding */ private String bytesToString(byte[] rawText) { String plainText = null; plainText = Base64.encode(rawText); return plainText; } /** * * @param plainText * @return rawText * * Perform Base64 decoding */ private byte[] stringToBytes(String plainText) { byte[] rawText = null; try { rawText = Base64.decode(plainText); } catch (Base64DecodingException ex) { System.out.println(ex); } return rawText; } } Output:Â Text before Encryption: AES AlgorithmÂ Cipher Text: rqDMYCW17enP8S7sio3Kbg==Â Text after Decryption: AES Algorithm  ",
    "ref": "/blog/2013-08-11-java-advanced-encryption-standard-aes-algorithm/"
  },{
    "title": "Java - JButton in a JTable cell",
    "date": "August 3, 2013",
    "description": "",
    "body": "Now we shall discuss how to include a JButton in a table cell.\nButtonJTable.java\n/* * ButtonJTable.java * * Created on Aug 3, 2013, 02:57:58 PM */ package me.dhanoop.forblog; import java.awt.Component; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import javax.swing.JButton; import javax.swing.JCheckBox; import javax.swing.JFrame; import javax.swing.JOptionPane; import javax.swing.JTable; import javax.swing.UIManager; import javax.swing.table.DefaultTableModel; import javax.swing.table.TableCellRenderer; /** * * @author dhanoopbhaskar */ public class ButtonJTable extends javax.swing.JFrame { private JButton tableData = null; /** Creates new form ButtonJTable */ public ButtonJTable() { initComponents(); customizeTable(); } /** This method is called from within the constructor to * initialize the form. * WARNING: Do NOT modify this code. The content of this method is * always regenerated by the Form Editor. */ @SuppressWarnings(\u0026#34;unchecked\u0026#34;) //  private void initComponents() { dbScrollPane = new javax.swing.JScrollPane(); dbTable = new javax.swing.JTable(); setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE); dbTable.setModel(new javax.swing.table.DefaultTableModel( new Object [][] { }, new String [] { \u0026#34;Title 1\u0026#34; } )); dbScrollPane.setViewportView(dbTable); javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane()); getContentPane().setLayout(layout); layout.setHorizontalGroup( layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING) .addComponent(dbScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 226, javax.swing.GroupLayout.PREFERRED_SIZE) ); layout.setVerticalGroup( layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING) .addComponent(dbScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 81, javax.swing.GroupLayout.PREFERRED_SIZE) ); pack(); }//  /** * @param args the command line arguments */ public static void main(String args[]) { java.awt.EventQueue.invokeLater(new Runnable() { public void run() { new ButtonJTable().setVisible(true); } }); } // Variables declaration - do not modify  private javax.swing.JScrollPane dbScrollPane; private javax.swing.JTable dbTable; // End of variables declaration  private void customizeTable() { Object[] columnNames = new Object[1]; columnNames[0] = \u0026#34;Button\u0026#34;; String buttonString = \u0026#34;Click Me\u0026#34;; Object[][] rowData = new Object[1][1]; rowData[0][0] = buttonString; DefaultTableModel tableModel = new DBTableModel(rowData, columnNames); dbTable.setModel(tableModel); tableData = new JButton(buttonString); tableData.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { JOptionPane.showMessageDialog(new JFrame(), \u0026#34;I\u0026#39;m clicked!\u0026#34;, \u0026#34;ButtonJTable\u0026#34;, JOptionPane.INFORMATION_MESSAGE); } }); dbTable.getColumnModel().getColumn(0).setCellEditor(new ButtonCellEditor(new JCheckBox())); dbTable.getColumnModel().getColumn(0).setCellRenderer(new TableCellRenderer() { public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) { if (isSelected) { setForeground(table.getSelectionForeground()); setBackground(table.getSelectionBackground()); } else { setForeground(table.getForeground()); setBackground(UIManager.getColor(\u0026#34;Button.background\u0026#34;)); } tableData.setText((value == null) ? \u0026#34;\u0026#34; : value.toString()); return tableData; } }); dbTable.updateUI(); } } DBTableModel.java\npackage me.dhanoop.forblog; import javax.swing.table.DefaultTableModel; /** * * @author dhanoopbhaskar */ public class DBTableModel extends DefaultTableModel { public DBTableModel(Object[] columns) { super(columns, 0); } public DBTableModel(Object[][] data, Object[] columns) { super(data, columns); } @Override public boolean isCellEditable(int row, int column) { return true; } } The following is the key snippet in the program.\nHere we do mainly two things:\n  Changing the CellEditor of the ColumnModel of the column at position 0 (zero) of the table.\n  Changing the CellRenderer of the ColumnModel of the column at position 0 (zero) of the table.Â   Unlike JComboBox and JCheckBox, for JButton we don\u0026rsquo;t have a suitable constructor.Â public javax.swing.DefaultCellEditor(javax.swing.JTextField);Â public javax.swing.DefaultCellEditor(javax.swing.JCheckBox); public javax.swing.DefaultCellEditor(javax.swing.JComboBox); The above are the ONLY available constructors for DefaultCellEditor. Hence we have to create fully customized DefaultCellEditor for JButton.\nprivate void customizeTable() { Object[] columnNames = new Object[1]; columnNames[0] = \u0026#34;Button\u0026#34;; String buttonString = \u0026#34;Click Me\u0026#34;; Object[][] rowData = new Object[1][1]; rowData[0][0] = buttonString; DefaultTableModel tableModel = new DBTableModel(rowData, columnNames); dbTable.setModel(tableModel); tableData = new JButton(buttonString); tableData.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { JOptionPane.showMessageDialog(new JFrame(), \u0026#34;I\u0026#39;m clicked!\u0026#34;, \u0026#34;ButtonJTable\u0026#34;, JOptionPane.INFORMATION_MESSAGE); } }); dbTable.getColumnModel().getColumn(0).setCellEditor(new ButtonCellEditor(new JCheckBox())); dbTable.getColumnModel().getColumn(0).setCellRenderer(new TableCellRenderer() { public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) { if (isSelected) { setForeground(table.getSelectionForeground()); setBackground(table.getSelectionBackground()); } else { setForeground(table.getForeground()); setBackground(UIManager.getColor(\u0026#34;Button.background\u0026#34;)); } tableData.setText((value == null) ? \u0026#34;\u0026#34; : value.toString()); return tableData; } }); dbTable.updateUI(); } Please find below an example of such a customized DefaultCellEditor\nButtonCellEditor.java\npackage me.dhanoop.forblog; import java.awt.Component; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import javax.swing.DefaultCellEditor; import javax.swing.JButton; import javax.swing.JCheckBox; import javax.swing.JOptionPane; import javax.swing.JTable; /** * * @author dhanoopbhaskar */ public class ButtonCellEditor extends DefaultCellEditor { private JButton button = null; private String buttonText = null; private boolean isClicked; public ButtonCellEditor(JCheckBox checkBox) { super(checkBox); button = new JButton(); button.setOpaque(true); button.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { fireEditingStopped(); } }); } @Override public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column) { if (isSelected) { button.setForeground(table.getSelectionForeground()); button.setBackground(table.getSelectionBackground()); } else { button.setForeground(table.getForeground()); button.setBackground(table.getBackground()); } buttonText = (value == null) ? \u0026#34;\u0026#34; : value.toString(); button.setText(buttonText); isClicked = true; return button; } @Override public Object getCellEditorValue() { if (isClicked) { JOptionPane.showMessageDialog(button, \u0026#34;I\u0026#39;m clicked!\u0026#34;, \u0026#34;ButtonJTable\u0026#34;, JOptionPane.INFORMATION_MESSAGE); } isClicked = false; return buttonText; } @Override public boolean stopCellEditing() { isClicked = false; return super.stopCellEditing(); } @Override protected void fireEditingStopped() { super.fireEditingStopped(); } } \n\n",
    "ref": "/blog/2013-08-03-java-jbutton-in-a-jtable-cell/"
  },{
    "title": "Java - JCheckBox in a JTable cell",
    "date": "August 3, 2013",
    "description": "",
    "body": "Now we shall discuss how to include a JCheckBox in a table cell.\nCheckBoxJFrame.java\n/** * CheckBoxJFrame.java * * Created on Aug 2, 2013, 11:57:36 PM */ package me.dhanoop.forblog; import java.awt.Component; import java.awt.event.ItemEvent; import java.awt.event.ItemListener; import javax.swing.DefaultCellEditor; import javax.swing.JCheckBox; import javax.swing.JFrame; import javax.swing.JOptionPane; import javax.swing.JTable; import javax.swing.table.DefaultTableModel; import javax.swing.table.TableCellRenderer; /** * * @author dhanoopbhaskar */ public class CheckBoxJFrame extends javax.swing.JFrame { private JCheckBox tableData = null; /** Creates new form CheckBoxJFrame */ public CheckBoxJFrame() { initComponents(); customizeTable(); } /** This method is called from within the constructor to * initialize the form. * WARNING: Do NOT modify this code. The content of this method is * always regenerated by the Form Editor. */ @SuppressWarnings(\u0026#34;unchecked\u0026#34;) //  private void initComponents() { dbScrollPane = new javax.swing.JScrollPane(); dbTable = new javax.swing.JTable(); setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE); dbTable.setModel(new javax.swing.table.DefaultTableModel( new Object [][] { }, new String [] { \u0026#34;Title 1\u0026#34; } )); dbScrollPane.setViewportView(dbTable); javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane()); getContentPane().setLayout(layout); layout.setHorizontalGroup( layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING) .addComponent(dbScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 226, javax.swing.GroupLayout.PREFERRED_SIZE) ); layout.setVerticalGroup( layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING) .addComponent(dbScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 81, javax.swing.GroupLayout.PREFERRED_SIZE) ); pack(); }//  /** * @param args the command line arguments */ public static void main(String args[]) { java.awt.EventQueue.invokeLater(new Runnable() { public void run() { new CheckBoxJFrame().setVisible(true); } }); } // Variables declaration - do not modify  private javax.swing.JScrollPane dbScrollPane; private javax.swing.JTable dbTable; // End of variables declaration  private void customizeTable() { Object[] columnNames = new Object[1]; columnNames[0] = \u0026#34;CheckBox\u0026#34;; String checkString = \u0026#34;Gate Qualified?\u0026#34;; Object[][] rowData = new Object[1][1]; rowData[0][0] = checkString; DefaultTableModel tableModel = new DBTableModel(rowData, columnNames); dbTable.setModel(tableModel); tableData = new JCheckBox(checkString); tableData.setSelected(false); tableData.addItemListener(new ItemListener() { public void itemStateChanged(ItemEvent e) { String result = \u0026#34;\u0026#34;; if (tableData.isSelected()) { result = \u0026#34;YES\u0026#34;; } else { result = \u0026#34;NO\u0026#34;; } JOptionPane.showMessageDialog(new JFrame(), result, \u0026#34;Gate Qualified?\u0026#34;, JOptionPane.INFORMATION_MESSAGE); } }); dbTable.getColumnModel().getColumn(0).setCellEditor(new DefaultCellEditor(tableData)); dbTable.getColumnModel().getColumn(0).setCellRenderer(new TableCellRenderer() { public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) { return tableData; } }); dbTable.updateUI(); } } DBTableModel.java\npackage me.dhanoop.forblog; import javax.swing.table.DefaultTableModel; /** * * @author dhanoopbhaskar */ public class DBTableModel extends DefaultTableModel { public DBTableModel(Object[] columns) { super(columns, 0); } public DBTableModel(Object[][] data, Object[] columns) { super(data, columns); } @Override public boolean isCellEditable(int row, int column) { return true; } } The following is the key snippet in the program. Here we do mainly two things:\n  Changing the CellEditor of the ColumnModel of the column at position 0 (zero) of the table\n  Changing the CellRenderer of the ColumnModel of the column at position 0 (zero) of the table.\n  private void customizeTable() { Object[] columnNames = new Object[1]; columnNames[0] = \u0026#34;CheckBox\u0026#34;; String checkString = \u0026#34;Gate Qualified?\u0026#34;; Object[][] rowData = new Object[1][1]; rowData[0][0] = checkString; DefaultTableModel tableModel = new DBTableModel(rowData, columnNames); dbTable.setModel(tableModel); tableData = new JCheckBox(checkString); tableData.setSelected(false); tableData.addItemListener(new ItemListener() { public void itemStateChanged(ItemEvent e) { String result = \u0026#34;\u0026#34;; if (tableData.isSelected()) { result = \u0026#34;YES\u0026#34;; } else { result = \u0026#34;NO\u0026#34;; } JOptionPane.showMessageDialog(new JFrame(), result, \u0026#34;Gate Qualified?\u0026#34;, JOptionPane.INFORMATION_MESSAGE); } }); dbTable.getColumnModel().getColumn(0).setCellEditor(new DefaultCellEditor(tableData)); dbTable.getColumnModel().getColumn(0).setCellRenderer(new TableCellRenderer() { public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) { return tableData; } }); dbTable.updateUI(); }  \n\n\n",
    "ref": "/blog/2013-08-03-java-jcheckbox-in-a-jtable-cell/"
  },{
    "title": "Java - JComboBox in a JTable cell (with event handling)",
    "date": "August 3, 2013",
    "description": "",
    "body": "Please refer to the previous post here\u0026hellip;\nThe function customizeTable() has been modified in order to include event handling functionality in the combo box.\nprivate void customizeTable() { Object[] columnNames = new Object[1]; columnNames[0] = \u0026#34;ComboBox\u0026#34;; Object[][] rowData = new Object[1][1]; rowData[0][0] = \u0026#34;select gender\u0026#34;; DefaultTableModel tableModel = new DBTableModel(rowData, columnNames); dbTable.setModel(tableModel); String[] gender = {\u0026#34;Male\u0026#34;, \u0026#34;Female\u0026#34;}; tableData = new JComboBox(gender); tableData.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { String item = (String) tableData.getSelectedItem(); JOptionPane.showMessageDialog(new JFrame(), item, \u0026#34;Selected Item\u0026#34;, JOptionPane.INFORMATION_MESSAGE); } }); dbTable.getColumnModel().getColumn(0).setCellEditor(new DefaultCellEditor(tableData)); dbTable.updateUI(); }  For the JComboBox tableData to be accessible in the inner class\u0026rsquo; method actionPerformed(), it should be declared in class level as below. (In the previous post, it\u0026rsquo;s declared locally).\npublic class MainJFrame extends javax.swing.JFrame { private JComboBox tableData = null; . . .  \n\n",
    "ref": "/blog/2013-08-03-java-jcombobox-in-a-jtable-cell-with-event-handling/"
  },{
    "title": "Java - JComboBox in a JTable cell",
    "date": "August 3, 2013",
    "description": "",
    "body": "MainJFrame.java\n/** * MainJFrame.java * * Created on Aug 2, 2013, 11:57:36 PM */ package me.dhanoop.forblog; import javax.swing.DefaultCellEditor; import javax.swing.JComboBox; import javax.swing.table.DefaultTableModel; import javax.swing.table.TableCellEditor; /** * * @author dhanoopbhaskar */ public class MainJFrame extends javax.swing.JFrame { /** Creates new form MainJFrame */ public MainJFrame() { initComponents(); customizeTable(); } /** This method is called from within the constructor to * initialize the form. * WARNING: Do NOT modify this code. The content of this method is * always regenerated by the Form Editor. */ @SuppressWarnings(\u0026#34;unchecked\u0026#34;) //  private void initComponents() { dbScrollPane = new javax.swing.JScrollPane(); dbTable = new javax.swing.JTable(); setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE); dbTable.setModel(new javax.swing.table.DefaultTableModel( new Object [][] { }, new String [] { \u0026#34;Title 1\u0026#34; } )); dbScrollPane.setViewportView(dbTable); javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane()); getContentPane().setLayout(layout); layout.setHorizontalGroup( layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING) .addComponent(dbScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 169, javax.swing.GroupLayout.PREFERRED_SIZE) ); layout.setVerticalGroup( layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING) .addComponent(dbScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 81, javax.swing.GroupLayout.PREFERRED_SIZE) ); pack(); }//  /** * @param args the command line arguments */ public static void main(String args[]) { java.awt.EventQueue.invokeLater(new Runnable() { public void run() { new MainJFrame().setVisible(true); } }); } // Variables declaration - do not modify  private javax.swing.JScrollPane dbScrollPane; private javax.swing.JTable dbTable; // End of variables declaration  private void customizeTable() { Object[] columnNames = new Object[1]; columnNames[0] = \u0026#34;ComboBox\u0026#34;; Object[][] rowData = new Object[1][1]; rowData[0][0] = \u0026#34;select gender\u0026#34;; DefaultTableModel tableModel = new DBTableModel(rowData, columnNames); dbTable.setModel(tableModel); String[] gender = {\u0026#34;Male\u0026#34;, \u0026#34;Female\u0026#34;}; JComboBox tableData = new JComboBox(gender); dbTable.getColumnModel().getColumn(0).setCellEditor(new DefaultCellEditor(tableData)); dbTable.updateUI(); } } DBTableModel.java\npackage me.dhanoop.forblog; import javax.swing.table.DefaultTableModel; /** * * @author dhanoopbhaskar */ public class DBTableModel extends DefaultTableModel { public DBTableModel(Object[] columns) { super(columns, 0); } public DBTableModel(Object[][] data, Object[] columns) { super(data, columns); } @Override public boolean isCellEditable(int row, int column) { return true; } } The following is the key snippet in the program. What we do here is simply changing the CellEditor of the ColumnModel of the column at position 0 (zero) of the table.\nprivate void customizeTable() { Object[] columnNames = new Object[1]; columnNames[0] = \u0026#34;ComboBox\u0026#34;; Object[][] rowData = new Object[1][1]; rowData[0][0] = \u0026#34;select gender\u0026#34;; DefaultTableModel tableModel = new DBTableModel(rowData, columnNames); dbTable.setModel(tableModel); String[] gender = {\u0026#34;Male\u0026#34;, \u0026#34;Female\u0026#34;}; JComboBox tableData = new JComboBox(gender); dbTable.getColumnModel().getColumn(0).setCellEditor(new DefaultCellEditor(tableData)); dbTable.updateUI(); } Here we use the following constructor of the class DefaultCellEditor.\npublic javax.swing.DefaultCellEditor(javax.swing.JComboBox); \n\nIn the next post we shall discuss on handling of various events in such combo boxes which are added to the table.\n",
    "ref": "/blog/2013-08-03-java-jcombobox-in-a-jtable-cell/"
  },{
    "title": "Talend - Out of Memory Error and Java Heap Space Error",
    "date": "July 21, 2013",
    "description": "",
    "body": "The Out of Memory Error and Java Heap Space Error are two of the common errors which occur in the Talend jobs handling a large volume of data. These errors can be avoided to an extent by following some design guidelines.\n Keep in mind that tMap is a heavy component. Minimize its use in your jobs.   Avoid tMap if you need just simple transformations like trimming the string values, replacing null numbers by zeroes, etc. In its place you can use tJavaRow component.   If you want to get only a small set of columns from a huge collection avoid using a tMap. For that you can use a lighter component- tFilterColumns  \n Similarly, to filter rows you can use tFilterRow instead of a tMap  Use store on disk option whenever necessary.  This option is available in tMap, tUniqRow, tSortRow, etc.\n tMap  While using store on disk option in tMap the directory to store temporary data will be created automatically. This data will not be deleted or replaced on subsequent run(s) of the job. So it is advised to delete the temporary directory created using tFileDelete component from within the job. You can give that in On Subjob Ok of tPostJob component.\n\n tUniqRow  In the case of tUniqRow the temporary directory should be created manually before the job run/or can be handled within the job. If the temporary directory is not available, the component tUniqRow will give out FileNotFoundException!\n tSortRow  In the case of tSortRow the temporary directory will be created automatically (see the image below- a check box can be seen)\n\nThe JVM arguments can be modified as and when needed.  -Xms256M - initial memory size available to JVM is 256 MB\n-Xmx1024M - maximum memory size available to JVM is 1024 MB\n\n",
    "ref": "/blog/2013-07-21-talend-out-of-memory-error-and-java-heap-space-error/"
  },{
    "title": "Google's Project Loon: Balloon-powered Internet access",
    "date": "June 16, 2013",
    "description": "",
    "body": "The Google is introducing its new project named Project LoonÂ to overcome the terrestrial challenges to Internet connectivity such as jungles, archipelagos, mountains, etc.\nIt is nothing but balloon-powered Internet access. A ring of balloons, flying around the globe on the stratospheric winds, provides Internet access to the earth below. These balloons are carried by the wind at altitudes twice as high as commercial planes and they beam Internet access to the ground at speeds similar to todayâ€™s 3G networks or faster. The team hopes that the balloons could become an option for connecting rural, remote, and under-served areas, and for helping with communications after natural disasters.\nThe major challenges include-\n  Trying to keep the balloons in one place requires a system with major cost and complexity.\nThe idea they pursued was based on freeing the balloons and letting them sail freely on the winds. To control their path through the sky they use just wind and solar power- moving the balloons up or down to catch the winds they want them to travel in.\n  How to manage a fleet of balloons sailing around the world so that each balloon is in the area we want it right when we need it.\nThis is solved with some complex algorithms and lots of computing power.\n  \n \u0026ldquo;We imagine someday you\u0026rsquo;ll be able to use your cell phone with your existing service provider to connect to the balloons and get connectivity where there is none today. This is still highly experimental technology and we have a long way to go â€” weâ€™d love your support as we keep trying and keep flying!\u0026rdquo;\n Courtesy: Google Blog\n",
    "ref": "/blog/2013-06-16-googles-project-loon-balloon-powered-internet-access/"
  },{
    "title": "Talend Equivalent for Index Function in Datastage",
    "date": "June 16, 2013",
    "description": "",
    "body": "package routines; public class UserString { public static int Index(String string, String substring, Integer instance) { int index = -1; if (string == null) { return 0; } if (substring == null) { return 0; } if (substring.equals(\u0026#34;\u0026#34;)) { return 1; } if (instance == null) { throw new UnsupportedOperationException(\u0026#34;Instance is supposed to be NOT NULL!!\u0026#34;); } if (!string.contains(substring)) { return 0; } index = string.indexOf(substring, 0); while (--instance \u0026gt; 0 \u0026amp;\u0026amp; index != -1) { index = string.indexOf(substring, index + 1); } return ++index; } } ",
    "ref": "/blog/2013-06-16-talend-equivalent-for-index-function-in-datastage/"
  },{
    "title": "Talend Equivalent for TRIM Function in Datastage",
    "date": "June 16, 2013",
    "description": "",
    "body": "package routines; public class UserString { /** * * L Removes leading occurrences of character. * T Removes trailing occurrences of character. * B Removes leading and trailing occurrences of character. * R Removes leading and trailing occurrences of character, and reduces multiple occurrences to a single occurrence. * A Removes all occurrences of character. * F Removes leading spaces and tabs * E Removes trailing spaces and tabs * D Removes leading and trailing spaces and tabs, and reduces multiple spaces and tabs to single ones. */ public static String TRIM(String str, String character, String option) { String returnStr = \u0026#34;\u0026#34;; if (str == null) { return null; } if (option.equals(\u0026#34;L\u0026#34;)) { returnStr = str.replaceFirst(\u0026#34;^\u0026#34; + character + \u0026#34;+\u0026#34;, \u0026#34;\u0026#34;); } else if (option.equals(\u0026#34;T\u0026#34;)) { returnStr = str.replaceAll(\u0026#34;[\u0026#34; + character + \u0026#34;]+$\u0026#34;, \u0026#34;\u0026#34;); } else if (option.equals(\u0026#34;B\u0026#34;)) { returnStr = str.replaceFirst(\u0026#34;^\u0026#34; + character + \u0026#34;+\u0026#34;, \u0026#34;\u0026#34;); returnStr = returnStr.replaceAll(\u0026#34;[\u0026#34; + character + \u0026#34;]+$\u0026#34;, \u0026#34;\u0026#34;); } else if (option.equals(\u0026#34;R\u0026#34;)) { returnStr = str.replaceFirst(\u0026#34;^\u0026#34; + character + \u0026#34;+\u0026#34;, \u0026#34;\u0026#34;); returnStr = returnStr.replaceAll(\u0026#34;[\u0026#34; + character + \u0026#34;]+$\u0026#34;, \u0026#34;\u0026#34;); returnStr = avoidMultipleOccurrence(returnStr, character); } else if (option.equals(\u0026#34;A\u0026#34;)) { returnStr = str.replaceAll(character, \u0026#34;\u0026#34;); } else if (option.equals(\u0026#34;F\u0026#34;)) { returnStr = TRIM(str, \u0026#34; \u0026#34;, \u0026#34;L\u0026#34;); returnStr = TRIM(returnStr, \u0026#34;\\t\u0026#34;, \u0026#34;L\u0026#34;); } else if (option.equals(\u0026#34;E\u0026#34;)) { returnStr = TRIM(str, \u0026#34; \u0026#34;, \u0026#34;T\u0026#34;); returnStr = TRIM(returnStr, \u0026#34;\\t\u0026#34;, \u0026#34;T\u0026#34;); } else if (option.equals(\u0026#34;D\u0026#34;)) { returnStr = TRIM(str, \u0026#34;\u0026#34;, \u0026#34;F\u0026#34;); returnStr = TRIM(returnStr, \u0026#34;\u0026#34;, \u0026#34;E\u0026#34;); returnStr = avoidMultipleOccurrence(returnStr, \u0026#34; \u0026#34;); returnStr = avoidMultipleOccurrence(returnStr, \u0026#34;\\t\u0026#34;); } return returnStr; } public static String TRIM(String str) { return (str == null) ? null : TRIM(str, \u0026#34; \u0026#34;, \u0026#34;R\u0026#34;); } public static String avoidMultipleOccurrence(String input, String character) { if (input == null) { return null; } if (input.length() == 0) { return input; } StringBuilder output = new StringBuilder(); output.append(input.charAt(0)); for (int idx = 1; idx \u0026lt; input.length(); idx++) { if (Character.toString(input.charAt(idx)).equals(character)) { if (input.charAt(idx) != input.charAt(idx - 1)) { output.append(input.charAt(idx)); } } else { output.append(input.charAt(idx)); } } return output.toString(); } } ",
    "ref": "/blog/2013-06-16-talend-equivalent-for-trim-function-in-datastage/"
  },{
    "title": "Talend Equivalent for MatchField Function in Datastage",
    "date": "June 16, 2013",
    "description": "",
    "body": "package routines; import java.util.regex.*; public class UserString { public static String MatchField(String sourceStr, String patternStr, Integer fieldNo) { String matchedStr = \u0026#34;\u0026#34;; if (fieldNo == null) { throw new UnsupportedOperationException(\u0026#34;fieldNo is supposed to be NOT NULL!!\u0026#34;); } if (patternStr == null) { return \u0026#34;\u0026#34;; } if (sourceStr == null) { return \u0026#34;\u0026#34;; } patternStr = formatPatternDStoTld(patternStr); Pattern pattern = Pattern.compile(patternStr); Matcher matcher = pattern.matcher(sourceStr); if (matcher.find()) { matchedStr = matcher.group(fieldNo); } else { matchedStr = \u0026#34;\u0026#34;; } return matchedStr; } public static String formatPatternDStoTld(String input) { StringBuilder output = new StringBuilder(); String outputStr = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; input.length(); i++) { Character firstChar = input.charAt(i); if (Character.isDigit(firstChar)) { Character secondChar = input.charAt(i + 1); int occur = Integer.parseInt(\u0026#34;\u0026#34; + firstChar); if (Character.isDigit(secondChar)) { occur = (occur * 10) + Integer.parseInt(\u0026#34;\u0026#34; + secondChar); i++; secondChar = input.charAt(i + 1); } if (Character.isLetter(secondChar)) { if (secondChar == \u0026#39;A\u0026#39;) { output.append(\u0026#34;([a-zA-Z]\u0026#34;); } else if (secondChar == \u0026#39;N\u0026#39;) { output.append(\u0026#34;(\\\\d\u0026#34;); } else if (secondChar == \u0026#39;X\u0026#39;) { output.append(\u0026#34;([a-zA-Z0-9 ]\u0026#34;); } if (occur == 0) { output.append(\u0026#34;*)\u0026#34;); } else { output.append(\u0026#34;{\u0026#34; + occur + \u0026#34;,\u0026#34; + occur + \u0026#34;})\u0026#34;); } i++; } else { output.append(\u0026#34;(\u0026#34; + firstChar + \u0026#34;)\u0026#34;); } } else { output.append(\u0026#34;(\u0026#34; + firstChar + \u0026#34;)\u0026#34;); } } outputStr = output.toString(); return outputStr; } } ",
    "ref": "/blog/2013-06-16-talend-equivalent-for-matchfield-function-in-datastage/"
  },{
    "title": "Exporting Google Contacts to a Nokia Phone",
    "date": "February 26, 2013",
    "description": "",
    "body": "You can export the Google Contacts to a Nokia phone very easily now!!\nDownload the low sized application (only 5.7KB) dbVcfSplitter.jar from the sourceforge\u0026hellip;\nFollow the below instructions-\n  Export the Google contacts in vCard format (with .vcf extension).\n  Open a command prompt or terminal.\n  \u0026ldquo;cd\u0026rdquo; to the folder or directory where the vCard file resides.\n  Type in the command below-\n java -jar dbVcfSplitter.jar contacts.vcf    The application will split the combined vCards into individual vCards so that you can import them to your Nokia Phones using PC Suite or OVI Suite, otherwise it won\u0026rsquo;t work!!\n\n",
    "ref": "/blog/2013-02-26-exporting-google-contacts-to-a-nokia-phone/"
  },{
    "title": "A command line SMTP GMailing tool in Java.",
    "date": "January 12, 2013",
    "description": "",
    "body": "Launched my new project in sourceforge. It is simply a command line SMTP GMailing tool.\nI googled a lot in pursuit of Linux/Unix like utilities for my windows machine. Could find some of them (Shared them in my previous post).\nSuccessfully installed and executed some of them :) Came across blat - A Windows (32 \u0026amp; 64 bit) command line SMTP mailer. Installed in my system. Executed - but could not connect to smtp.gmail.com - secured connection (using SSL) was required and blat do not support it.\nTried using open_ssl to connect to gmail.\nopenssl s_client -connect smtp.gmail.com:465 -crlf -ign_eof (welcome screen comes) --- 220 mx.google.com ESMTP is3sm3300685pbc.6 HELO 250 mx.google.com at your service auth login 334 VXNlcm5hbWU6 #asking for username - base-64 encoded form \u0026lt;key-in the base-64 encoded username\u0026gt; 334 UGFzc3dvcmQ6 #asking for password \u0026lt;key-in the base-64 encoded password\u0026gt;  Through the above procedure we can only check the connection and credentials. And everything should be base-64 encoded. Why such chaos?\nWith the power of Java and JavaMail API created a simple java program which accepts everything through the console. The program is just 12KB of size. Remaining (in 3.1MB) is contributed by the API jars ;)\nCheck this in sourceforge - dbMail.\n\u0026ndash;USAGE\u0026ndash;\ndbMail.bat -s=smtp.gmail.com -u=\u0026lt;loginId\u0026gt; -p=\u0026lt;password\u0026gt; -to=\u0026lt;email1;email2;email3\u0026gt; -cc=\u0026lt;email1;email2;email3\u0026gt; -bcc=\u0026lt;email1;email2;email3\u0026gt;  Please do not forget to give feedback :)\n",
    "ref": "/blog/2013-01-12-a-command-line-smtp-gmailing-tool-in-java/"
  },{
    "title": "Using Linux Utilities Under Windows",
    "date": "January 5, 2013",
    "description": "",
    "body": "There are many utilities in Linux/Unix which are very useful in our life say for example sed, awk, grep, etc. Some of us might have wished Windows/DOS environment to have similar kind of utilities. Anyway I did. Today I came across some of the open source projects, while googling, which provide some of the utilities in Windows too and thought of sharing :)\nThe projects are GnuWin and UnxUtils.\nPlease find below the links to their sourceforge pages GnuWin UnxUtils  ",
    "ref": "/blog/2013-01-05-using-linux-utilities-under-windows/"
  },{
    "title": "Talend equivalent for OCONV function in Datastage (Only for time and date)",
    "date": "October 20, 2012",
    "description": "",
    "body": "The function has been developed as a routine in the Talend.\npackage routines; import java.text.ParseException; public class DateConv { public static String oConv(int secToAdd, String format) throws ParseException { final String date = \u0026#34;31/12/1967\u0026#34;;// 31 Dec 1967  java.util.Date returnDate = null; String returnString = null; java.text.DateFormat sdf = new java.text.SimpleDateFormat(\u0026#34;dd/MM/yyyy\u0026#34;); java.util.Date parsedDate = sdf.parse(date); java.util.Calendar now = java.util.Calendar.getInstance(); now.setTime(parsedDate); if (format.equals(\u0026#34;MT\u0026#34;)) { // 02:46  sdf = new java.text.SimpleDateFormat(\u0026#34;HH:mm\u0026#34;); now.add(java.util.Calendar.SECOND, secToAdd); returnDate = now.getTime(); returnString = sdf.format(returnDate); } else if (format.equals(\u0026#34;MTS\u0026#34;)) { // 02:46:40  sdf = new java.text.SimpleDateFormat(\u0026#34;HH:mm:ss\u0026#34;); now.add(java.util.Calendar.SECOND, secToAdd); returnDate = now.getTime(); returnString = sdf.format(returnDate); } else if (format.equals(\u0026#34;MTHS\u0026#34;)) { // 02:46:40am  sdf = new java.text.SimpleDateFormat(\u0026#34;HH:mm:ssa\u0026#34;); now.add(java.util.Calendar.SECOND, secToAdd); returnDate = now.getTime(); returnString = sdf.format(returnDate).toLowerCase(); } else if (format.equals(\u0026#34;MTH\u0026#34;)) { // 02:46am  sdf = new java.text.SimpleDateFormat(\u0026#34;HH:mma\u0026#34;); now.add(java.util.Calendar.SECOND, secToAdd); returnDate = now.getTime(); returnString = sdf.format(returnDate).toLowerCase(); } else if (format.equals(\u0026#34;MT.\u0026#34;)) { // 02.46  sdf = new java.text.SimpleDateFormat(\u0026#34;HH.mm\u0026#34;); now.add(java.util.Calendar.SECOND, secToAdd); returnDate = now.getTime(); returnString = sdf.format(returnDate); } else if (format.equals(\u0026#34;D2\u0026#34;)) { // 3 Feb 93  sdf = new java.text.SimpleDateFormat(\u0026#34;d MMM yy\u0026#34;); now.add(java.util.Calendar.DAY_OF_MONTH, secToAdd); returnDate = now.getTime(); returnString = sdf.format(returnDate); } else if (format.equals(\u0026#34;D/E\u0026#34;)) { // 3/2/1993  sdf = new java.text.SimpleDateFormat(\u0026#34;d/M/yyyy\u0026#34;); now.add(java.util.Calendar.DAY_OF_MONTH, secToAdd); returnDate = now.getTime(); returnString = sdf.format(returnDate); } else if (format.equals(\u0026#34;DI\u0026#34;)) { // 3/2/1993  sdf = new java.text.SimpleDateFormat(\u0026#34;d/M/yyyy\u0026#34;); now.add(java.util.Calendar.DAY_OF_MONTH, secToAdd); returnDate = now.getTime(); returnString = sdf.format(returnDate); } else if (format.equals(\u0026#34;D2-\u0026#34;)) { // 2-3-93  sdf = new java.text.SimpleDateFormat(\u0026#34;M-d-yy\u0026#34;); now.add(java.util.Calendar.DAY_OF_MONTH, secToAdd); returnDate = now.getTime(); returnString = sdf.format(returnDate); } else if (format.equals(\u0026#34;D\u0026#34;)) { // 31 Dec 1967  sdf = new java.text.SimpleDateFormat(\u0026#34;d MMM yyyy\u0026#34;); now.add(java.util.Calendar.DAY_OF_MONTH, secToAdd); returnDate = now.getTime(); returnString = sdf.format(returnDate); } return returnString; } public static String oConv(String input, String format) throws ParseException { String returnString = null; java.text.DateFormat sdf = null; if (input.equalsIgnoreCase(\u0026#34;@DATE\u0026#34;) \u0026amp;\u0026amp; format.equals(\u0026#34;DMD[2,2]\u0026#34;)) { // DMD[2,2]  sdf = new java.text.SimpleDateFormat(\u0026#34;MMdd\u0026#34;); returnString = sdf.format(new java.util.Date()); } else if (input.equalsIgnoreCase(\u0026#34;@DATE\u0026#34;) \u0026amp;\u0026amp; format.equals(\u0026#34;DYMD[4,2,2]\u0026#34;)) { // DYMD[4,2,2]  sdf = new java.text.SimpleDateFormat(\u0026#34;yyyyMMdd\u0026#34;); returnString = sdf.format(new java.util.Date()); } return returnString; } } eg:\nDateConv.oConv(10000, \u0026quot;MTHS\u0026quot;); // 02:46:40am DateConv.oConv(9166, \u0026quot;D2\u0026quot;); // 3 Feb 93  ",
    "ref": "/blog/2012-10-20-talend-equivalent-for-oconv-function-in-datastage-only-for-time-and-date/"
  },{
    "title": "Java - removing leading zeroes from a string",
    "date": "October 6, 2012",
    "description": "",
    "body": "Using Regular Expressions (regex)\nString str = \u0026quot;00938\u0026quot;; System.out.println(\u0026quot;*\u0026quot; + str.replaceFirst(\u0026quot;^0+\u0026quot;, \u0026quot;\u0026quot;) + \u0026quot;*\u0026quot;);\t//*938*  Suppose the string contains only zeroes, then the output will be a null string.\nString str = \u0026quot;0000000\u0026quot;; System.out.println(\u0026quot;*\u0026quot; + str.replaceFirst(\u0026quot;^0+\u0026quot;, \u0026quot;\u0026quot;) + \u0026quot;*\u0026quot;); //**  If you want a zero to remain in the above case use another form -\nString str = \u0026quot;0000000\u0026quot;; System.out.println(\u0026quot;*\u0026quot; + str.replaceFirst(\u0026quot;^0+(?!$)\u0026quot;, \u0026quot;\u0026quot;) + \u0026quot;*\u0026quot;); //*0*  The negative lookahead (?!$) ensures that the entire string is not matched with the regular expression ^0+.\nThe anchor ^ makes sure that the beginning of the input is matched. 0+ denotes zero or more zeroes (0s).\n",
    "ref": "/blog/2012-10-06-java-removing-leading-zeroes-from-a-string/"
  },{
    "title": "Microsoft Magic",
    "date": "October 18, 2011",
    "description": "",
    "body": "MAGIC #1\nAn Indian discovered that nobody can create a FOLDER anywhere on the computer which can be named as \u0026ldquo;CON\u0026rdquo;. This is something pretty coolâ€¦ and unbelievableâ€¦ At Microsoft the whole Team, couldn\u0026rsquo;t answer why this happened!\nTRY IT NOW, IT WILL NOT CREATE \u0026ldquo;CON\u0026rdquo; FOLDER\nMAGIC #2\nFor those of you using Windows, do the following:\n Open an empty notepad file Type \u0026ldquo;Bush hid the facts\u0026rdquo; (without the quotes) Save it as whatever you want.. Close it, and re-open it.\nIs it just a really weird bug? At Microsoft they say they don\u0026rsquo;t know why this happens.  MAGIC #3\nMicrosoft\u0026rsquo;s crazy facts\nThis is something pretty cool and neatâ€¦ and unbelievableâ€¦ At Microsoft the whole Team, including Bill Gates, couldn\u0026rsquo;t answer why this happened!\nIt was discovered by a Brazilian.. Try it out yourselfâ€¦.\nOpen Microsoft Word and type\n=rand (200, 99)\nAnd then press ENTER then see the magicâ€¦â€¦\nCommentary This message combines three Microsoft Windows \u0026ldquo;magic tricks\u0026rdquo; that also circulate individually. The message is often posted to online message boards and blogs and also circulates via email. According to the message, not even Microsoft can explain why these procedures invoke such strange and unexpected outcomes.\nThe procedures outlined are real and do work as described. However, there is no mystery whatsoever. I discuss each \u0026ldquo;magic\u0026rdquo; item in turn below:\nMAGIC #1\nIt is in fact perfectly true that you cannot create a folder named \u0026ldquo;CON\u0026rdquo;, nor can you rename an existing folder to \u0026ldquo;CON\u0026rdquo;. However, the \u0026ldquo;team\u0026rdquo; at Microsoft, and a great many others besides, know perfectly well why you cannot name a folder \u0026ldquo;CON\u0026rdquo;.\n\u0026ldquo;CON\u0026rdquo; and a number of other character strings are in fact reserved names that go back to the days of DOS and cannot be used to name folders or files. Other reserved names are:\n PRN AUX NUL LPT1 COM1 Potential drive letter - A: to Z: A number of others  If you try to name a folder using one of these reserved names, the name will automatically revert to the default, generally \u0026ldquo;New Folder\u0026rdquo;. Moreover, if you try to use a reserved name to name a file such as a Notepad or Microsoft Word document you will generally receive an error message similar to the following:\nDepending on exactly how you save the file, you may instead receive a warning message advising that a file with that name already exists. However, even if you choose \u0026ldquo;Yes\u0026rdquo; to overwrite the existing file, you will still not be allowed* to save the file.\nWhile there is no mystery about this issue, it might have saved user confusion if Windows displayed an explanatory error message when attempting to create a folder with a reserved name as well.\nFor more detailed information see: MS-DOS Device Driver Names Cannot be Used as File Names\n Note: It may be possible to create a folder using a reserved name via the command prompt. However, this may cause other problems and is not advisable.  To create a folder named \u0026ldquo;con\u0026rdquo; - open the command prompt and type\nmd \\\\.\\c:\\con  To delete the folder \u0026ldquo;con\u0026rdquo; - type\nrd \\\\.\\c:\\con  MAGIC #2\nIt is true that, when the phrase \u0026ldquo;Bush hid the facts\u0026rdquo; is typed into the Windows XP or Windows NT/2000 versions of Notepad as instructed above, the re-opened file displays an unreadable line of squares or Chinese style characters.\nThe first image below shows the text before closing the Notepad file. The second image shows the text as it is displayed after the file is re-opened:\nSome of the more wide-eyed conspiracy theorists postulate that this result is a form of political commentary directed against US President Bush.\nAlas, the truth is far less compelling. It appears that a lot of other character strings in the pattern 4 letters, 3 letters, 3 letters and 5 letters will give the same result. For example, the phrase \u0026ldquo;Bill fed the goats\u0026rdquo; also displays the garbled text as shown below:\nIn fact, even a line of text such as \u0026ldquo;hhhh hhh hhh hhhhh\u0026rdquo; will elicit the same results.\nHowever, some character strings that fit the \u0026ldquo;4,3,3,5\u0026rdquo; pattern do not generate the error. For example, the phrase \u0026ldquo;Bush hid the truth\u0026rdquo; is displayed normally. However, conspiracy theorists should not take this as aiding their argument. \u0026ldquo;Fred led the brats\u0026rdquo;, \u0026ldquo;brad ate the trees\u0026rdquo; and other strings also escape the error.\nThus, any hint of political conspiracy fades into oblivion and is replaced by a rather mundane programming bug. It seems that a certain combination and/or frequency of letters in the character string cause Notepad to misinterpret the encoding of the file when it is re-opened. If the file is originally saved as \u0026ldquo;Unicode\u0026rdquo; rather than \u0026ldquo;ANSI\u0026rdquo; the text displays correctly. Older versions of Notepad such as those that came with Windows 95, 98 or ME do not include Unicode support so the error does not occur.\nMAGIC #3\nUsing the rand() function in the way described automatically adds sample text to a word document. In Word 2003 and earlier versions, the rand() function adds several sentences and paragraphs that repeat the words, The quick brown fox jumps over the lazy dog. These words are often used for testing because, together, they contain all the letters in the English alphabet in one concise and coherent sentence. Such a sentence is known as a pangram.\nIn Word 2007, the rand() function adds information about using specific Word features in order to create a more realistic document for testing. However, if you wish to use the \u0026ldquo;Quick Brown Fox\u0026rdquo; pangram in Word 2007, you can still do so by inputting the function =rand.old(). Another Word 2007 option is to use =lorem(), This function automatically adds the familiar Lorem ipsum dummy text that has been used by the printing and typesetting industry since the 1500\u0026rsquo;s. Nowadays, Lorem ipsum text is also used extensively by web developers and publishers to add random text to such things as templates and website prototypes.\nYou can alter the results of the rand() function by adding numbers in the round brackets. The first number controls the number of paragraphs while the second number controls the number of sentences in each paragraph. For example, using \u0026ldquo;rand(3,5)\u0026rdquo; will add three paragraphs of five sentences each. Leaving the brackets empty will add the default number of paragraphs and sentences, which is set at three sentences and three paragraphs.\nFar from being a mystery, this is a well-documented feature of Microsoft Word that simply allows sample text to be quickly added to a document for testing purposes. Microsoft can in fact \u0026ldquo;explain the result\u0026rdquo; and does so in an article on the MS Support website.\nThus, although these little computer tricks are interesting, there is no mystery or magic involved and Microsoft certainly does know about them.\nCourtesy: Hoax-Slayer\n",
    "ref": "/blog/2011-10-18-microsoft-magic/"
  },{
    "title": "One Of The Best Arguments, I Have Ever Read !!!",
    "date": "October 9, 2011",
    "description": "",
    "body": "\nOne Of The Best Arguments.!! I have ever read. Donâ€™t miss even a single wordâ€¦ Itâ€™s Too good\nAn atheist professor of philosophy speaks to his class on the problem science has with God, The Almighty.\nHe asks one of his new students to stand andâ€¦..\nProf: So you believe in God?\nStudent: Absolutely, sir.\nProf: Is God good?\nStudent: Sure.\nProf: Is God all-powerful?\nStudent: Yes..\nProf: My brother died of cancer even though he prayed to God to heal him. Most of us would attempt to help others who are ill. But God didnâ€™t. How is this God good then? Hmm? (Student is silent.)\nProf: You canâ€™t answer, can you? Letâ€™s start again, young fella. Is God good?\nStudent: Yes.\nProf: Is Satan good?\nStudent: No.\nProf: Where does Satan come from?\nStudent: Fromâ€¦.Godâ€¦\nProf: Thatâ€™s right. Tell me son, is there evil in this world?\nStudent: Yes.\nProf: Evil is everywhere, isnâ€™t it? And God did make everything. Correct?\nStudent: Yes.\nProf: So who created evil? (Student does not answer.)\nProf: Is there sickness? Immorality? Hatred? Ugliness? All these terrible things exist in the world, donâ€™t they?\nStudent: Yes, sir.\nProf: So, who created them? (Student has no answer.)\nProf: Science says you have 5 senses you use to identify and observe the world around you. Tell me, sonâ€¦Have you ever seen God?\nStudent: No, sir.\nProf: Tell us if you have ever heard your God?\nStudent: No, sir.\nProf: Have you ever felt your God, tasted your God, smelt your God? Have you ever had any sensory perception of God for that matter?\nStudent: No, sir. Iâ€™m afraid I havenâ€™t.\nProf: Yet you still believe in Him?\nStudent: Yes.\nProf: According to empirical, testable, demonstrable protocol, science says your GOD doesnâ€™t exist. What do you say to that, son?\nStudent: Nothing. I only have my faith.\nProf: Yes. Faith. And that is the problem science has.\nStudent: Professor, is there such a thing as heat?\nProf: Yes.\nStudent: And is there such a thing as cold?\nProf: Yes.\nStudent: No sir. There isnâ€™t. (The lecture the after becomes very quiet with this turn of events.)\nStudent: Sir, you can have lots of heat, even more heat, superheat, mega heat, white heat, a little heat or no heat..\nBut we donâ€™t have anything called cold. We can hit 458 degrees below zero which is no heat, but we canâ€™t go any further after that. There is no such thing as cold. Cold is only a word we use to describe the absence of heat. We cannot measure cold. Heat is energy Cold is not the opposite of heat, sir, just the absence of it . (There is pin-drop silence in the lecture theatre.)\nStudent: What about darkness, Professor? Is there such a thing as darkness?\nProf: Yes. What is night if there isnâ€™t darkness?\nStudent : Youâ€™re wrong again, sir. Darkness is the absence of something. You can have low light, normal light, bright light, flashing lightâ€¦..But if you have no light constantly, you have nothing and itâ€™s called darkness, isnâ€™t it? In reality, darkness isnâ€™t. If it were you would be able to make darkness darker, wouldnâ€™t you?\nProf: So what is the point you are making, young man?\nStudent: Sir, my point is your philosophical premise is flawed.\nProf: Flawed? Can you explain how?\nStudent: Sir, you are working on the premise of duality. You argue there is life and then there is death, a good God and a bad God. You are viewing the concept of God as something finite, something we can measure. Sir, science canâ€™t even explain a thought.. It uses electricity and magnetism, but has never seen, much less fully understood either one.To view death as the opposite of life is to be ignorant of the fact that death cannot exist as a substantive thing. Death is not the opposite of life: just the absence of it. Now tell me, Professor.Do you teach your students that they evolved from a monkey?\nProf: If you are referring to the natural evolutionary process, yes, of course, I do.\nStudent: Have you ever observed evolution with your own eyes, sir? (The Professor shakes his head with a smile, beginning to realize where the argument is going.)\nStudent: Since no one has ever observed the process of evolution at work and cannot even prove that this process is an on-going endeavor, are you not teaching your opinion, sir? Are you not a scientist but a preacher? (The class is in uproar.)\nStudent: Is there anyone in the class who has ever seen the Professorâ€™s brain? (The class breaks out into laughter.)\nStudent : Is there anyone here who has ever heard the Professorâ€™s brain, felt it, touched or smelt it? No one appears to have done so. So, according to the established rules of empirical, stable, demonstrable protocol, science says that you have no brain,sir. With all due respect, sir, how do we then trust your lectures, sir? (The room is silent. The professor stares at the student, his face unfathomable.)\nProf: I guess youâ€™ll have to take them on faith, son.\nStudent: That is it sirâ€¦ The link between man \u0026amp; god is FAITH . That is all that keeps things moving \u0026amp; alive.\nI believe you have enjoyed the conversationâ€¦and if soâ€¦youâ€™ll probably want your friends/colleagues to enjoy the sameâ€¦ wonâ€™t you?.. This is a true story, and the student was none other than \u0026hellip;.\nAPJ Abdul Kalam, the former President of India\n",
    "ref": "/blog/2011-10-09-one-of-the-best-arguments-i-have-ever-read/"
  },{
    "title": "Dr. A.P.J Abdul Kalam's Speech: A Must Read",
    "date": "October 9, 2011",
    "description": "",
    "body": "\nI have three visions for India. In 3000 years of our history people from all over the world have come and invaded us, captured our lands, conquered our minds. From Alexander onwards. The Greeks, the Turks, the Moguls, the Portuguese, the British, the French, the Dutch, all of them came and looted us, took over what was ours. Yet we have not done this to any other nation. We have not conquered anyone. We have not grabbed their land, their culture, their history and tried to enforce our way of life on them. Why? Because we respect the freedom of others. That is why my first vision is that of FREEDOM. I believe that India got its first vision of this in 1857, when we started the war of independence. It is this freedom that we must protect and nurture and build on. If we are not free, no one will respect us.\nMy second vision for India is DEVELOPMENT. For fifty years we have been a developing nation. It is time we see ourselves as a developed nation. We are among top 5 nations of the world in terms of GDP. We have 10 percent growth rate in most areas. Our poverty levels are falling. Our achievements are being globally recognized today. Yet we lack the self-confidence to see ourselves as a developed nation, self-reliant and self-assured. Isn\u0026rsquo;t this incorrect?\nI have a THIRD vision. India must stand up to the world. Because I believe that unless India stands up to the world, no one will respect us. Only strength respects strength. We must be strong not only as a military power but also as an economic power. Both must go hand-in-hand. My good fortune was to have worked with three great minds. Dr. Vikram Sarabhai of the Dept. of space, Professor Satish Dhawan, who succeeded him and Dr. Brahm Prakash, father of nuclear material. I was lucky to have worked with all three of them closely and consider this the great opportunity of my life.\nI see four milestones in my career: ONE: Twenty years I spent in ISRO. I was given the opportunity to be the project director for India\u0026rsquo;s first satellite launch vehicle, SLV3. The one that launched Rohini. These years played a very important role in my life of Scientist.\nTWO: After my ISRO years, I joined DRDO and got a chance to be the part of India\u0026rsquo;s missile program. It was my second bliss when Agni met its mission requirements in 1994.\nTHREE: The Dept. of Atomic Energy and DRDO had this tremendous partnership in the recent nuclear tests, on May 11 and 13. This was the third bliss. The joy of participating with my team in these nuclear tests and proving to the world that India can make it, that we are no longer a developing nation but one of them. It made me feel very proud as an Indian. The fact that we have now developed for Agni a re-entry structure, for which we have developed this new material. A Very light material called carbon-carbon.\nFOUR: One day an orthopedic surgeon from Nizam Institute of Medical Sciences visited my laboratory. He lifted the material and found it so light that he took me to his hospital and showed me his patients. There were these little girls and boys with heavy metallic calipers weighing over three kg. each, dragging their feet around. He said to me: Please remove the pain of my patients. In three weeks, we made these Floor reaction Orthosis 300 gram calipers and took them to the orthopedic centre. The children didn\u0026rsquo;t believe their eyes. From dragging around a three kg. load on their legs, they could now move around! Their parents had tears in their eyes. That was my fourth bliss!\nWhy is the media here so negative? Why are we in India so embarrassed to recognize our own strengths, our achievements? We are such a great nation. We have so many amazing success stories but we refuse to acknowledge them. Why? We are the first in milk production. We are number one in Remote sensing satellites. We are the second largest producer of wheat. We are the second largest producer of rice. Look at Dr. Sudarshan, he has transferred the tribal village into a self-sustaining, self-driving unit. There are millions of such achievements but our media is only obsessed in the bad news and failures and disasters.\nI was in Tel Aviv once and I was reading the Israeli newspaper. It was the day after a lot of attacks and bombardments and deaths had taken place. The Hamas had struck. But the front page of the newspaper had the picture of a Jewish gentleman who in five years had transformed his desert land into an orchid and a granary. It was this inspiring picture that everyone woke up to. The gory details of killings, bombardments, deaths, were inside in the newspaper, buried among other news. In India we only read about death, sickness, terrorism, crime. Why are we so NEGATIVE? Another question: Why are we, as a nation so obsessed with foreign things? We want foreign TVs, we want foreign shirts. We want foreign technology. Why this obsession with everything imported. Do we not realize that self-respect comes with self-reliance?\nI was in Hyderabad giving this lecture, when a 14 year old girl asked me for my autograph. I asked her what her goal in life is: She replied: I want to live in a developed India. For her, you and I will have to build this developed India. You must proclaim. India is not an under-developed nation; it is a highly developed nation.\nAllow me to come back with vengeance. Got 10 minutes for your country?\nYOU say that our government is inefficient. YOU say that our laws are too old. YOU say that the municipality does not pick up the garbage. YOU say that the phones don\u0026rsquo;t work, the railways are a joke, the airline is the worst in the world, mails never reach their destination. YOU say that our country has been fed to the dogs and is the absolute pits. YOU say, say and say.\nWhat do YOU do about it? Take a person on his way to Singapore. Give him a name - YOURS. Give him a face - YOURS. YOU walk out of the airport and you are at your International best. In Singapore you don\u0026rsquo;t throw cigarette butts on the roads or eat in the stores. YOU are as proud of their Underground Links as they are. You pay $5 (approx. Rs. 60) to drive through Orchard Road (equivalent of Mahim Causeway or Pedder Road) between 5 PM and 8 PM.\nYOU comeback to the parking lot to punch your parking ticket if you have over stayed in a restaurant or a shopping mall irrespective of your status identity. In Singapore you don\u0026rsquo;t say anything, DO YOU? YOU wouldn\u0026rsquo;t dare to eat in public during Ramadan, in Dubai. YOU would not dare to go out without your head covered in Jeddah. YOU would not dare to buy an employee of the telephone exchange in London at 10 pounds (Rs. 650) a month to, \u0026ldquo;see to it that my STD and ISD calls are billed to someone else.\u0026rdquo; YOU would not dare to speed beyond 55 mph (88 kph) in Washington and then tell the traffic cop, \u0026ldquo;Jaanta hai sala main kaun hoon (Do you know who I am?). I am so and so\u0026rsquo;s son. Take your two bucks and get lost.\u0026rdquo; YOU wouldn\u0026rsquo;t chuck an empty coconut shell anywhere other than the garbage pail on the beaches in Australia and New Zealand. Why don\u0026rsquo;t YOU spit Paan on the streets of Tokyo? Why don\u0026rsquo;t YOU use examination jockeys or buy fake certificates in Boston? We are still talking of the same YOU. YOU who can respect and conform to a foreign system in other countries but cannot in your own. You who will throw papers and cigarettes on the road the moment you touch Indian ground. If you can be an involved and appreciative citizen in an alien country why cannot you be the same here in India. Once in an interview, the famous Ex-municipal commissioner of Bombay Mr.Tinaikar had a point to make. \u0026ldquo;Rich people\u0026rsquo;s dogs are walked on the streets to leave their affluent droppings all over the place,\u0026rdquo; he said. \u0026ldquo;And then the same people turn around to criticize and blame the authorities for inefficiency and dirty pavements. What do they expect the officers to do? Go down with a broom every time their dog feels the pressure in his bowels? In America every dog owner has to clean up after his pet has done the job. Same in Japan. Will the Indian citizen do that here?\u0026rdquo; He\u0026rsquo;s right. We go to the polls to choose a government and after that forfeit all responsibility. We sit back wanting to be pampered and expect the government to do everything for us whilst our contribution is totally negative. We expect the government to clean up but we are not going to stop chucking garbage all over the place nor are we going to stop to pick a up a stray piece of paper and throw it in the bin. We expect the railways to provide clean bathrooms but we are not going to learn the proper use of bathrooms. We want Indian Airlines and Air India to provide the best of food and toiletries but we are not going to stop pilfering at the least opportunity. This applies even to the staff who is known not to pass on the service to the public. When it comes to burning social issues like those related to women, dowry, girl child and others, we make loud drawing room protestations and continue to do the reverse at home. Our excuse? \u0026ldquo;It\u0026rsquo;s the whole system which has to change, how will it matter if I alone forego my sons\u0026rsquo; rights to a dowry.\u0026rdquo; So who\u0026rsquo;s going to change the system? What does a system consist of? Very conveniently for us it consists of our neighbors, other households, other cities, other communities and the government. But definitely not me and YOU. When it comes to us actually making a positive contribution to the system we lock ourselves along with our families into a safe cocoon and look into the distance at countries far away and wait for a Mr. Clean to come along \u0026amp; work miracles for us with a majestic sweep of his hand. Or we leave the country and run away. Like lazy cowards hounded by our fears we run to America to bask in their glory and praise their system. When New York becomes insecure we run to England. When England experiences unemployment, we take the next flight out to the Gulf. When the Gulf is war struck, we demand to be rescued and brought home by the Indian government. Everybody is out to abuse and rape the country. Nobody thinks of feeding the system. Our conscience is mortgaged to money.\nDear Indians, The article is highly thought inductive, calls for a great deal of introspection and pricks one\u0026rsquo;s conscience too\u0026hellip;. I am echoing J.F. Kennedy\u0026rsquo;s words to his fellow Americans to relate to Indians\u0026hellip;..\n\u0026ldquo;ASK WHAT WE CAN DO FOR INDIA AND DO WHAT HAS TO BE DONE TO MAKE INDIA WHAT AMERICA AND OTHER WESTERN COUNTRIES ARE TODAY\u0026rdquo;\nLets do what India needs from us.\n",
    "ref": "/blog/2011-10-09-dr-a-p-j-abdul-kalams-speech-a-must-read/"
  },{
    "title": "Creating a PDF file in Java",
    "date": "October 7, 2011",
    "description": "",
    "body": "jPDFCreator.java\nimport com.itextpdf.text.BaseColor; import com.itextpdf.text.Chapter; import com.itextpdf.text.Document; import com.itextpdf.text.DocumentException; import com.itextpdf.text.Font; import com.itextpdf.text.FontFactory; import com.itextpdf.text.List; import com.itextpdf.text.ListItem; import com.itextpdf.text.PageSize; import com.itextpdf.text.Paragraph; import com.itextpdf.text.Section; import com.itextpdf.text.pdf.PdfWriter; import java.io.FileNotFoundException; import java.io.FileOutputStream; /** * * @author dhanoopbhaskar */ public class jPDFCreator { Document document = null; PdfWriter pdfWriter = null; public jPDFCreator() { /** * Creating an instance of com.itextpdf.text.Document * The arguments * -page size * -left margin * -right margin * -top margin * -bottom margin */ document = new Document(PageSize.A4, 50, 50, 50, 50); try { /** * Arguments * -instance of Document * -OutputStream of file to which the data has to be written */ pdfWriter = PdfWriter.getInstance( document, new FileOutputStream(\u0026#34;jPDF.pdf\u0026#34;)); } catch (FileNotFoundException ex) { System.out.println(ex); } catch (DocumentException ex) { System.out.println(ex); } /** * Open the document */ document.open(); try { /** * Adding a paragraph to the document */ document.add(new Paragraph(\u0026#34;First Paragraph.\u0026#34;)); /** * Creating an instance of com.itextpdf.text.Font * Arguments * -font name * -size * -style * -base color */ Font font = FontFactory.getFont(FontFactory.COURIER, 14, Font.BOLD, BaseColor.BLUE); /** * Pass an instance of font in new Paragraph() to set font. */ document.add(new Paragraph(\u0026#34;Second Paragraph in a different \u0026#34; + \u0026#34;color and font type.\u0026#34;, font)); /** * Creating a Chapter * Arguments * -title * -number * Setting number depth to 0 - to hide chapter number on page. */ Paragraph chapterTitle = new Paragraph(\u0026#34;Chapter 1\u0026#34;, font); Chapter chapter1 = new Chapter(chapterTitle, 1); chapter1.setNumberDepth(0); /** * Creating Sections under the Chapter */ Paragraph sectionTitle = new Paragraph( \u0026#34;Section 1 in Chapter 1\u0026#34;, font); Section section1 = chapter1.addSection(sectionTitle); Paragraph textUnderSection = new Paragraph(\u0026#34;Some text \u0026#34; + \u0026#34;under the section 1 in the chapter 1\u0026#34;); section1.add(textUnderSection); section1.setNumberDepth(0); Paragraph someText = new Paragraph(\u0026#34;Following is a list.\u0026#34;); section1.add(someText); /** * Creating a list * Arguments * -numbered * -lettered * -symbolIndent */ List list = new List(true, false, 10); /** * Adding list items */ list.add(new ListItem(\u0026#34;First item in the list\u0026#34;)); list.add(new ListItem(\u0026#34;Second item in the list\u0026#34;)); list.add(new ListItem(\u0026#34;Third item in the list\u0026#34;)); /** * Adding the list to section1 */ section1.add(list); /** * Adding chapter1 to document */ document.add(chapter1); document.close(); } catch (DocumentException ex) { System.out.println(ex); } } public static void main(String[] args) { new jPDFCreator(); } } SCREENSHOTS\nPage1\n\nPage2\nProgram with the statements:\nchapter1.setNumberDepth(0);  andÂ section1.setNumberDepth(0);  \nPage2\nProgram without the statements:\nchapter1.setNumberDepth(0);  and\nsection1.setNumberDepth(0);  \n",
    "ref": "/blog/2011-10-07-creating-a-pdf-file-in-java/"
  },{
    "title": "HTTP POST in Java using URLConnection",
    "date": "October 4, 2011",
    "description": "",
    "body": "URLPost.java\nimport java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.OutputStreamWriter; import java.io.UnsupportedEncodingException; import java.net.MalformedURLException; import java.net.URL; import java.net.URLConnection; import java.net.URLEncoder; /** * * @author dhanoopbhaskar */ public class URLPost { public URLPost() { } /** * @param args the command line arguments */ public static void main(String[] args) { try { /** * Constructing the data to be sent. * The data is encoded in UTF8 encoding scheme. * For that encode() method in the class java.net.URLEncoder * is used */ String data = URLEncoder.encode(\u0026#34;sName\u0026#34;, \u0026#34;UTF-8\u0026#34;) + \u0026#34;=\u0026#34; + URLEncoder.encode(\u0026#34;PI\u0026#34;, \u0026#34;UTF-8\u0026#34;); data += \u0026#34;\u0026amp;\u0026#34; + URLEncoder.encode(\u0026#34;sData\u0026#34;, \u0026#34;UTF-8\u0026#34;) + \u0026#34;=\u0026#34; + URLEncoder.encode(\u0026#34;3.14159\u0026#34;, \u0026#34;UTF-8\u0026#34;); System.out.println(\u0026#34;Data: \u0026#34; + data); /** * URL to which the post data has to be sent. */ URL url = new URL(\u0026#34;http://localhost/cybman/test/post2.php\u0026#34;); /** * A URLConnection is opened */ URLConnection conn = url.openConnection(); /** * The variable doOutput in URLConnection is false by default. * It should be set as true, otherwise we cannot write to a * URLConnection. * * Possible Exception (if doOuput is false): * java.net.ProtocolException: cannot write to a URLConnection * if doOutput=false - call setDoOutput(true) * at sun.net.www.protocol.http.HttpURLConnection.getOutputStream( * HttpURLConnection.java:885) * */ conn.setDoOutput(true); /** * Getting the output stream of URLConnection */ OutputStreamWriter outputStreamWriter = new OutputStreamWriter( conn.getOutputStream()); /** * Writing and flushing the data */ outputStreamWriter.write(data); outputStreamWriter.flush(); /** * Getting the input stream of URLConnection */ BufferedReader bufferedReader = new BufferedReader( new InputStreamReader(conn.getInputStream())); String line; System.out.print(\u0026#34;Result: \u0026#34;); /** * The Response is read and displayed. */ while ((line = bufferedReader.readLine()) != null) { System.out.println(line); } /** * Close the opened readers and writers. */ outputStreamWriter.close(); bufferedReader.close(); } catch (MalformedURLException ex) { //thrown by new URL()  System.out.println(ex); } catch (UnsupportedEncodingException ex) { //thrown by URLEncoder.encode()  System.out.println(ex); } catch (IOException ex) { //thrown by stream class methods  System.out.println(ex); } } } OUTPUT\nData: sName=PI\u0026amp;sData=3.14159 Result: Done!!  post2.php\n\u0026lt;?php if(isset($_POST['sName']) \u0026amp;\u0026amp; isset($_POST['sData'])) { # Read the POST variables $name = $_POST['sName']; $data = $_POST['sData']; # Create output string $str = \u0026quot;\\\u0026quot;$name\\\u0026quot;, \\\u0026quot;$data\\\u0026quot;\\n\u0026quot;; # Open and write to file $fh = fopen(\u0026quot;postData.txt\u0026quot;, \u0026quot;a+\u0026quot;); fwrite($fh, $str); fclose($fh); echo \u0026quot;Done!!\u0026quot;; } ?\u0026gt;  postData.txt\n\u0026quot;PI\u0026quot;, \u0026quot;3.14159\u0026quot; ",
    "ref": "/blog/2011-10-04-http-post-in-java-using-urlconnection/"
  },{
    "title": "Java - GTalk Client using SMACK XMPP API",
    "date": "September 22, 2011",
    "description": "",
    "body": "GtalkClient.java\nimport java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.Collection; import java.util.Iterator; import org.jivesoftware.smack.Chat; import org.jivesoftware.smack.ConnectionConfiguration; import org.jivesoftware.smack.MessageListener; import org.jivesoftware.smack.Roster; import org.jivesoftware.smack.RosterEntry; import org.jivesoftware.smack.XMPPConnection; import org.jivesoftware.smack.XMPPException; import org.jivesoftware.smack.packet.Message; /** * * @author dhanoopbhaskar */ public class GtalkClient implements Runnable, MessageListener { ConnectionConfiguration connConfig = null; XMPPConnection xMPPConnection = null; BufferedReader readFromKeyboard = null; String toAddresss = null; String[] buddies = null; int buddySize = 0; public GtalkClient() { /** * Set the \u0026#39;ConnectionConfiguration\u0026#39; with * -host name * -port number * -service name */ connConfig = new ConnectionConfiguration(\u0026#34;talk.google.com\u0026#34;, 5222, \u0026#34;gmail.com\u0026#34;); /** * Create an instance of \u0026#39;XMPPConnection\u0026#39; with the already created * instance of \u0026#39;ConnectionConfiguration\u0026#39; */ xMPPConnection = new XMPPConnection(connConfig); try { /** * Connecting to the service */ xMPPConnection.connect(); /** * Login to the GMail account from which you want to chat * Provide * -email id * -password */ xMPPConnection.login(\u0026#34;user-name@gmail.com\u0026#34;, \u0026#34;password\u0026#34;); } catch (XMPPException ex) { System.out.println(\u0026#34;Error: \u0026#34; + ex.getMessage()); } /** * BufferedReader to read from the keyboard */ readFromKeyboard = new BufferedReader(new InputStreamReader(System.in)); displayBuddyList(); System.out.println(\u0026#34;\\n\\nEnter the recipient\u0026#39;s Email Id! or \u0026#34; + \u0026#34;buddy id in the list\u0026#34;); try { String temp = readFromKeyboard.readLine(); try { int j = Integer.parseInt(temp); toAddresss = getBuddy(j); System.out.println(\u0026#34;Buddy \u0026lt;\u0026#34; + toAddresss + \u0026#34;\u0026gt; selected!\u0026#34;); } catch(NumberFormatException exp) { toAddresss = temp; } } catch (IOException ex) { System.out.println(\u0026#34;Error: \u0026#34; + ex.getMessage()); } System.out.println(\u0026#34;Enter your chat messages one by one!\u0026#34;); System.out.println(\u0026#34;[Enter \\\u0026#34;quit\\\u0026#34; to end the chat!]\u0026#34;); String msg = \u0026#34;\u0026#34;; while(true) { try { msg = readFromKeyboard.readLine(); } catch (IOException ex) { System.out.println(\u0026#34;Error: \u0026#34; + ex.getMessage()); } if(msg.equalsIgnoreCase(\u0026#34;quit\u0026#34;)) { System.out.println(\u0026#34;--Chat Ended--\u0026#34;); break; } else { sendMessage(toAddresss, msg); } } } /** * * @param recipient * @param message */ private void sendMessage(String recipient, String message) { /** * Create an instance of \u0026#39;Chat\u0026#39; providing the recipient\u0026#39;s email-id * and an instance of MessageListener interface(The predefined * reference \u0026#39;this\u0026#39; will do, since the class * implements the MessageListener interface. */ Chat chat = xMPPConnection.getChatManager().createChat(recipient, this); try { /** * Sending the chat message */ chat.sendMessage(message); } catch (XMPPException ex) { System.out.println(\u0026#34;Error: \u0026#34; + ex.getMessage()); } } /** * This method belongs to MessageListener interface. * It listens for the incoming chat messages. */ @Override public void processMessage(Chat chat, Message msg) { String msgStr = msg.getBody(); System.out.println(\u0026#34;\u0026lt;\u0026#34; + chat.getParticipant() + \u0026#34;\u0026gt; says \u0026#34; + msgStr); } public static void main(String[] args) { GtalkClient gtalkClient = new GtalkClient(); } @Override public void run() { } private void displayBuddyList() { Roster roster = xMPPConnection.getRoster(); Collection entries = roster.getEntries(); System.out.println(\u0026#34;\\n\\n------------Your Buddies!!------------\u0026#34;); System.out.println(entries.size() + \u0026#34; buddy(ies):\\n\u0026#34;); Iterator iter = entries.iterator(); buddySize = entries.size(); buddies = new String[buddySize]; int i = 0; while (iter.hasNext()) { RosterEntry rosterEntry = (RosterEntry) iter.next(); buddies[i] = rosterEntry.getUser(); i++; System.out.println(i + \u0026#34;. \u0026#34; + rosterEntry.getUser()); } System.out.println(\u0026#34;--------------------------------------\u0026#34;); } private String getBuddy(int i) { String buddy = \u0026#34;\u0026#34;; if(i \u0026gt; 0 \u0026amp;\u0026amp; i \u0026lt;= buddySize) { buddy = buddies[i-1]; } else { System.out.println(\u0026#34;Invalid Buddy Id!! Selected default one!!\u0026#34;); buddy = buddies[0]; } return buddy; } } \u0026mdash;\u0026mdash;Sample Output\u0026mdash;\u0026mdash;\n------------Your Buddies!!------------ 3 buddy(ies): 1. dhanoopbhaskar@gmail.com 2. dhanoopbhaskar4@gmail.com 3. dhanoopbhaskar3@gmail.com -------------------------------------- Enter the recipient's Email Id! or buddy id in the list 1 Buddy \u0026lt;dhanoopbhaskar@gmail.com\u0026gt; selected! Enter your chat messages one by one! [Enter \u0026quot;quit\u0026quot; to end the chat!] hi \u0026lt;dhanoopbhaskar@gmail.com\u0026gt; says hello quit --Chat Ended--  NB: To run and test the above program you need to download Smack XMPP API from here\u0026hellip;\n",
    "ref": "/blog/2011-09-22-java-gtalk-client-using-smack-xmpp-api/"
  },{
    "title": "Contact",
    "date": "January 1, 0001",
    "description": "",
    "body": "",
    "ref": "/contact/"
  }]
