[{
    "title": "ROS In Docker Container",
    "date": "May 7, 2020",
    "description": "",
    "body": "ROS (Robot Operating System) - Documentation - http://wiki.ros.org/\nIn this example I use docker image of ROS Melodic and a Dockerfile for creating the required docker container. Python3 (python3.7) is also installed in this example.\nPlease refer https://docs.docker.com/get-started/ for more information on Dockers.\n  Pull the docker image for ROS Melodic\n docker pull ros:melodic    Creating the Dockerfile FROM ros:melodic MAINTAINER dhanoopbhaskar@gmail.com RUN apt-get update \u0026amp;\u0026amp; apt-get upgrade -y \\ \u0026amp;\u0026amp; apt-get install -y software-properties-common \\ \u0026amp;\u0026amp; add-apt-repository ppa:deadsnakes/ppa \\ \u0026amp;\u0026amp; apt-get install -y python3.7 RUN apt-get update \u0026amp;\u0026amp; apt-get install -y \\ python-pip \\ python3-pip \\ python3-all-dev RUN apt-get install -y \\ python3-rospkg* RUN apt-get update --fix-missing RUN dpkg --configure -a RUN apt-get install -f RUN apt-get install -y \\ ros-melodic-desktop-full --fix-missing RUN apt-get install -y python-catkin-tools RUN apt-get install --no-install-recommends --no-install-suggests -y \\ build-essential \\ cmake \\ python3.7-dev \\ \u0026amp;\u0026amp; rm -rf /var/lib/apt/lists/* RUN python -m pip install --upgrade pip RUN python2 -m pip install --upgrade pip RUN python3 -m pip install --upgrade pip RUN pip3 install --upgrade pip RUN pip3 install --upgrade setuptools RUN python3.7 -m pip install --upgrade pip RUN python3.7 -m pip install --upgrade setuptools    Now create the docker using this Dockerfile and run ðŸ˜Š (Refer documentation for more information).\n  ",
    "ref": "/blog/2020-05-07-ros-in-docker-container/"
  },{
    "title": "Working With Python 3 In ROS Kinetic Or Melodic",
    "date": "May 7, 2020",
    "description": "",
    "body": "ROS (Robot Operating System) - Documentation - http://wiki.ros.org/\n The Robot Operating System (ROS) is a flexible framework for writing robot software. It is a collection of tools, libraries, and conventions that aim to simplify the task of creating complex and robust robot behavior across a wide variety of robotic platforms. â€” https://www.ros.org/ 1 ROS (upto Melodic) officially supports only python2 and NOT python3. However some libraries we use in our projects (eg. Speech Recognition using Google Cloud Speech) may require python3 to run.\nIf ROS needs to support python3 we may have to recompile ROS source code using python3 which is not practical.\nSo what we can do is to run python3 programs, separately and connect using ROS bridge. (if we use custom messages (ROS msg)\nHowever, if we are not using any custom rosmsg and using only built-in rosmsg, we can do the following steps to run python3 codes in ROS (without using a ROS bridge.)\nInstall ROS (here I install Melodic)\n apt install ros-melodic-desktop-full  After installing ROS, install rospkg for python3\n apt install python3-pip python3-all-dev python3-rospkg  This will prompt to install python3-rospkg and to remove ROS packages (already installed). Select Yes for that prompt. This will remove ROS packages and we will have to re-install them.\n apt install ros-melodic-desktop-full --fix-missing  This will complete the installation part. Now comes the coding part.\nJust include the following directive as the first line of your program code (file) which should be executed using python3.\n #!/usr/bin/env python3  We can now execute everything as we do normally in ROS. Read the documentation (link is given above) for more information on ROS.\n  https://www.ros.org/ \u0026#x21a9;\u0026#xfe0e;\n   ",
    "ref": "/blog/2020-05-07-working-with-python-3-in-ros-kinetic-or-melodic/"
  },{
    "title": "Biped Walking Robot",
    "date": "October 28, 2019",
    "description": "",
    "body": "We, a team of 3, attended a course titled \u0026ldquo;2 Mechatronics Project\u0026rdquo; conducted by Skyfi Labs in the month of October 2019. Thought of sharing the assignments done as a part of the course.\nBiped Walking Robot\n  ",
    "ref": "/blog/2019-10-28-biped-walking-robot/"
  },{
    "title": "Robotic Arm",
    "date": "October 28, 2019",
    "description": "",
    "body": "We, a team of 3, attended a course titled \u0026ldquo;2 Mechatronics Project\u0026rdquo; conducted by Skyfi Labs in the month of October 2019.Â Thought of sharing the assignments done as a part of the course.\nRobotic Arm\n  ",
    "ref": "/blog/2019-10-28-robotic-arm/"
  },{
    "title": "7 Robots in 6 Days",
    "date": "October 28, 2019",
    "description": "",
    "body": "7 Robots in 6 Days\nWe, a team of 3, attended a course titled \u0026ldquo;7 Robots in 6 Days\u0026rdquo; conducted by Skyfi Labs in the month of June 2019. Thought of sharing the assignments done as a part of the course.\n1. Line Follower Robot using Arduino\n  2. Obstacle Avoider Robot using Arduino\n  3. Obstacle Follower Robot using Arduino\n  4. Gesture Based Robotics\n  5. Mobile Controlled Robot\n  6. Swarm Robotics\n  7. Maze Solver Robot using Arduino\n  ",
    "ref": "/blog/2019-10-28-7-robots-in-6-days/"
  },{
    "title": "About",
    "date": "February 28, 2019",
    "description": "the insane techie",
    "body": "A technical blog which covers mainly Java technologies. Other programming languages are also covered.\n",
    "ref": "/about/"
  },{
    "title": "Mounting an iPhone to Linux Mint as an external drive to copy images and videos",
    "date": "July 2, 2018",
    "description": "",
    "body": "Phone: iPhone SE\nOperating System: Linux MintÂ 18.1(should work in Ubuntu as well)\nIt is done by compiling most of the sources yourself.\nOnly one library - usbmuxd - must be installed as root\nAll others are installed in the home account.\nInstall necessary software for building the source packages.\nTo check-out and compile the needed packages from source, you have to install git first.\nOpen a terminal and do the following:\n:~$ sudo apt-get install -y git :~$ sudo apt-get install -y build-essential :~$ sudo apt-get install -y libtool m4 automake :~$ sudo apt-get install -y libfuse-dev  All new commands to mount and unmount the file-system of your iPhone, will be installed in the sub-directory ${HOME}/usr/bin/.\nCreate the sub-directory to store the source files of the packages to be compiled:\n:~$ mkdir -p \u0026quot;$HOME/usr/src\u0026quot;  Set all required environment variables to ensure to build the packages from source as desired:\n:~$ export PKG_CONFIG_PATH=\u0026quot;${HOME}/usr/lib/pkgconfig:${PKG_CONFIG_PATH}\u0026quot; :~$ export CPATH=\u0026quot;${HOME}/usr/include:${CPATH}\u0026quot; :~$ export MANPATH=\u0026quot;${HOME}/usr/share/man:${MANPATH}\u0026quot; :~$ export PATH=\u0026quot;${HOME}/usr/bin:${PATH}\u0026quot; :~$ export LD_LIBRARY_PATH=\u0026quot;${HOME}/usr/lib:${LD_LIBRARY_PATH}\u0026quot;  Now put the last two export statements into your .bashrc, to be loaded every time you open a new terminal, otherwise you must type:\n:~$ export PATH=\u0026quot;${HOME}/usr/bin:${PATH}\u0026quot; :~$ export LD_LIBRARY_PATH=\u0026quot;${HOME}/usr/lib:${LD_LIBRARY_PATH}\u0026quot;  whenever you open a new terminal.\nClone all needed repositories from Github.\n:~$ cd ~/usr/src :~$ for x in libplist libusbmuxd usbmuxd libimobiledevice ifuse; do git clone https://github.com/libimobiledevice/${x}.git;done  Build and install the packages in the following order.\nBuild libplist\n:~$ cd ~/usr/src/libplist :~$ ./autogen.sh --prefix=\u0026quot;$HOME/usr\u0026quot; :~$ make \u0026amp;\u0026amp; make install  Build libusbmuxd\n:~$ cd ~/usr/src/libusbmuxd :~$ ./autogen.sh --prefix=\u0026quot;$HOME/usr\u0026quot; :~$ make \u0026amp;\u0026amp; make install  Build libimobiledevice\n:~$ cd ~/usr/src/libimobiledevice :~$ ./autogen.sh --prefix=\u0026quot;$HOME/usr\u0026quot; :~$ make \u0026amp;\u0026amp; make install  Build usbmuxd\n(The package usbmuxd must be installed with administrative rights, because it needs write access to /lib/udev/rules.d and /lib/systemd/system)\n:~$ cd ~/usr/src/usbmuxd :~$ ./autogen.sh --prefix=\u0026quot;$HOME/usr\u0026quot; :~$ make \u0026amp;\u0026amp; sudo make install  Build ifuse\n:~$ cd ~/usr/src/ifuse :~$ ./autogen.sh --prefix=\u0026quot;$HOME/usr\u0026quot; :~$ make \u0026amp;\u0026amp; make install  TESTING\nIt\u0026rsquo;s assumed that you put the two exports into your ~/.bashrc as mentioned above.\nOpen a new terminal. Connect your iPhone. Create a mount point, where you want the content of your iPhone to appear.\n:~$ mkdir -p ~/usr/mnt  Connect your iPhone to the computer and try to pair the iPhone with your computer.\n:~$ idevicepair pair  If error occurs during validation, please enter the passcode on the device and retry. A trust dialog will be appeared on your device. You have to accept it as well\n:~$ idevicepair pair  After successfully pairing the device, mount the file-system of your iPhone and check the content\n:~$ ifuse ~/usr/mnt/ :~$ ls ~/usr/mnt/  To safely disconnect your iPhone, you have to unmount the file-system in ~/usr/mnt first with fusermount.\n:~$ fusermount -u ~/usr/mnt  Now, you can plug-off your iPhone again.\nERRORS AND SOLUTIONS\n(1) configure: error: OpenSSL support explicitly requested but OpenSSL could not be found\n:~$ sudo apt-get install libssl-dev  (2) configure: error: Could not link test program to Python. Maybe the main Python library has been installed in some non-standard library path. If so, pass it to configure, via the LDFLAGS environment variable.\nExample: ./configure LDFLAGS=\u0026rdquo;-L/usr/non-standard-path/python/lib\u0026rdquo;\n(You probably have to install the development version of the Python package for your distribution.Â The exact name of this package varies among them.)\n:~$ sudo apt-get install python-dev  ",
    "ref": "/blog/2018-07-02-mounting-an-iphone-to-linux-mint-as-an-external-drive-to-copy-images-and-videos/"
  },{
    "title": "RESTful Web Services in Java",
    "date": "August 22, 2016",
    "description": "",
    "body": "Read about REST here\u0026hellip;\nIn the example program REST is implemented using Jersey Framework.\nDownload Jersey framework from here\u0026hellip;\nI used Dynamic Web Project in Eclipse for coding. Extract jersey zip file and copy all the .jar files from api, ext, lib folders to WebContent/WEB-INF/lib folder.\nEmployee.java\npackage in.theinsanetechie.rest; import java.io.Serializable; import javax.xml.bind.annotation.XmlElement; import javax.xml.bind.annotation.XmlRootElement; @XmlRootElement(name = \u0026#34;employee\u0026#34;) public class Employee implements Serializable { private static final long serialVersionUID = 1L; private int empcode; private String name; private String designation; private float basicpay; public Employee() { } public Employee(int empcode, String name, String designation, float basicpay) { super(); this.empcode = empcode; this.name = name; this.designation = designation; this.basicpay = basicpay; } public int getEmpcode() { return empcode; } @XmlElement public void setEmpcode(int empcode) { this.empcode = empcode; } public String getName() { return name; } @XmlElement public void setName(String name) { this.name = name; } public String getDesignation() { return designation; } @XmlElement public void setDesignation(String designation) { this.designation = designation; } public float getBasicpay() { return basicpay; } @XmlElement public void setBasicpay(float basicpay) { this.basicpay = basicpay; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Employee other = (Employee) obj; if (Float.floatToIntBits(basicpay) != Float.floatToIntBits(other.basicpay)) return false; if (designation == null) { if (other.designation != null) return false; } else if (!designation.equals(other.designation)) return false; if (empcode != other.empcode) return false; if (name == null) { if (other.name != null) return false; } else if (!name.equals(other.name)) return false; return true; } } EmployeeAccessObject.java\npackage in.theinsanetechie.rest; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.ArrayList; import java.util.List; public class EmployeeAccessObject { private String fileName = \u0026#34;Employee.dat\u0026#34;; @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public List getFullList() { List list = null; File file = new File(fileName); try { if (file.exists()) { FileInputStream fileInputStream = new FileInputStream(file); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); list = (List) objectInputStream.readObject(); objectInputStream.close(); } else { Employee employee = new Employee(1001, \u0026#34;The Insane Techie\u0026#34;, \u0026#34;Dev\u0026#34;, 99999.99f); list = new ArrayList(); list.add(employee); saveList(list); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } return list; } public Employee get(int empcode) { List list = getFullList(); for (Employee temp : list) { if (temp.getEmpcode() == empcode) { return temp; } } return null; } public boolean addToList(Employee emp) { List list = getFullList(); boolean exists = false; for (Employee temp : list) { if (temp.getEmpcode() == emp.getEmpcode()) { exists = true; break; } } if (!exists) { list.add(emp); saveList(list); return true; } return false; } public boolean updateList(Employee emp) { List list = getFullList(); for (Employee temp : list) { if (temp.getEmpcode() == emp.getEmpcode()) { int index = list.indexOf(temp); list.set(index, emp); saveList(list); return true; } } return false; } public boolean deleteFromList(int empcode) { List list = getFullList(); for (Employee temp : list) { if (temp.getEmpcode() == empcode) { int index = list.indexOf(temp); list.remove(index); saveList(list); return true; } } return false; } private void saveList(List list) { File file = new File(fileName); try { FileOutputStream fileOutputStream = new FileOutputStream(file); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(list); objectOutputStream.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } } EmployeeService.java\npackage in.theinsanetechie.rest; import java.io.IOException; import java.util.List; import javax.servlet.http.HttpServletResponse; import javax.ws.rs.Consumes; import javax.ws.rs.DELETE; import javax.ws.rs.FormParam; import javax.ws.rs.GET; import javax.ws.rs.OPTIONS; import javax.ws.rs.POST; import javax.ws.rs.PUT; import javax.ws.rs.Path; import javax.ws.rs.PathParam; import javax.ws.rs.Produces; import javax.ws.rs.core.Context; import javax.ws.rs.core.MediaType; @Path(\u0026#34;/EmployeeService\u0026#34;) public class EmployeeService { EmployeeAccessObject accessObject = new EmployeeAccessObject(); private static final String SUCCESS = \u0026#34;success\u0026#34;; private static final String FAILURE = \u0026#34;failure\u0026#34;; @GET @Path(\u0026#34;/employees\u0026#34;) @Produces(MediaType.APPLICATION_XML) public List getFullList() { return accessObject.getFullList(); } @GET @Path(\u0026#34;/employees/{empcode}\u0026#34;) @Produces(MediaType.APPLICATION_XML) public Employee get(@PathParam(\u0026#34;empcode\u0026#34;) int empcode) { return accessObject.get(empcode); } @PUT @Path(\u0026#34;/employees\u0026#34;) @Produces(MediaType.APPLICATION_XML) @Consumes(MediaType.APPLICATION_FORM_URLENCODED) public String add(@FormParam(\u0026#34;empcode\u0026#34;) int empcode, @FormParam(\u0026#34;name\u0026#34;) String name, @FormParam(\u0026#34;designation\u0026#34;) String designation, @FormParam(\u0026#34;basicpay\u0026#34;) float basicpay, @Context HttpServletResponse servletResponse) throws IOException { Employee emp = new Employee(empcode, name, designation, basicpay); boolean result = accessObject.addToList(emp); if (result == true) { return SUCCESS; } return FAILURE; } @POST @Path(\u0026#34;/employees\u0026#34;) @Produces(MediaType.APPLICATION_XML) @Consumes(MediaType.APPLICATION_FORM_URLENCODED) public String update(@FormParam(\u0026#34;empcode\u0026#34;) int empcode, @FormParam(\u0026#34;name\u0026#34;) String name, @FormParam(\u0026#34;designation\u0026#34;) String designation, @FormParam(\u0026#34;basicpay\u0026#34;) float basicpay, @Context HttpServletResponse servletResponse) throws IOException { Employee emp = new Employee(empcode, name, designation, basicpay); boolean result = accessObject.updateList(emp); if (result == true) { return SUCCESS; } return FAILURE; } @DELETE @Path(\u0026#34;/employees/{empcode}\u0026#34;) @Produces(MediaType.APPLICATION_XML) public String deleteUser(@PathParam(\u0026#34;empcode\u0026#34;) int empcode) { boolean result = accessObject.deleteFromList(empcode); if (result == true) { return SUCCESS; } return FAILURE; } @OPTIONS @Path(\u0026#34;/employees\u0026#34;) @Produces(MediaType.APPLICATION_XML) public String getSupportedOperations() { return \u0026#34;GET, PUT, POST, DELETE\u0026#34;; } }  WebServiceTester.java\npackage in.theinsanetechie.rest; import java.util.List; import javax.ws.rs.client.Client; import javax.ws.rs.client.ClientBuilder; import javax.ws.rs.client.Entity; import javax.ws.rs.core.Form; import javax.ws.rs.core.GenericType; import javax.ws.rs.core.MediaType; public class WebServiceTester { private Client client; private String REST_SERVICE_URL = \u0026#34;http://localhost:8080/EmployeeManagement/rest/EmployeeService/employees\u0026#34;; private static final String SUCCESS = \u0026#34;success\u0026#34;; private static final String PASS = \u0026#34;pass\u0026#34;; private static final String FAIL = \u0026#34;fail\u0026#34;; private void init() { this.client = ClientBuilder.newClient(); } public static void main(String[] args) { WebServiceTester tester = new WebServiceTester(); tester.init(); tester.testGetFullList(); tester.testGet(); tester.testUpdate(); tester.testAdd(); tester.testDelete(); } private void testGetFullList(){ GenericType\u0026gt; list = new GenericType\u0026gt;() {}; List employees = client .target(REST_SERVICE_URL) .request(MediaType.APPLICATION_XML) .get(list); String result = PASS; if(employees.isEmpty()){ result = FAIL; } System.out.println(\u0026#34;Test case name: testGetFullList, Result: \u0026#34; + result ); } private void testGet() { Employee sampleEmp = new Employee(); sampleEmp.setEmpcode(1001); Employee emp = client.target(REST_SERVICE_URL).path(\u0026#34;/{empcode}\u0026#34;).resolveTemplate(\u0026#34;empcode\u0026#34;, 1001) .request(MediaType.APPLICATION_XML).get(Employee.class); String result = FAIL; if (sampleEmp != null \u0026amp;\u0026amp; sampleEmp.getEmpcode() == emp.getEmpcode()) { result = PASS; } System.out.println(\u0026#34;Test case name: testGet, Result: \u0026#34; + result); } private void testUpdate() { Form form = new Form(); form.param(\u0026#34;empcode\u0026#34;, \u0026#34;1001\u0026#34;); form.param(\u0026#34;name\u0026#34;, \u0026#34;Dhanoop Bhaskar\u0026#34;); form.param(\u0026#34;designation\u0026#34;, \u0026#34;Computer Scientist\u0026#34;); form.param(\u0026#34;basicpay\u0026#34;, \u0026#34;100000.00f\u0026#34;); String callResult = client.target(REST_SERVICE_URL).request(MediaType.APPLICATION_XML) .post(Entity.entity(form, MediaType.APPLICATION_FORM_URLENCODED_TYPE), String.class); String result = PASS; if (!SUCCESS.equals(callResult)) { result = FAIL; } System.out.println(\u0026#34;Test case name: testUpdate, Result: \u0026#34; + result); } private void testAdd() { Form form = new Form(); form.param(\u0026#34;empcode\u0026#34;, \u0026#34;1002\u0026#34;); form.param(\u0026#34;name\u0026#34;, \u0026#34;The Insane Techie\u0026#34;); form.param(\u0026#34;designation\u0026#34;, \u0026#34;Computer Scientist\u0026#34;); form.param(\u0026#34;basicpay\u0026#34;, \u0026#34;100000.00f\u0026#34;); String callResult = client.target(REST_SERVICE_URL).request(MediaType.APPLICATION_XML) .put(Entity.entity(form, MediaType.APPLICATION_FORM_URLENCODED_TYPE), String.class); String result = PASS; if (!SUCCESS.equals(callResult)) { result = FAIL; } System.out.println(\u0026#34;Test case name: testAdd, Result: \u0026#34; + result); } private void testDelete() { String callResult = client.target(REST_SERVICE_URL).path(\u0026#34;/{empcode}\u0026#34;).resolveTemplate(\u0026#34;empcode\u0026#34;, 1002) .request(MediaType.APPLICATION_XML).delete(String.class); String result = PASS; if (!SUCCESS.equals(callResult)) { result = FAIL; } System.out.println(\u0026#34;Test case name: testDelete, Result: \u0026#34; + result); } } web.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns=\u0026#34;http://java.sun.com/xml/ns/javaee\u0026#34; xsi:schemaLocation=\u0026#34;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\u0026#34; id=\u0026#34;WebApp_ID\u0026#34; version=\u0026#34;3.0\u0026#34;\u0026gt; \u0026lt;display-name\u0026gt;Employee Management\u0026lt;/display-name\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;Jersey RESTful Application\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.glassfish.jersey.servlet.ServletContainer\u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;jersey.config.server.provider.packages\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;in.theinsanetechie.rest\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;Jersey RESTful Application\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/rest/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt; ",
    "ref": "/blog/2016-08-22-restful-web-services-in-java/"
  },{
    "title": "Installing and Configuring phpMyAdmin in Ubuntu/Linux Mint",
    "date": "March 9, 2016",
    "description": "",
    "body": "Install phpmyadmin\nsudo apt-get install phpmyadmin  Configure phpmyadmin\nsudo dpkg-reconfigure -plow phpmyadmin  Then select Apache 2 for the webserver you wish to configure.\nTry hitting the URL http://localhost/phpmyadmin/\nIf this does not work, then you have to include the phpMyAdmin-shipped Apache configuration into Apache:\nsudo ln -s /etc/phpmyadmin/apache.conf /etc/apache2/conf.d/phpmyadmin.conf sudo /etc/init.d/apache2 reload  Since Ubuntu 13.10 (Saucy Salamander), Apache no longer loads configuration files from the /etc/apache2/conf.d directory.\nInstead, they are placed in the /etc/apache2/conf-available directory which is managed with the a2enconf command.\nTherefore, if you need to manually include the phpMyAdmin-shipped Apache configuration file, you must run the following:\nsudo ln -s /etc/phpmyadmin/apache.conf /etc/apache2/conf-available/phpmyadmin.conf sudo a2enconf phpmyadmin sudo /etc/init.d/apache2 reload  ",
    "ref": "/blog/2016-03-09-installing-and-configuring-phpmyadmin-in-ubuntu-linux-mint/"
  },{
    "title": "DNS Lookup - Implementation in C",
    "date": "February 14, 2016",
    "description": "",
    "body": "Read about DNS here\u0026hellip;\nDNS Lookup - Implementation in C\n/**dnsclient.c**/ #include\u0026#34;stdio.h\u0026#34;  #include\u0026#34;stdlib.h\u0026#34;  #include\u0026#34;sys/types.h\u0026#34;  #include\u0026#34;sys/socket.h\u0026#34;  #include\u0026#34;string.h\u0026#34;  #include\u0026#34;netinet/in.h\u0026#34;  #include\u0026#34;netdb.h\u0026#34; #include\u0026#34;arpa/inet.h\u0026#34; #define BUF_SIZE 512  #define SERVER \u0026#34;8.8.8.8\u0026#34;  #define PORT 53  #define WIDTH 16  int createSocket(); void createRequest(char * url); void hexdump (char *desc, void *addr, int len); void lookUp(); struct query { uint16_t length; char * url; unsigned char request[BUF_SIZE]; uint16_t reqType; }; struct query dnsQuery = { .length = 12, .url = \u0026#34;\u0026#34;, .reqType = 0x01, .request = { 0xDB, 0x42, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } }; int main(int argc, char** argv) { char * url; if (argc != 2) { fprintf(stderr,\u0026#34;usage: %s hostnameToResolve\\n\u0026#34;, argv[0]); exit(1); } url = argv[1]; createRequest(url); lookUp(); } int createSocket() { int sockfd; sockfd = socket(AF_INET, SOCK_DGRAM, 0); if (sockfd \u0026lt; 0) { printf(\u0026#34;Error creating socket!\\n\u0026#34;); exit(1); } //printf(\u0026#34;Socket created...\\n\u0026#34;);  return sockfd; } void createRequest(char * url) { char * word; int i; printf(\u0026#34;Asking DNS server %s about %s\\n\u0026#34;, SERVER, url); dnsQuery.url = strdup(url); dnsQuery.reqType = 0x01; word = strtok(url, \u0026#34;.\u0026#34;); while (word) { printf(\u0026#34;parsing hostname: \\\u0026#34;%s\\\u0026#34;is %d characters\\n\u0026#34;, word, strlen(word)); dnsQuery.request[dnsQuery.length++] = strlen(word); for (i = 0; i \u0026lt; strlen(word); i++) { dnsQuery.request[dnsQuery.length++] = word[i]; } word = strtok(NULL, \u0026#34;.\u0026#34;); } dnsQuery.request[dnsQuery.length++] = 0x00; // End of the host name  dnsQuery.request[dnsQuery.length++] = 0x00; // 0x0001 - Query is a Type A query (host address)  dnsQuery.request[dnsQuery.length++] = dnsQuery.reqType; dnsQuery.request[dnsQuery.length++] = 0x00; // 0x0001 - Query is class IN (Internet address)  dnsQuery.request[dnsQuery.length++] = 0x01; } // http://stackoverflow.com/questions/7775991/how-to-get-hexdump-of-a-structure-data  void hexdump (char *desc, void *addr, int len) { int i; unsigned char buff[17]; unsigned char *pc = addr; // Output description if given.  if (desc != NULL) printf (\u0026#34;%s:\\n\u0026#34;, desc); // Process every byte in the data.  for (i = 0; i \u0026lt; len; i++) { // Multiple of 16 means new line (with line offset).  if ((i % 16) == 0) { // Just don\u0026#39;t print ASCII for the zeroth line.  if (i != 0) printf (\u0026#34; %s\\n\u0026#34;, buff); // Output the offset.  printf (\u0026#34; %04x \u0026#34;, i); } // Now the hex code for the specific character.  printf (\u0026#34; %02x\u0026#34;, pc[i]); // And store a printable ASCII character for later.  if ((pc[i] \u0026lt; 0x20) || (pc[i] \u0026gt; 0x7e)) buff[i % 16] = \u0026#39;.\u0026#39;; else buff[i % 16] = pc[i]; buff[(i % 16) + 1] = \u0026#39;\\0\u0026#39;; } // Pad out last line if not exactly 16 characters.  while ((i % 16) != 0) { printf (\u0026#34; \u0026#34;); i++; } // And print the final ASCII bit.  printf (\u0026#34; %s\\n\u0026#34;, buff); } void lookUp() { struct sockaddr_in addr; int socket; int ret, rcode, size, i; int ip = 0, dom = 0; int length; unsigned char buffer[BUF_SIZE]; unsigned char tempBuf[3]; uint16_t QDCOUNT; //No. of items in Question Section  uint16_t ANCOUNT; //No. of items in Answer Section  uint16_t NSCOUNT; //No. of items in Authority Section  uint16_t ARCOUNT; //No. of items in Additional Section  uint16_t QCLASS; //Specifies the class of the query  uint16_t ATYPE; //Specifies the meaning of the data in the RDATA field  uint16_t ACLASS; //Specifies the class of the data in the RDATA field  uint32_t TTL; //The number of seconds the results can be cached  uint16_t RDLENGTH; //The length of the RDATA field  uint16_t MSGID; socket = createSocket(); memset(\u0026amp;addr, 0, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_addr.s_addr = inet_addr(SERVER); addr.sin_port = htons(PORT); size = sizeof(addr); hexdump(\u0026#34;sending packet\u0026#34;, \u0026amp;dnsQuery.request, dnsQuery.length); ret = sendto(socket, dnsQuery.request, dnsQuery.length, 0, (struct sockaddr*)\u0026amp;addr, size); if (ret \u0026lt; 0) { printf(\u0026#34;Error Sending Request\u0026#34;); exit(1); } //printf(\u0026#34;Sent\\n\u0026#34;);  memset(\u0026amp;buffer, 0, BUF_SIZE); ret = recvfrom(socket, buffer, BUF_SIZE, 0, (struct sockaddr*)\u0026amp;addr, \u0026amp;size); if (ret \u0026lt; 0) { printf(\u0026#34;Error Receiving Response\u0026#34;); exit(1); } hexdump(\u0026#34;received packet\u0026#34;, \u0026amp;buffer, ret); close(socket); rcode = (buffer[3] \u0026amp; 0x0F); //tempBuf[0] = buffer[4];  //tempBuf[1] = buffer[5];  //tempBuf[2] = \u0026#39;\\0\u0026#39;;  //printf(\u0026#34;%0x %0x %0x %0x\\n\u0026#34;, buffer[4], buffer[5], tempBuf[0], tempBuf[1]);  //QDCOUNT = (uint16_t) strtol(tempBuf, NULL, 16);  QDCOUNT = (uint16_t) buffer[4] * 0x100 + buffer[5]; printf(\u0026#34;entries in question section: %u\\n\u0026#34;, QDCOUNT); ANCOUNT = (uint16_t) buffer[6] * 0x100 + buffer[7]; printf(\u0026#34;records in answer section: %u\\n\u0026#34;, ANCOUNT); NSCOUNT = (uint16_t) buffer[8] * 0x100 + buffer[9]; printf(\u0026#34;name server resource record count: %u\\n\u0026#34;, NSCOUNT); ARCOUNT = (uint16_t) buffer[10] * 0x100 + buffer[11]; printf(\u0026#34;additional records count: %u\\n\u0026#34;, ARCOUNT); printf(\u0026#34;query type: %u\\n\u0026#34;, dnsQuery.reqType); QCLASS = (uint16_t) dnsQuery.request[dnsQuery.length - 2] * 0x100 + dnsQuery.request[dnsQuery.length - 1]; printf(\u0026#34;query class: %u\\n\u0026#34;, QCLASS); length = dnsQuery.length + 1; // to skip 0xc00c  ATYPE = (uint16_t) buffer[length + 1] * 0x100 + buffer[length + 2]; printf(\u0026#34;answer type: %u\\n\u0026#34;, ATYPE); ACLASS = (uint16_t) buffer[length + 3] * 0x100 + buffer[length + 4]; printf(\u0026#34;answer class: %u\\n\u0026#34;, ACLASS); TTL = (uint32_t) buffer[length + 5] * 0x1000000 + buffer[length + 6] * 0x10000 + buffer[length + 7] * 0x100 + buffer[length + 8]; printf(\u0026#34;seconds to cache: %u\\n\u0026#34;, TTL); RDLENGTH = (uint16_t) buffer[length + 9] * 0x100 + buffer[length + 10]; printf(\u0026#34;bytes in answer: %u\\n\u0026#34;, RDLENGTH); MSGID = (uint16_t) buffer[0] * 0x100 + buffer[1]; printf(\u0026#34;answer msg id: %u\\n\u0026#34;, MSGID); if (rcode == 2) { printf(\u0026#34;nameserver %s returned SERVFAIL:\\n\u0026#34;, SERVER); printf(\u0026#34; the name server was unable to process this query due to a\\nproblem with the name server.\\n\u0026#34;); exit(1); } else if (rcode == 3) { printf(\u0026#34;nameserver %s returned NXDOMAIN for %s:\\n\u0026#34;, SERVER, dnsQuery.url); printf(\u0026#34; the domain name referenced in the query does not exist\\n\u0026#34;); exit(1); } /* search for and print IPv4 addresses */ if (dnsQuery.reqType == 0x01) { printf(\u0026#34;DNS server\u0026#39;s answer is: (type#=%u):\u0026#34;, ATYPE); //printf(\u0026#34;IPv4 address(es) for %s:\\n\u0026#34;, dnsQuery.url);  for (i = 0 ; i \u0026lt; ret ; i++) { if (buffer[i] == 0xC0 \u0026amp;\u0026amp; buffer[i+3] == 0x01) { ip++; i += 12; /* ! += buf[i+1]; */ printf(\u0026#34; %u.%u.%u.%u\\n\u0026#34;, buffer[i], buffer[i+1], buffer[i+2], buffer[i+3]); } } if (!ip) { printf(\u0026#34; No IPv4 address found in the DNS response!\\n\u0026#34;); exit(1); } } } Output\ndhanoopbhaskar@dhanoop-laptop:~/workspace/Copy/_works$ gcc dnsclient.c dhanoopbhaskar@dhanoop-laptop:~/workspace/Copy/_works$ ./a.out www.theinsanetechie.in Asking DNS server 8.8.8.8 about www.theinsanetechie.in parsing hostname: \u0026quot;www\u0026quot; is 3 characters parsing hostname: \u0026quot;theinsanetechie\u0026quot; is 15 characters parsing hostname: \u0026quot;in\u0026quot; is 2 characters sending packet: 0000 db 42 01 00 00 01 00 00 00 00 00 00 03 77 77 77 .B...........www 0010 0f 74 68 65 69 6e 73 61 6e 65 74 65 63 68 69 65 .theinsanetechie 0020 02 69 6e 00 00 01 00 01 .in..... received packet: 0000 db 42 81 80 00 01 00 03 00 00 00 00 03 77 77 77 .B...........www 0010 0f 74 68 65 69 6e 73 61 6e 65 74 65 63 68 69 65 .theinsanetechie 0020 02 69 6e 00 00 01 00 01 c0 0c 00 05 00 01 00 00 .in............. 0030 32 c7 00 10 03 67 68 73 06 67 6f 6f 67 6c 65 03 2....ghs.google. 0040 63 6f 6d 00 c0 34 00 05 00 01 00 00 54 5f 00 08 com..4......T_.. 0050 03 67 68 73 01 6c c0 38 c0 50 00 01 00 01 00 00 .ghs.l.8.P...... 0060 01 2b 00 04 4a 7d 44 79 .+..J}Dy entries in question section: 1 records in answer section: 3 name server resource record count: 0 additional records count: 0 query type: 1 query class: 1 answer type: 5 answer class: 1 seconds to cache: 12999 bytes in answer: 16 answer msg id: 56130 DNS server's answer is: (type#=5): 74.125.68.121 dhanoopbhaskar@dhanoop-laptop:~/workspace/Copy/_works$  ",
    "ref": "/blog/2016-02-14-dns-lookup-implementation-in-c/"
  },{
    "title": "Java program to find the distance between two GPS locations.",
    "date": "March 11, 2015",
    "description": "",
    "body": "Location.java\npackage com.cables.gps; public class Location { private int latDegree; private int latMinutes; private int latSeconds; private char latDirection; private int longDegree; private int longMinutes; private int longSeconds; private char longDirection; private float latitude; private float longitude; private void init() throws Exception { latitude = latDegree + (latMinutes / 60.0f) + (latSeconds / 3600.0f); if (latDirection == \u0026#39;N\u0026#39;) { latitude *= 1f; } else if (latDirection == \u0026#39;S\u0026#39;) { latitude *= -1f; } else { throw new Exception(\u0026#34;Invalid Latitude Direction: \u0026#34; + latDirection); } longitude = longDegree + (longMinutes / 60.0f) + (longSeconds / 3600.0f); if (longDirection == \u0026#39;E\u0026#39;) { longitude *= 1f; } else if (longDirection == \u0026#39;W\u0026#39;) { longitude *= -1f; } else { throw new Exception(\u0026#34;Invalid Longitude Direction: \u0026#34; + longDirection); } } public String toString() { String returnString = \u0026#34;\u0026#34;; try { init(); } catch (Exception e) { e.printStackTrace(); return null; } returnString += \u0026#34;(\u0026#34; + latitude + \u0026#34;, \u0026#34; + longitude + \u0026#34;)\u0026#34;; return returnString; } public void setLatitude(int deg, int min, int sec, char dir) { latDegree = deg; latMinutes = min; latSeconds = sec; latDirection = dir; } public void setLongitude(int deg, int min, int sec, char dir) { longDegree = deg; longMinutes = min; longSeconds = sec; longDirection = dir; } public int getLatDegree() { return latDegree; } public void setLatDegree(int latDegree) { this.latDegree = latDegree; } public int getLatMinutes() { return latMinutes; } public void setLatMinutes(int latMinutes) { this.latMinutes = latMinutes; } public int getLatSeconds() { return latSeconds; } public void setLatSeconds(int latSeconds) { this.latSeconds = latSeconds; } public char getLatDirection() { return latDirection; } public void setLatDirection(char latDirection) throws Exception { if (latDirection != \u0026#39;N\u0026#39; \u0026amp;\u0026amp; latDirection != \u0026#39;S\u0026#39;) { throw new Exception(\u0026#34;Invalid Latitude Direction: \u0026#34; + latDirection); } this.latDirection = latDirection; } public int getLongDegree() { return longDegree; } public void setLongDegree(int longDegree) { this.longDegree = longDegree; } public int getLongMinutes() { return longMinutes; } public void setLongMinutes(int longMinutes) { this.longMinutes = longMinutes; } public int getLongSeconds() { return longSeconds; } public void setLongSeconds(int longSeconds) { this.longSeconds = longSeconds; } public char getLongDirection() { return longDirection; } public void setLongDirection(char longDirection) throws Exception { if (longDirection != \u0026#39;E\u0026#39; \u0026amp;\u0026amp; longDirection != \u0026#39;W\u0026#39;) { throw new Exception(\u0026#34;Invalid Longitude Direction: \u0026#34; + longDirection); } this.longDirection = longDirection; } public float getLatitude() throws Exception { init(); return latitude; } public void setLatitude(float latitude) { this.latitude = latitude; } public float getLongitude() throws Exception { init(); return longitude; } public void setLongitude(float longitude) { this.longitude = longitude; } public void setLatString(String latStr) throws Exception { latStr = latStr.trim(); String[] values = latStr.split(\u0026#34; \u0026#34;); latDegree = Integer.parseInt(values[0].trim()); latMinutes = Integer.parseInt(values[1].trim()); latSeconds = Integer.parseInt(values[2].trim()); latDirection = values[3].trim().charAt(0); if (latDirection != \u0026#39;N\u0026#39; \u0026amp;\u0026amp; latDirection != \u0026#39;S\u0026#39;) { throw new Exception(\u0026#34;Invalid Latitude Direction: \u0026#34; + latDirection); } } public void setLongString(String longStr) throws Exception { longStr = longStr.trim(); String[] values = longStr.split(\u0026#34; \u0026#34;); longDegree = Integer.parseInt(values[0].trim()); longMinutes = Integer.parseInt(values[1].trim()); longSeconds = Integer.parseInt(values[2].trim()); longDirection = values[3].trim().charAt(0); if (longDirection != \u0026#39;E\u0026#39; \u0026amp;\u0026amp; longDirection != \u0026#39;W\u0026#39;) { throw new Exception(\u0026#34;Invalid Longitude Direction: \u0026#34; + longDirection); } } } LocationOps.java\npackage com.cables.gps; public class LocationOps { private Location location1 = null; private Location location2 = null; private int radius = 6371; public LocationOps(Location location1, Location location2) { this.location1 = location1; this.location2 = location2; } public double calculateDistance() throws Exception { double distance = 0.0; double lat1 = degreesToRadians(location1.getLatitude()); double lat2 = degreesToRadians(location2.getLatitude()); double dLat = degreesToRadians(location2.getLatitude() - location1.getLatitude()); double dLong = degreesToRadians(location2.getLongitude() - location1.getLongitude()); double a = Math.sin(dLat / 2.0) * Math.sin(dLat / 2.0) + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLong / 2.0) * Math.sin(dLong / 2.0); double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); distance = radius * c; return distance; } public double degreesToRadians(double degrees) { double radians = 0.0; radians = degrees * Math.PI / 180.0; return radians; } public static void main(String[] args) throws Exception { Location loc1 = new Location(); loc1.setLatDegree(50); loc1.setLatMinutes(03); loc1.setLatSeconds(59); loc1.setLatDirection(\u0026#39;N\u0026#39;); loc1.setLongDegree(005); loc1.setLongMinutes(42); loc1.setLongSeconds(53); loc1.setLongDirection(\u0026#39;W\u0026#39;); Location loc2 = new Location(); loc2.setLatDegree(58); loc2.setLatMinutes(38); loc2.setLatSeconds(38); loc2.setLatDirection(\u0026#39;N\u0026#39;); loc2.setLongDegree(003); loc2.setLongMinutes(04); loc2.setLongSeconds(12); loc2.setLongDirection(\u0026#39;W\u0026#39;); System.out.println(new LocationOps(loc1, loc2).calculateDistance()); loc1.setLatString(\u0026#34;50 03 59 N\u0026#34;); loc1.setLongString(\u0026#34;005 42 53 W\u0026#34;); loc2.setLatString(\u0026#34;58 38 38 N\u0026#34;); loc2.setLongString(\u0026#34;003 04 12 W\u0026#34;); System.out.println(new LocationOps(loc1, loc2).calculateDistance()); } } ",
    "ref": "/blog/2015-03-11-java-program-to-find-the-distance-between-two-gps-locations/"
  },{
    "title": "Sum of Prime Numbers Between 1000000 and 1000100 Using Sieve of Eratosthenes",
    "date": "December 30, 2014",
    "description": "",
    "body": "For more information on Sieve of Eratosthenes please refer wikipedia page\n#include \u0026#34;stdio.h\u0026#34; #include \u0026#34;string.h\u0026#34; #include \u0026#34;stdlib.h\u0026#34; #include \u0026#34;assert.h\u0026#34; typedef unsigned long long biggerint; void findPrimeNumbers(biggerint start, biggerint end) { char * primeList = malloc(sizeof(unsigned char) * (end + 1)); int i; biggerint sum = 0; assert(primeList != NULL); /* set prime status */ for (i = 0; i \u0026lt;= end + 1 ; i++) { *(primeList + i) = 1; } primeList[0] = 0; primeList[1] = 0; /* mark all the non-prime numbers */ biggerint currentFactor = 2; biggerint lastSquare = 0; biggerint currentSquare = 0; while (currentFactor * currentFactor \u0026lt;= end) { /* mark all the multiples of the current factor */ biggerint mark = currentFactor + currentFactor; while (mark \u0026lt;= end) { *(primeList + mark) = 0; mark += currentFactor; } /* set currentFactor to next prime number */ currentFactor++; while (*(primeList+currentFactor) == 0) currentFactor++; assert(currentFactor \u0026lt;= end); } for(i = start; i \u0026lt;= end ; i++) { if(*(primeList + i)) sum += i; } free(primeList); printf(\u0026#34;%llu\\n\u0026#34;, sum); } int main(int argc, char *argv[]) { biggerint start = 1000000; biggerint end = 1000100; findPrimeNumbers(start, end); return 0; } ",
    "ref": "/blog/2014-12-30-sum-of-prime-numbers-between-1000000-and-1000100-using-sieve-of-eratosthenes/"
  },{
    "title": "AES Implementation In Java with ECB | CBC | OFB | CFB Modes Of Operation",
    "date": "July 30, 2014",
    "description": "",
    "body": "Note that these are ONLY basic level programs for easy understanding of the Advanced Encryption Standard (AES) algorithm\nKey Generation - AESkeygen.java\nimport java.io.File; import java.io.FileWriter; public class AESkeygen { private final File file = new File(\u0026#34;AESkey.txt\u0026#34;); private final int KEY_LENGTH = 32; private final static char[] hexArray = \u0026#34;0123456789ABCDEF\u0026#34;.toCharArray(); public AESkeygen() { try { FileWriter fileWriter = new FileWriter(file); fileWriter.write(\u0026#34;\u0026#34;); for (int i = 0; i \u0026lt; KEY_LENGTH; i++) { double random = Math.random(); int index = (int) (random * 16); fileWriter.append(hexArray[index]); fileWriter.flush(); } fileWriter.close(); System.out.println(\u0026#34;Key generated and saved in \u0026#34; + file.getName()); } catch (Exception exp) { exp.printStackTrace(); } } public static void main(String[] args) { new AESkeygen(); } } Word.java\npublic class Word { private byte[] word = null; public Word() { word = new byte[4]; } public Word(byte k0, byte k1, byte k2, byte k3) { this(); word[0] = k0; word[1] = k1; word[2] = k2; word[3] = k3; } public byte[] getWord() { return word; } public void setWord(byte[] word) { this.word = word; } public static byte[] wordToBytes(Word word) { return word.getWord(); } public static byte[] wordsToBytes(Word[] words) { byte[] out = new byte[4 * words.length]; for (int i = 0; i \u0026lt; words.length; i++) { byte[] temp = words[i].getWord(); out[4 * i] = temp[0]; out[4 * i + 1] = temp[1]; out[4 * i + 2] = temp[2]; out[4 * i + 3] = temp[3]; } return out; } public void rotWord() { byte[] temp = this.getWord(); byte[] newWord = new byte[4]; newWord[0] = temp[1]; newWord[1] = temp[2]; newWord[2] = temp[3]; newWord[3] = temp[0]; this.setWord(newWord); } public void subWord() { byte[] in = this.getWord(); byte[] out = new byte[4]; for (int i = 0; i \u0026lt; 4; i++) { byte a = in[i]; int row = (a \u0026gt;\u0026gt; 4) \u0026amp; 0x000F; int col = a \u0026amp; 0x000F; out[i] = (byte) AESencrypt.sBox[row * 16 + col]; } for (int i = 0; i \u0026lt; 4; i++) { this.word[i] = out[i]; } } public static Word XORWords(Word word1, Word word2) { Word outWord = new Word(); byte[] in1 = word1.getWord(); byte[] in2 = word2.getWord(); byte[] out = new byte[4]; for (int i = 0; i \u0026lt; 4; i++) { out[i] = (byte) ((in1[i] ^ in2[i]) \u0026amp; 0xff); } outWord.setWord(out); return outWord; } public String toString() { return AESencrypt.bytesToHex(this.getWord()); } }  Encryption - AESencrypt.java\nimport java.io.BufferedReader; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.FileReader; import java.util.Arrays; public class AESencrypt { private static final int BITS = 16; private static final int ROUNDS = 10; private static final int NO_OF_WORDS_IN_KEY = 44; private static final int KEY_LENGTH = 16; private static final int BLOCK_LENGTH = 16; final protected static char[] hexArray = \u0026#34;0123456789ABCDEF\u0026#34;.toCharArray(); int[] RC = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36 }; Word[] Rcon = new Word[ROUNDS]; private byte[] word = null; private String mode = null; static final int[] sBox = { 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 }; static final int[] invSBox = { 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d }; public AESencrypt(String mode) { this.mode = mode; for (int i = 0; i \u0026lt; ROUNDS; i++) { Rcon[i] = new Word(); byte[] temp = new byte[4]; temp[0] = (byte) (RC[i] \u0026amp; 0xff); temp[1] = 0; temp[2] = 0; temp[3] = 0; Rcon[i].setWord(temp); } word = new byte[NO_OF_WORDS_IN_KEY]; } /* Ref: http://www.samiam.org/galois.html */ /* Galois Addition */ byte gadd(byte a, byte b) { return (byte) ((a ^ b) \u0026amp; 0xff); } /* Galois Subtraction */ byte gsub(byte a, byte b) { return (byte) ((a ^ b) \u0026amp; 0xff); } /* Galois Multiplication */ byte gmul(byte a, byte b) { byte p = 0; int counter; byte high_bit_set; byte byte0x80 = hexStringToByteArray(\u0026#34;80\u0026#34;)[0]; for (counter = 0; counter \u0026lt; 8; counter++) { if ((b \u0026amp; 0x01) == 1) { // System.out.println(\u0026#34;lower bit of b is set\u0026#34;);  p = (byte) ((p ^ a) \u0026amp; 0xff); } high_bit_set = (byte) (a \u0026amp; 0x80); // printByte(\u0026#34;high_bit_set\u0026#34;, high_bit_set);  a \u0026lt;\u0026lt;= 1; if (high_bit_set == byte0x80) { // System.out.println(\u0026#34;higher bit of a is set\u0026#34;);  a = (byte) ((a ^ 0x1b) \u0026amp; 0xff); } b = (byte) ((b \u0026gt;\u0026gt; 1) \u0026amp; 0x7f); // printByte(\u0026#34;a\u0026#34;, a);  // printByte(\u0026#34;b\u0026#34;, b);  // printByte(\u0026#34;p\u0026#34;, p);  } return p; } byte gmul(byte a, int b) { byte t = (byte) (b \u0026amp; 0xff); return gmul(a, t); } /* Key Expansion */ private byte[] expandKey(byte[] key) throws Exception { // System.out.println(key.length);  // System.out.println(bytesToHex(key));  if (key.length != KEY_LENGTH) { throw new Exception(\u0026#34;Key should be of length, 128 bits\u0026#34;); } Word[] w = new Word[NO_OF_WORDS_IN_KEY]; Word temp; for (int i = 0; i \u0026lt; 4; i++) { w[i] = new Word(key[4 * i], key[4 * i + 1], key[4 * i + 2], key[4 * i + 3]); // System.out.println(\u0026#34;w\u0026#34; + i + \u0026#34; = \u0026#34; + w[i]);  } for (int i = 4; i \u0026lt; 44; i++) { temp = w[i - 1]; Word temp1 = new Word(); temp1.setWord(temp.getWord()); // System.out.println(\u0026#34;w\u0026#34; + (i-1) + \u0026#34; = \u0026#34; + temp);  if (i % 4 == 0) { temp1.rotWord(); // System.out.println(\u0026#34;Rot=\u0026#34; + temp1);  temp1.subWord(); // System.out.println(\u0026#34;Sub=\u0026#34; + temp1);  temp1 = Word.XORWords(temp1, Rcon[(i / 4) - 1]); // System.out.println(\u0026#34;Rcon\u0026#34; + temp1);  } w[i] = Word.XORWords(w[i - 4], temp1); // System.out.println(\u0026#34;w\u0026#34; + i + \u0026#34; = \u0026#34; + w[i]);  } return Word.wordsToBytes(w); } /* Substitute Bytes */ private byte[] subBytes(byte[] in) { byte[] out = new byte[BITS]; for (int i = 0; i \u0026lt; BITS; i++) { byte a = in[i]; int row = (a \u0026gt;\u0026gt; 4) \u0026amp; 0x000F; int col = a \u0026amp; 0x000F; out[i] = (byte) sBox[row * BITS + col]; } return out; } /* Inverse Substitute Bytes */ private byte[] inverseSubBytes(byte[] in) { byte[] out = new byte[BITS]; for (int i = 0; i \u0026lt; BITS; i++) { byte a = in[i]; int row = (a \u0026gt;\u0026gt; 4) \u0026amp; 0x000F; int col = a \u0026amp; 0x000F; out[i] = (byte) invSBox[row * BITS + col]; } return out; } /* Shift Rows */ private byte[] shiftRows(byte[] in) { byte[] out = new byte[BITS]; byte[] temp = new byte[BITS]; for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { temp[4 * j + i] = in[4 * i + j]; } } // System.out.println(\u0026#34;temp: \u0026#34; + bytesToHex(temp));  for (int i = 0; i \u0026lt; BITS / 4; i++) { byte[] a = Arrays.copyOfRange(temp, (4 * i), (4 * i + 4)); byte[] b = leftShift(a, i); in[4 * i] = b[0]; in[4 * i + 1] = b[1]; in[4 * i + 2] = b[2]; in[4 * i + 3] = b[3]; } for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { out[4 * j + i] = in[4 * i + j]; } } return out; } private byte[] leftShift(byte[] in, int times) { byte[] out = new byte[4]; out = Arrays.copyOfRange(in, 0, 4); for (int i = 0; i \u0026lt; times; i++) { out[0] = in[1]; out[1] = in[2]; out[2] = in[3]; out[3] = in[0]; in = Arrays.copyOfRange(out, 0, 4); } return out; } /* Inverse Shift Rows */ private byte[] inverseShiftRows(byte[] in) { byte[] out = new byte[BITS]; byte[] temp = new byte[BITS]; for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { temp[4 * j + i] = in[4 * i + j]; } } for (int i = 0; i \u0026lt; BITS / 4; i++) { byte[] a = Arrays.copyOfRange(temp, (4 * i), (4 * i + 4)); byte[] b = rightShift(a, i); in[4 * i] = b[0]; in[4 * i + 1] = b[1]; in[4 * i + 2] = b[2]; in[4 * i + 3] = b[3]; } for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { out[4 * j + i] = in[4 * i + j]; } } return out; } private byte[] rightShift(byte[] in, int times) { byte[] out = new byte[4]; out = Arrays.copyOfRange(in, 0, 4); for (int i = 0; i \u0026lt; times; i++) { out[0] = in[3]; out[1] = in[0]; out[2] = in[1]; out[3] = in[2]; in = Arrays.copyOfRange(out, 0, 4); } return out; } /* Mix Columns */ private byte[] mixColumns(byte[] in) { byte[] out = new byte[BITS]; byte[] temp = new byte[BITS]; for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { temp[4 * j + i] = in[4 * i + j]; } } in = temp; for (int j = 0; j \u0026lt; BITS / 4; j++) { out[4 * 0 + j] = (byte) ((gmul(in[4 * 0 + j], 2) ^ gmul(in[4 * 1 + j], 3) ^ in[4 * 2 + j] ^ in[4 * 3 + j]) \u0026amp; 0xff); out[4 * 1 + j] = (byte) ((in[4 * 0 + j] ^ gmul(in[4 * 1 + j], 2) ^ gmul(in[4 * 2 + j], 3) ^ in[4 * 3 + j]) \u0026amp; 0xff); out[4 * 2 + j] = (byte) ((in[4 * 0 + j] ^ in[4 * 1 + j] ^ gmul(in[4 * 2 + j], 2) ^ gmul(in[4 * 3 + j], 3)) \u0026amp; 0xff); out[4 * 3 + j] = (byte) ((gmul(in[4 * 0 + j], 3) ^ in[4 * 1 + j] ^ in[4 * 2 + j] ^ gmul(in[4 * 3 + j], 2)) \u0026amp; 0xff); } for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { temp[4 * j + i] = out[4 * i + j]; } } out = temp; return out; } /* Inverse Mix Columns */ private byte[] inverseMixColumns(byte[] in) { byte[] out = new byte[BITS]; byte[] temp = new byte[BITS]; for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { temp[4 * j + i] = in[4 * i + j]; } } in = temp; for (int j = 0; j \u0026lt; BITS / 4; j++) { out[4 * 0 + j] = (byte) ((gmul(in[4 * 0 + j], 14) ^ gmul(in[4 * 1 + j], 11) ^ gmul(in[4 * 2 + j], 13) ^ gmul(in[4 * 3 + j], 9)) \u0026amp; 0xff); out[4 * 1 + j] = (byte) ((gmul(in[4 * 0 + j], 9) ^ gmul(in[4 * 1 + j], 14) ^ gmul(in[4 * 2 + j], 11) ^ gmul(in[4 * 3 + j], 13)) \u0026amp; 0xff); out[4 * 2 + j] = (byte) ((gmul(in[4 * 0 + j], 13) ^ gmul(in[4 * 1 + j], 9) ^ gmul(in[4 * 2 + j], 14) ^ gmul(in[4 * 3 + j], 11)) \u0026amp; 0xff); out[4 * 3 + j] = (byte) ((gmul(in[4 * 0 + j], 11) ^ gmul(in[4 * 1 + j], 13) ^ gmul(in[4 * 2 + j], 9) ^ gmul(in[4 * 3 + j], 14)) \u0026amp; 0xff); } for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { temp[4 * j + i] = out[4 * i + j]; } } out = temp; return out; } private byte[] hexStringToByteArray(String string) { int length = string.length(); int n = (int) Math.ceil((length + 1) / 2); byte[] result = new byte[n]; for (int i = length - 1; i \u0026gt;= 0; i -= 2) { if (i == 0) { result[i / 2] = (byte) ((Character.digit(\u0026#39;0\u0026#39;, 16) \u0026lt;\u0026lt; 4) + Character.digit(string.charAt(i), 16)); } else { result[i / 2] = (byte) ((Character.digit(string.charAt(i - 1), 16) \u0026lt;\u0026lt; 4) + Character.digit(string.charAt(i), 16)); } } return result; } /* * http://stackoverflow.com/questions/9655181/convert-from-byte-array-to-hex- * string-in-java */ public static String bytesToHex(byte[] bytes) { char[] hexChars = new char[bytes.length * 2]; for (int j = 0; j \u0026lt; bytes.length; j++) { int v = bytes[j] \u0026amp; 0xFF; hexChars[j * 2] = hexArray[v \u0026gt;\u0026gt;\u0026gt; 4]; hexChars[j * 2 + 1] = hexArray[v \u0026amp; 0x0F]; } return new String(hexChars); } private void printBytes(byte[] input) { for (int i = 0; i \u0026lt; input.length; i++) { System.out.print(byteToBits(input[i]) + \u0026#34; \u0026#34;); } System.out.println(); } private void printByte(String msg, byte input) { byte[] temp = new byte[1]; temp[0] = input; System.out.println(msg + \u0026#34;: \u0026#34; + bytesToHex(temp)); } private String byteToBits(byte b) { StringBuffer buffer = new StringBuffer(); for (int i = 0; i \u0026lt; 8; i++) buffer.append((int) (b \u0026gt;\u0026gt; (8 - (i + 1)) \u0026amp; 0x0001)); return buffer.toString(); } private byte[] getRoundKey(int round) { byte[] out = new byte[KEY_LENGTH]; out = Arrays.copyOfRange(word, 16 * round, 16 * round + 16); return out; } public static byte[] XORBytes(byte[] in1, byte[] in2) { byte[] out = new byte[in1.length]; for (int i = 0; i \u0026lt; in1.length; i++) { out[i] = (byte) ((in1[i] ^ in2[i]) \u0026amp; 0xff); } return out; } public byte[] encryptText(byte[] plainText, byte[] key) throws Exception { byte[] cipher = new byte[BLOCK_LENGTH]; this.word = expandKey(key); byte[] roundKey = getRoundKey(0); /* Round 0 */ cipher = XORBytes(plainText, roundKey); // System.out.println(\u0026#34;Round 0\\n\u0026#34; + bytesToHex(cipher));  /* Rounds 1 to 9 */ for (int i = 1; i \u0026lt; 10; i++) { // System.out.println(\u0026#34;Round \u0026#34; + i);  cipher = subBytes(cipher); // System.out.println(\u0026#34;SubBytes: \u0026#34; + bytesToHex(cipher));  cipher = shiftRows(cipher); // System.out.println(\u0026#34;ShiftRows: \u0026#34; + bytesToHex(cipher));  cipher = mixColumns(cipher); // System.out.println(\u0026#34;MixColumns: \u0026#34; + bytesToHex(cipher));  roundKey = getRoundKey(i); // System.out.println(\u0026#34;RoundKey: \u0026#34; + bytesToHex(roundKey));  cipher = XORBytes(cipher, roundKey); // System.out.println(\u0026#34;CIPHER: \u0026#34; + bytesToHex(cipher));  } /* Round 10 */ // System.out.println(\u0026#34;Round 10\u0026#34;);  cipher = subBytes(cipher); // System.out.println(\u0026#34;SubBytes: \u0026#34; + bytesToHex(cipher));  cipher = shiftRows(cipher); // System.out.println(\u0026#34;ShiftRows: \u0026#34; + bytesToHex(cipher));  roundKey = getRoundKey(10); // System.out.println(\u0026#34;RoundKey: \u0026#34; + bytesToHex(roundKey));  cipher = XORBytes(cipher, roundKey); // System.out.println(\u0026#34;CIPHER: \u0026#34; + bytesToHex(cipher));  return cipher; } public byte[] decryptText(byte[] cipher, byte[] key) throws Exception { byte[] plainText = new byte[BLOCK_LENGTH]; this.word = expandKey(key); byte[] roundKey = getRoundKey(10); /* Round 0 */ plainText = XORBytes(cipher, roundKey); /* Rounds 1 to 9 */ for (int i = 9; i \u0026gt; 0; i--) { plainText = inverseShiftRows(plainText); plainText = inverseSubBytes(plainText); roundKey = getRoundKey(i); plainText = XORBytes(plainText, roundKey); plainText = inverseMixColumns(plainText); } /* Round 10 */ plainText = inverseShiftRows(plainText); plainText = inverseSubBytes(plainText); roundKey = getRoundKey(0); plainText = XORBytes(plainText, roundKey); return plainText; } public static void main(String[] args) throws Exception { try { if (args.length != 1) { System.out.println(\u0026#34;Usage: java \u0026lt; classname \u0026gt; \u0026lt; mode \u0026gt;\u0026#34; + \u0026#34;\\n\\t\u0026lt; mode \u0026gt; := (ECB|CBC|OFB|CFB)\u0026#34;); return; } /* ECB, CBC, OFB, or CFB */ String mode = args[0]; // String mode = \u0026#34;CFB\u0026#34;;  mode = mode.toUpperCase(); AESencrypt aes = new AESencrypt(mode); File keyFile = new File(\u0026#34;AESkey.txt\u0026#34;); File textFile = new File(\u0026#34;AESplaintext.txt\u0026#34;); File cipherFile = new File(\u0026#34;AESciphertext.txt\u0026#34;); FileReader keyFileReader = new FileReader(keyFile); BufferedReader bufferedReader = new BufferedReader(keyFileReader); FileInputStream textFileInputStream = new FileInputStream(textFile); FileOutputStream cipherFileOutputStream = new FileOutputStream(cipherFile); byte[] key = new byte[(int) keyFile.length()]; String keyString = bufferedReader.readLine(); key = aes.hexStringToByteArray(keyString); byte[] message = new byte[(int) textFile.length()]; textFileInputStream.read(message); byte[] cipher = aes.encrypt(message, key); cipherFileOutputStream.write(cipher); cipherFileOutputStream.flush(); cipherFileOutputStream.close(); bufferedReader.close(); textFileInputStream.close(); System.out.println(\u0026#34;Encryption done! Please check AESciphertext.txt for output!\u0026#34;); } catch (Exception exp) { exp.printStackTrace(); } } private byte[] encrypt(byte[] message, byte[] key) throws Exception { if (message.length \u0026lt; 16) { System.out.println(\u0026#34;Message should be atleast 64 bits\u0026#34;); System.exit(1); } if (key.length != 16) { System.out.println(\u0026#34;Key should be 64 bits\u0026#34;); System.exit(1); } int length = message.length; int n = (length + 15) / 16 * 16; byte[] cipher = new byte[n]; if (length == 16) { if (mode.equals(\u0026#34;ECB\u0026#34;)) { return encryptText(message, key); } else if (mode.equals(\u0026#34;CBC\u0026#34;)) { byte[] iv = getInitializationVector(); message = XORBytes(message, iv); return encryptText(message, key); } else if (mode.equals(\u0026#34;OFB\u0026#34;)) { byte[] nounce = getNounce(); byte[] temp = encryptText(nounce, key); byte[] result = XORBytes(temp, message); return result; } else if (mode.equals(\u0026#34;CFB\u0026#34;)) { } else { System.out.println(\u0026#34;Unsupported mode of operation!\u0026#34;); return null; } } int i = 0; int k = 0; byte[] feedback = new byte[16]; if (mode.equals(\u0026#34;CBC\u0026#34;)) { feedback = getInitializationVector(); } else if (mode.equals(\u0026#34;OFB\u0026#34;)) { feedback = getNounce(); } else if (mode.equals(\u0026#34;CFB\u0026#34;)) { feedback = getInitializationVectorCFB(); } while (i \u0026lt; length) { byte[] block = new byte[16]; byte[] result = new byte[16]; int j = 0; for (; j \u0026lt; 16 \u0026amp;\u0026amp; i \u0026lt; length; j++, i++) { block[j] = message[i]; } while (j \u0026lt; 16) { /* pad with white spaces */ block[j++] = 0x20; } // System.out.println(\u0026#34;BLOCK: \u0026#34;);  // printBytes(block);  if (mode.equals(\u0026#34;ECB\u0026#34;)) { result = encryptText(block, key); } else if (mode.equals(\u0026#34;CBC\u0026#34;)) { block = XORBytes(block, feedback); result = encryptText(block, key); feedback = Arrays.copyOfRange(result, 0, 16); } else if (mode.equals(\u0026#34;OFB\u0026#34;)) { result = encryptText(feedback, key); feedback = Arrays.copyOfRange(result, 0, 16); result = XORBytes(result, block); } else if (mode.equals(\u0026#34;CFB\u0026#34;)) { result = encryptText(feedback, key); byte[] resultPart = Arrays.copyOfRange(result, 0, 8); byte[] blockPart = Arrays.copyOfRange(block, 0, 8); byte[] temp1 = XORBytes(resultPart, blockPart); feedback = mergeBytes(Arrays.copyOfRange(result, 8, 16), temp1); resultPart = Arrays.copyOfRange(result, 8, 16); blockPart = Arrays.copyOfRange(block, 8, 16); result = encryptText(feedback, key); byte[] temp2 = XORBytes(resultPart, blockPart); feedback = mergeBytes(Arrays.copyOfRange(result, 8, 16), temp2); result = mergeBytes(temp1, temp2); } else { System.out.println(\u0026#34;Unsupported mode of operation!\u0026#34;); return null; } // System.out.println(\u0026#34;RESULT: \u0026#34;);  // printBytes(result);  for (j = 0; j \u0026lt; 16 \u0026amp;\u0026amp; k \u0026lt; cipher.length; j++, k++) { cipher[k] = result[j]; } } return cipher; } private byte[] getInitializationVector() { return hexStringToByteArray(\u0026#34;247D8AC4DDB1AA739DC593821D0BC432\u0026#34;); } private byte[] getInitializationVectorCFB() { return hexStringToByteArray(\u0026#34;247D8AC4DDB1AA739DC593821D0BC432\u0026#34;); } private byte[] getNounce() { // char[] hexArray = \u0026#34;0123456789ABCDEF\u0026#34;.toCharArray();  // String nounceStr = \u0026#34;\u0026#34;;  // for (int i = 0 ; i \u0026lt; 16 ; i++) {  // double random = Math.random();  // int index = (int) (random * 16);  // nounceStr += hexArray[index];  // }  // return hexStringToByteArray(nounceStr);  return hexStringToByteArray(\u0026#34;247D8AC4DDB1AA739DC593821D0BC432\u0026#34;); } private byte[] mergeBytes(byte[] in1, byte[] in2) { byte[] out = new byte[in1.length + in2.length]; int i = 0; for (int j = 0; j \u0026lt; in1.length; j++) { out[i++] = in1[j]; } for (int j = 0; j \u0026lt; in2.length; j++) { out[i++] = in2[j]; } return out; } } Decryption - AESdecrypt.java\nimport java.io.BufferedReader; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.FileReader; import java.util.Arrays; public class AESdecrypt { private static final int BITS = 16; private static final int ROUNDS = 10; private static final int NO_OF_WORDS_IN_KEY = 44; private static final int KEY_LENGTH = 16; private static final int BLOCK_LENGTH = 16; final protected static char[] hexArray = \u0026#34;0123456789ABCDEF\u0026#34;.toCharArray(); int[] RC = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36 }; Word[] Rcon = new Word[ROUNDS]; private byte[] word = null; private String mode = null; static final int[] sBox = { 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 }; static final int[] invSBox = { 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d }; public AESdecrypt(String mode) { this.mode = mode; for (int i = 0; i \u0026lt; ROUNDS; i++) { Rcon[i] = new Word(); byte[] temp = new byte[4]; temp[0] = (byte) (RC[i] \u0026amp; 0xff); temp[1] = 0; temp[2] = 0; temp[3] = 0; Rcon[i].setWord(temp); } word = new byte[NO_OF_WORDS_IN_KEY]; } /* Ref: http://www.samiam.org/galois.html */ /* Galois Addition */ byte gadd(byte a, byte b) { return (byte) ((a ^ b) \u0026amp; 0xff); } /* Galois Subtraction */ byte gsub(byte a, byte b) { return (byte) ((a ^ b) \u0026amp; 0xff); } /* Galois Multiplication */ byte gmul(byte a, byte b) { byte p = 0; int counter; byte high_bit_set; byte byte0x80 = hexStringToByteArray(\u0026#34;80\u0026#34;)[0]; for (counter = 0; counter \u0026lt; 8; counter++) { if ((b \u0026amp; 0x01) == 1) { // System.out.println(\u0026#34;lower bit of b is set\u0026#34;);  p = (byte) ((p ^ a) \u0026amp; 0xff); } high_bit_set = (byte) (a \u0026amp; 0x80); // printByte(\u0026#34;high_bit_set\u0026#34;, high_bit_set);  a \u0026lt;\u0026lt;= 1; if (high_bit_set == byte0x80) { // System.out.println(\u0026#34;higher bit of a is set\u0026#34;);  a = (byte) ((a ^ 0x1b) \u0026amp; 0xff); } b = (byte) ((b \u0026gt;\u0026gt; 1) \u0026amp; 0x7f); // printByte(\u0026#34;a\u0026#34;, a);  // printByte(\u0026#34;b\u0026#34;, b);  // printByte(\u0026#34;p\u0026#34;, p);  } return p; } byte gmul(byte a, int b) { byte t = (byte) (b \u0026amp; 0xff); return gmul(a, t); } /* Key Expansion */ private byte[] expandKey(byte[] key) throws Exception { // System.out.println(key.length);  // System.out.println(bytesToHex(key));  if (key.length != KEY_LENGTH) { throw new Exception(\u0026#34;Key should be of length, 128 bits\u0026#34;); } Word[] w = new Word[NO_OF_WORDS_IN_KEY]; Word temp; for (int i = 0; i \u0026lt; 4; i++) { w[i] = new Word(key[4 * i], key[4 * i + 1], key[4 * i + 2], key[4 * i + 3]); // System.out.println(\u0026#34;w\u0026#34; + i + \u0026#34; = \u0026#34; + w[i]);  } for (int i = 4; i \u0026lt; 44; i++) { temp = w[i - 1]; Word temp1 = new Word(); temp1.setWord(temp.getWord()); // System.out.println(\u0026#34;w\u0026#34; + (i-1) + \u0026#34; = \u0026#34; + temp);  if (i % 4 == 0) { temp1.rotWord(); // System.out.println(\u0026#34;Rot=\u0026#34; + temp1);  temp1.subWord(); // System.out.println(\u0026#34;Sub=\u0026#34; + temp1);  temp1 = Word.XORWords(temp1, Rcon[(i / 4) - 1]); // System.out.println(\u0026#34;Rcon\u0026#34; + temp1);  } w[i] = Word.XORWords(w[i - 4], temp1); // System.out.println(\u0026#34;w\u0026#34; + i + \u0026#34; = \u0026#34; + w[i]);  } return Word.wordsToBytes(w); } /* Substitute Bytes */ private byte[] subBytes(byte[] in) { byte[] out = new byte[BITS]; for (int i = 0; i \u0026lt; BITS; i++) { byte a = in[i]; int row = (a \u0026gt;\u0026gt; 4) \u0026amp; 0x000F; int col = a \u0026amp; 0x000F; out[i] = (byte) sBox[row * BITS + col]; } return out; } /* Inverse Substitute Bytes */ private byte[] inverseSubBytes(byte[] in) { byte[] out = new byte[BITS]; for (int i = 0; i \u0026lt; BITS; i++) { byte a = in[i]; int row = (a \u0026gt;\u0026gt; 4) \u0026amp; 0x000F; int col = a \u0026amp; 0x000F; out[i] = (byte) invSBox[row * BITS + col]; } return out; } /* Shift Rows */ private byte[] shiftRows(byte[] in) { byte[] out = new byte[BITS]; byte[] temp = new byte[BITS]; for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { temp[4 * j + i] = in[4 * i + j]; } } // System.out.println(\u0026#34;temp: \u0026#34; + bytesToHex(temp));  for (int i = 0; i \u0026lt; BITS / 4; i++) { byte[] a = Arrays.copyOfRange(temp, (4 * i), (4 * i + 4)); byte[] b = leftShift(a, i); in[4 * i] = b[0]; in[4 * i + 1] = b[1]; in[4 * i + 2] = b[2]; in[4 * i + 3] = b[3]; } for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { out[4 * j + i] = in[4 * i + j]; } } return out; } private byte[] leftShift(byte[] in, int times) { byte[] out = new byte[4]; out = Arrays.copyOfRange(in, 0, 4); for (int i = 0; i \u0026lt; times; i++) { out[0] = in[1]; out[1] = in[2]; out[2] = in[3]; out[3] = in[0]; in = Arrays.copyOfRange(out, 0, 4); } return out; } /* Inverse Shift Rows */ private byte[] inverseShiftRows(byte[] in) { byte[] out = new byte[BITS]; byte[] temp = new byte[BITS]; for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { temp[4 * j + i] = in[4 * i + j]; } } for (int i = 0; i \u0026lt; BITS / 4; i++) { byte[] a = Arrays.copyOfRange(temp, (4 * i), (4 * i + 4)); byte[] b = rightShift(a, i); in[4 * i] = b[0]; in[4 * i + 1] = b[1]; in[4 * i + 2] = b[2]; in[4 * i + 3] = b[3]; } for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { out[4 * j + i] = in[4 * i + j]; } } return out; } private byte[] rightShift(byte[] in, int times) { byte[] out = new byte[4]; out = Arrays.copyOfRange(in, 0, 4); for (int i = 0; i \u0026lt; times; i++) { out[0] = in[3]; out[1] = in[0]; out[2] = in[1]; out[3] = in[2]; in = Arrays.copyOfRange(out, 0, 4); } return out; } /* Mix Columns */ private byte[] mixColumns(byte[] in) { byte[] out = new byte[BITS]; byte[] temp = new byte[BITS]; for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { temp[4 * j + i] = in[4 * i + j]; } } in = temp; for (int j = 0; j \u0026lt; BITS / 4; j++) { out[4 * 0 + j] = (byte) ((gmul(in[4 * 0 + j], 2) ^ gmul(in[4 * 1 + j], 3) ^ in[4 * 2 + j] ^ in[4 * 3 + j]) \u0026amp; 0xff); out[4 * 1 + j] = (byte) ((in[4 * 0 + j] ^ gmul(in[4 * 1 + j], 2) ^ gmul(in[4 * 2 + j], 3) ^ in[4 * 3 + j]) \u0026amp; 0xff); out[4 * 2 + j] = (byte) ((in[4 * 0 + j] ^ in[4 * 1 + j] ^ gmul(in[4 * 2 + j], 2) ^ gmul(in[4 * 3 + j], 3)) \u0026amp; 0xff); out[4 * 3 + j] = (byte) ((gmul(in[4 * 0 + j], 3) ^ in[4 * 1 + j] ^ in[4 * 2 + j] ^ gmul(in[4 * 3 + j], 2)) \u0026amp; 0xff); } for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { temp[4 * j + i] = out[4 * i + j]; } } out = temp; return out; } /* Inverse Mix Columns */ private byte[] inverseMixColumns(byte[] in) { byte[] out = new byte[BITS]; byte[] temp = new byte[BITS]; for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { temp[4 * j + i] = in[4 * i + j]; } } in = temp; for (int j = 0; j \u0026lt; BITS / 4; j++) { out[4 * 0 + j] = (byte) ((gmul(in[4 * 0 + j], 14) ^ gmul(in[4 * 1 + j], 11) ^ gmul(in[4 * 2 + j], 13) ^ gmul(in[4 * 3 + j], 9)) \u0026amp; 0xff); out[4 * 1 + j] = (byte) ((gmul(in[4 * 0 + j], 9) ^ gmul(in[4 * 1 + j], 14) ^ gmul(in[4 * 2 + j], 11) ^ gmul(in[4 * 3 + j], 13)) \u0026amp; 0xff); out[4 * 2 + j] = (byte) ((gmul(in[4 * 0 + j], 13) ^ gmul(in[4 * 1 + j], 9) ^ gmul(in[4 * 2 + j], 14) ^ gmul(in[4 * 3 + j], 11)) \u0026amp; 0xff); out[4 * 3 + j] = (byte) ((gmul(in[4 * 0 + j], 11) ^ gmul(in[4 * 1 + j], 13) ^ gmul(in[4 * 2 + j], 9) ^ gmul(in[4 * 3 + j], 14)) \u0026amp; 0xff); } for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { temp[4 * j + i] = out[4 * i + j]; } } out = temp; return out; } private byte[] hexStringToByteArray(String string) { int length = string.length(); int n = (int) Math.ceil((length + 1) / 2); byte[] result = new byte[n]; for (int i = length - 1; i \u0026gt;= 0; i -= 2) { if (i == 0) { result[i / 2] = (byte) ((Character.digit(\u0026#39;0\u0026#39;, 16) \u0026lt;\u0026lt; 4) + Character.digit(string.charAt(i), 16)); } else { result[i / 2] = (byte) ((Character.digit(string.charAt(i - 1), 16) \u0026lt;\u0026lt; 4) + Character.digit(string.charAt(i), 16)); } } return result; } /* * http://stackoverflow.com/questions/9655181/convert-from-byte-array-to-hex- * string-in-java */ public static String bytesToHex(byte[] bytes) { char[] hexChars = new char[bytes.length * 2]; for (int j = 0; j \u0026lt; bytes.length; j++) { int v = bytes[j] \u0026amp; 0xFF; hexChars[j * 2] = hexArray[v \u0026gt;\u0026gt;\u0026gt; 4]; hexChars[j * 2 + 1] = hexArray[v \u0026amp; 0x0F]; } return new String(hexChars); } private void printBytes(byte[] input) { for (int i = 0; i \u0026lt; input.length; i++) { System.out.print(byteToBits(input[i]) + \u0026#34; \u0026#34;); } System.out.println(); } private void printByte(String msg, byte input) { byte[] temp = new byte[1]; temp[0] = input; System.out.println(msg + \u0026#34;: \u0026#34; + bytesToHex(temp)); } private String byteToBits(byte b) { StringBuffer buffer = new StringBuffer(); for (int i = 0; i \u0026lt; 8; i++) buffer.append((int) (b \u0026gt;\u0026gt; (8 - (i + 1)) \u0026amp; 0x0001)); return buffer.toString(); } private byte[] getRoundKey(int round) { byte[] out = new byte[KEY_LENGTH]; out = Arrays.copyOfRange(word, 16 * round, 16 * round + 16); return out; } public static byte[] XORBytes(byte[] in1, byte[] in2) { byte[] out = new byte[in1.length]; for (int i = 0; i \u0026lt; in1.length; i++) { out[i] = (byte) ((in1[i] ^ in2[i]) \u0026amp; 0xff); } return out; } public byte[] encryptText(byte[] plainText, byte[] key) throws Exception { byte[] cipher = new byte[BLOCK_LENGTH]; this.word = expandKey(key); byte[] roundKey = getRoundKey(0); /* Round 0 */ cipher = XORBytes(plainText, roundKey); // System.out.println(\u0026#34;Round 0\\n\u0026#34; + bytesToHex(cipher));  /* Rounds 1 to 9 */ for (int i = 1; i \u0026lt; 10; i++) { // System.out.println(\u0026#34;Round \u0026#34; + i);  cipher = subBytes(cipher); // System.out.println(\u0026#34;SubBytes: \u0026#34; + bytesToHex(cipher));  cipher = shiftRows(cipher); // System.out.println(\u0026#34;ShiftRows: \u0026#34; + bytesToHex(cipher));  cipher = mixColumns(cipher); // System.out.println(\u0026#34;MixColumns: \u0026#34; + bytesToHex(cipher));  roundKey = getRoundKey(i); // System.out.println(\u0026#34;RoundKey: \u0026#34; + bytesToHex(roundKey));  cipher = XORBytes(cipher, roundKey); // System.out.println(\u0026#34;CIPHER: \u0026#34; + bytesToHex(cipher));  } /* Round 10 */ // System.out.println(\u0026#34;Round 10\u0026#34;);  cipher = subBytes(cipher); // System.out.println(\u0026#34;SubBytes: \u0026#34; + bytesToHex(cipher));  cipher = shiftRows(cipher); // System.out.println(\u0026#34;ShiftRows: \u0026#34; + bytesToHex(cipher));  roundKey = getRoundKey(10); // System.out.println(\u0026#34;RoundKey: \u0026#34; + bytesToHex(roundKey));  cipher = XORBytes(cipher, roundKey); // System.out.println(\u0026#34;CIPHER: \u0026#34; + bytesToHex(cipher));  return cipher; } public byte[] decryptText(byte[] cipher, byte[] key) throws Exception { byte[] plainText = new byte[BLOCK_LENGTH]; this.word = expandKey(key); byte[] roundKey = getRoundKey(10); /* Round 0 */ plainText = XORBytes(cipher, roundKey); /* Rounds 1 to 9 */ for (int i = 9; i \u0026gt; 0; i--) { plainText = inverseShiftRows(plainText); plainText = inverseSubBytes(plainText); roundKey = getRoundKey(i); plainText = XORBytes(plainText, roundKey); plainText = inverseMixColumns(plainText); } /* Round 10 */ plainText = inverseShiftRows(plainText); plainText = inverseSubBytes(plainText); roundKey = getRoundKey(0); plainText = XORBytes(plainText, roundKey); return plainText; } public static void main(String[] args) throws Exception { try { if (args.length != 1) { System.out.println(\u0026#34;Usage: java \u0026lt; classname \u0026gt; \u0026lt; mode \u0026gt;\u0026#34; + \u0026#34;\\n\\t\u0026lt; mode \u0026gt; := (ECB|CBC|OFB|CFB)\u0026#34;); return; } /* ECB, CBC, OFB, or CFB */ String mode = args[0]; // String mode = \u0026#34;CFB\u0026#34;;  mode = mode.toUpperCase(); AESdecrypt aes = new AESdecrypt(mode); File keyFile = new File(\u0026#34;AESkey.txt\u0026#34;); File textFile = new File(\u0026#34;AESplaintext.txt\u0026#34;); File cipherFile = new File(\u0026#34;AESciphertext.txt\u0026#34;); FileReader keyFileReader = new FileReader(keyFile); BufferedReader bufferedReader = new BufferedReader(keyFileReader); FileInputStream cipherFileInputStream = new FileInputStream(cipherFile); FileOutputStream textFileOutputStream = new FileOutputStream(textFile); byte[] key = new byte[(int) keyFile.length()]; String keyString = bufferedReader.readLine(); key = aes.hexStringToByteArray(keyString); byte[] cipher = new byte[(int) cipherFile.length()]; cipherFileInputStream.read(cipher); byte[] message = aes.decrypt(cipher, key); textFileOutputStream.write(message); textFileOutputStream.flush(); textFileOutputStream.close(); bufferedReader.close(); cipherFileInputStream.close(); System.out.println(\u0026#34;Decryption done! Please check AESplaintext.txt for output!\u0026#34;); } catch (Exception exp) { exp.printStackTrace(); } } private byte[] decrypt(byte[] message, byte[] key) throws Exception { if (message.length \u0026lt; 16) { System.out.println(\u0026#34;Message should be atleast 64 bits\u0026#34;); System.exit(1); } if (key.length != 16) { System.out.println(\u0026#34;Key should be 64 bits\u0026#34;); System.exit(1); } int length = message.length; int n = (length + 15) / 16 * 16; byte[] cipher = new byte[n]; if (length == 16) { if (mode.equals(\u0026#34;ECB\u0026#34;)) { return decryptText(message, key); } else if (mode.equals(\u0026#34;CBC\u0026#34;)) { byte[] iv = getInitializationVector(); message = XORBytes(message, iv); return decryptText(message, key); } else if (mode.equals(\u0026#34;OFB\u0026#34;)) { byte[] nounce = getNounce(); byte[] temp = encryptText(nounce, key); byte[] result = XORBytes(temp, message); return result; } else if (mode.equals(\u0026#34;CFB\u0026#34;)) { } else { System.out.println(\u0026#34;Unsupported mode of operation!\u0026#34;); return null; } } int i = 0; int k = 0; byte[] feedback = new byte[16]; if (mode.equals(\u0026#34;CBC\u0026#34;)) { feedback = getInitializationVector(); } else if (mode.equals(\u0026#34;OFB\u0026#34;)) { feedback = getNounce(); } else if (mode.equals(\u0026#34;CFB\u0026#34;)) { feedback = getInitializationVectorCFB(); } while (i \u0026lt; length) { byte[] block = new byte[16]; byte[] result = new byte[16]; int j = 0; for (; j \u0026lt; 16 \u0026amp;\u0026amp; i \u0026lt; length; j++, i++) { block[j] = message[i]; } while (j \u0026lt; 16) { /* pad with white spaces */ block[j++] = 0x20; } // System.out.println(\u0026#34;BLOCK: \u0026#34;);  // printBytes(block);  if (mode.equals(\u0026#34;ECB\u0026#34;)) { result = decryptText(block, key); } else if (mode.equals(\u0026#34;CBC\u0026#34;)) { result = decryptText(block, key); result = XORBytes(result, feedback); feedback = Arrays.copyOfRange(block, 0, 16); } else if (mode.equals(\u0026#34;OFB\u0026#34;)) { result = encryptText(feedback, key); feedback = Arrays.copyOfRange(result, 0, 16); result = XORBytes(result, block); } else if (mode.equals(\u0026#34;CFB\u0026#34;)) { result = encryptText(feedback, key); byte[] resultPart = Arrays.copyOfRange(result, 0, 8); byte[] blockPart = Arrays.copyOfRange(block, 0, 8); byte[] temp1 = XORBytes(resultPart, blockPart); feedback = mergeBytes(Arrays.copyOfRange(result, 8, 16), blockPart); resultPart = Arrays.copyOfRange(result, 8, 16); blockPart = Arrays.copyOfRange(block, 8, 16); result = encryptText(feedback, key); byte[] temp2 = XORBytes(resultPart, blockPart); feedback = mergeBytes(Arrays.copyOfRange(result, 8, 16), blockPart); result = mergeBytes(temp1, temp2); } else { System.out.println(\u0026#34;Unsupported mode of operation!\u0026#34;); return null; } // System.out.println(\u0026#34;RESULT: \u0026#34;);  // printBytes(result);  for (j = 0; j \u0026lt; 16 \u0026amp;\u0026amp; k \u0026lt; cipher.length; j++, k++) { cipher[k] = result[j]; } } return cipher; } private byte[] getInitializationVector() { return hexStringToByteArray(\u0026#34;247D8AC4DDB1AA739DC593821D0BC432\u0026#34;); } private byte[] getInitializationVectorCFB() { return hexStringToByteArray(\u0026#34;247D8AC4DDB1AA739DC593821D0BC432\u0026#34;); } private byte[] getNounce() { // char[] hexArray = \u0026#34;0123456789ABCDEF\u0026#34;.toCharArray();  // String nounceStr = \u0026#34;\u0026#34;;  // for (int i = 0 ; i \u0026lt; 16 ; i++) {  // double random = Math.random();  // int index = (int) (random * 16);  // nounceStr += hexArray[index];  // }  // return hexStringToByteArray(nounceStr);  return hexStringToByteArray(\u0026#34;247D8AC4DDB1AA739DC593821D0BC432\u0026#34;); } private byte[] mergeBytes(byte[] in1, byte[] in2) { byte[] out = new byte[in1.length + in2.length]; int i = 0; for (int j = 0; j \u0026lt; in1.length; j++) { out[i++] = in1[j]; } for (int j = 0; j \u0026lt; in2.length; j++) { out[i++] = in2[j]; } return out; } } Output\ndhanoopbhaskar@dhanoop-laptop:~/workspace/Copy/crypto/run_aes$ java AESkeygen Key generated and saved in AESkey.txt dhanoopbhaskar@dhanoop-laptop:~/workspace/Copy/crypto/run_aes$ java AESencrypt Usage: java \u0026lt; classname \u0026gt; \u0026lt; mode \u0026gt; \u0026lt; mode \u0026gt; := (ECB|CBC|OFB|CFB) dhanoopbhaskar@dhanoop-laptop:~/workspace/Copy/crypto/run_aes$ java AESencrypt ecb Encryption done! Please check AESciphertext.txt for output! dhanoopbhaskar@dhanoop-laptop:~/workspace/Copy/crypto/run_aes$ java AESdecrypt ecb Decryption done! Please check AESplaintext.txt for output! dhanoopbhaskar@dhanoop-laptop:~/workspace/Copy/crypto/run_aes$ java AESencrypt cbc Encryption done! Please check AESciphertext.txt for output! dhanoopbhaskar@dhanoop-laptop:~/workspace/Copy/crypto/run_aes$ java AESdecrypt cbc Decryption done! Please check AESplaintext.txt for output! dhanoopbhaskar@dhanoop-laptop:~/workspace/Copy/crypto/run_aes$ java AESencrypt ofb Encryption done! Please check AESciphertext.txt for output! dhanoopbhaskar@dhanoop-laptop:~/workspace/Copy/crypto/run_aes$ java AESdecrypt ofb Decryption done! Please check AESplaintext.txt for output! dhanoopbhaskar@dhanoop-laptop:~/workspace/Copy/crypto/run_aes$ java AESencrypt cfb Encryption done! Please check AESciphertext.txt for output! dhanoopbhaskar@dhanoop-laptop:~/workspace/Copy/crypto/run_aes$ java AESdecrypt cfb Decryption done! Please check AESplaintext.txt for output! dhanoopbhaskar@dhanoop-laptop:~/workspace/Copy/crypto/run_aes$  About Input/Output Files\nAESkeygen.java - (output) AESkey.txt\nAESencrypt.java - (input) AESkey.txt \u0026amp; AESplaintext.txt (output) AESciphertext.txt\nAESdecrypt.java - (input) AESkey.txt \u0026amp; AESciphertext.txt (output) AESplaintext.txt\n",
    "ref": "/blog/2014-07-30-aes-implementation-in-java-with-ecb-cbc-ofb-cfb-modes-of-operation/"
  },{
    "title": "DES Implementation In Java with ECB | CBC | OFB | CFB Modes Of Operation",
    "date": "July 30, 2014",
    "description": "",
    "body": "Note that these are ONLY basic level programs for easy understanding of the Data Encryption Standard (DES) algorithm\nKey Generation - DESkeygen.java\nimport java.io.File; import java.io.FileWriter; public class DESkeygen { private final File file = new File(\u0026#34;DESkey.txt\u0026#34;); private final int KEY_LENGTH = 16; private final static char[] hexArray = \u0026#34;0123456789ABCDEF\u0026#34;.toCharArray(); public DESkeygen() { try { FileWriter fileWriter = new FileWriter(file); fileWriter.write(\u0026#34;\u0026#34;); for (int i = 0; i \u0026lt; KEY_LENGTH; i++) { double random = Math.random(); int index = (int) (random * 16); fileWriter.append(hexArray[index]); fileWriter.flush(); } fileWriter.close(); System.out.println(\u0026#34;Key generated and saved in \u0026#34; + file.getName()); } catch (Exception exp) { exp.printStackTrace(); } } public static void main(String[] args) { new DESkeygen(); } } Encryption - DESencrypt.java\nimport java.io.BufferedReader; import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.FileReader; import java.io.FileWriter; import java.util.Arrays; public class DESencrypt { private String mode = null; final protected static char[] hexArray = \u0026#34;0123456789ABCDEF\u0026#34;.toCharArray(); /* Initial Permutation */ static final int[] IP = { 58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8, 57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7 }; /* Inverse Initial Permutation */ static final int[] IIP = { 40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29, 36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25 }; /* Expansion Permutation */ static final int[] E = { 32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17, 16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1 }; /* Permutation Function */ static final int[] P = { 16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10, 2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25 }; /* S-Boxes*/ static final int[] S1 = { 14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7, 0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8, 4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0, 15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13 }; static final int[] S2 = { 15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10, 3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5, 0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15, 13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9 }; static final int[] S3 = { 10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8, 13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1, 13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7, 1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12 }; static final int[] S4 = { 7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15, 13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9, 10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4, 3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14 }; static final int[] S5 = { 2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9, 14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6, 4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14, 11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3 }; static final int[] S6 = { 12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11, 10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8, 9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6, 4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13 }; static final int[] S7 = { 4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1, 13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6, 1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2, 6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12 }; static final int[] S8 = { 13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7, 1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2, 7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8, 2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11 }; /* Permuted Choice One */ static final int[] PC1 = { 57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4 }; /* Permuted Choice Two */ static final int[] PC2 = { 14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32 }; /* Schedule of Left Shifts */ static final int[] SHIFTS = { 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1 }; public DESencrypt() { this.mode = \u0026#34;ECB\u0026#34;; } public DESencrypt(String mode) { this.mode = mode; } private byte[] performXOR(byte[] one, byte[] two) { byte[] result = new byte[one.length]; for (int i = 0; i \u0026lt; one.length; i++) { result[i] = (byte) (one[i] ^ two[i]); } return result; } private byte[] permute(byte[] input, int[] mapping) { int byteCount = 1 + (mapping.length - 1) / 8; byte[] output = new byte[byteCount]; int pos; for (int i = 0; i \u0026lt; mapping.length; i++) { pos = mapping[i] - 1; int value = getBitFromArray(input, pos); setBitInArray(output, i, value); } return output; } private int getBitFromArray(byte[] array, int pos) { int value; int bytePos = pos / 8; int bitPos = pos % 8; value = (array[bytePos] \u0026gt;\u0026gt; (8 - (bitPos + 1))) \u0026amp; 0x0001; /* * eg: right shift selected byte 5 times to get 3rd bit (bitPos = 2) at * rightmost position and then AND with 0x0001 */ return value; } private void setBitInArray(byte[] input, int pos, int value) { int bytePos = pos / 8; int bitPos = pos % 8; byte old = input[bytePos]; old = (byte) (((0xFF7F \u0026gt;\u0026gt; bitPos) \u0026amp; old) \u0026amp; 0x00FF); byte newByte = (byte) ((value \u0026lt;\u0026lt; (8 - (bitPos + 1))) | old); input[bytePos] = newByte; } private byte[] hexStringToByteArray(String string) { int length = string.length(); int n = (int) Math.ceil((length + 1) / 2); byte[] result = new byte[n]; for (int i = length - 1; i \u0026gt;= 0; i -= 2) { if (i == 0) { result[i / 2] = (byte) ((Character.digit(\u0026#39;0\u0026#39;, 16) \u0026lt;\u0026lt; 4) + Character.digit(string.charAt(i), 16)); } else { result[i / 2] = (byte) ((Character.digit(string.charAt(i - 1), 16) \u0026lt;\u0026lt; 4) + Character.digit(string.charAt(i), 16)); } } return result; } public static String bytesToHex(byte[] bytes) { char[] hexChars = new char[bytes.length * 2]; for (int j = 0; j \u0026lt; bytes.length; j++) { int v = bytes[j] \u0026amp; 0xFF; hexChars[j * 2] = hexArray[v \u0026gt;\u0026gt;\u0026gt; 4]; hexChars[j * 2 + 1] = hexArray[v \u0026amp; 0x0F]; } return new String(hexChars); } private void printBytes(byte[] input) { for (int i = 0; i \u0026lt; input.length; i++) { System.out.print(byteToBits(input[i]) + \u0026#34; \u0026#34;); } System.out.println(); } private String byteToBits(byte b) { StringBuffer buffer = new StringBuffer(); for (int i = 0; i \u0026lt; 8; i++) buffer.append((int) (b \u0026gt;\u0026gt; (8 - (i + 1)) \u0026amp; 0x0001)); return buffer.toString(); } private byte[] getBits(byte[] input, int startPos, int length) { int noOfBytes = (length - 1) / 8 + 1; byte[] output = new byte[noOfBytes]; for (int i = 0; i \u0026lt; length; i++) { int value = getBitFromArray(input, startPos + i); setBitInArray(output, i, value); } return output; } private byte[] rotateLeft(byte[] input, int step, int length) { int noOfBytes = (length - 1) / 8 + 1; byte[] output = new byte[noOfBytes]; for (int i = 0; i \u0026lt; length; i++) { int value = getBitFromArray(input, (i + step) % length); setBitInArray(output, i, value); } return output; } private byte[] concatBits(byte[] one, int oneLength, byte[] two, int twoLength) { int noOfBytes = (oneLength + twoLength - 1) / 8 + 1; byte[] output = new byte[noOfBytes]; int i = 0, j = 0; for (; i \u0026lt; oneLength; i++) { int value = getBitFromArray(one, i); setBitInArray(output, j, value); j++; } for (i = 0; i \u0026lt; twoLength; i++) { int value = getBitFromArray(two, i); setBitInArray(output, j, value); j++; } return output; } private byte[][] getSubKeys(byte[] masterKey) { int noOfSubKeys = SHIFTS.length; int keySize = PC1.length; byte[] key = permute(masterKey, PC1); byte[][] subKeys = new byte[noOfSubKeys][keySize]; byte[] leftHalf = getBits(key, 0, keySize / 2); byte[] rightHalf = getBits(key, keySize / 2, keySize / 2); for (int i = 0; i \u0026lt; noOfSubKeys; i++) { leftHalf = rotateLeft(leftHalf, SHIFTS[i], keySize / 2); rightHalf = rotateLeft(rightHalf, SHIFTS[i], keySize / 2); byte[] subKey = concatBits(leftHalf, keySize / 2, rightHalf, keySize / 2); subKeys[i] = permute(subKey, PC2); } return subKeys; } public byte[] crypt(byte[] message, byte[] key, String operation) { if (message.length \u0026lt; 8) { System.out.println(\u0026#34;Message should be atleast 64 bits\u0026#34;); System.exit(1); } if (key.length != 8) { System.out.println(\u0026#34;Key should be 64 bits\u0026#34;); System.exit(1); } int length = message.length; int n = (length + 7) / 8 * 8; byte[] cipher = new byte[n]; if (length == 8) { if (mode.equals(\u0026#34;ECB\u0026#34;)) { return cryptText(message, key, operation); } else if (mode.equals(\u0026#34;CBC\u0026#34;)) { byte[] iv = getInitializationVector(); message = XORBytes(message, iv); return cryptText(message, key, operation); } else if (mode.equals(\u0026#34;OFB\u0026#34;)) { byte[] nounce = getNounce(); byte[] temp = cryptText(nounce, key, operation); byte[] result = XORBytes(temp, message); return result; } else if (mode.equals(\u0026#34;CFB\u0026#34;)) { } else { System.out.println(\u0026#34;Unsupported mode of operation!\u0026#34;); return null; } } int i = 0; int k = 0; byte[] feedback = new byte[8]; if (mode.equals(\u0026#34;CBC\u0026#34;)) { feedback = getInitializationVector(); } else if (mode.equals(\u0026#34;OFB\u0026#34;)) { feedback = getNounce(); } else if (mode.equals(\u0026#34;CFB\u0026#34;)) { feedback = getInitializationVectorCFB(); } while (i \u0026lt; length) { byte[] block = new byte[8]; byte[] result = new byte[8]; int j = 0; for (; j \u0026lt; 8 \u0026amp;\u0026amp; i \u0026lt; length; j++, i++) { block[j] = message[i]; } while (j \u0026lt; 8) { /* pad with white spaces */ block[j++] = 0x20; } // System.out.println(\u0026#34;BLOCK: \u0026#34;);  // printBytes(block);  if (mode.equals(\u0026#34;ECB\u0026#34;)) { result = cryptText(block, key, operation); } else if (mode.equals(\u0026#34;CBC\u0026#34;)) { if (operation.equals(\u0026#34;encrypt\u0026#34;)) { block = XORBytes(block, feedback); result = cryptText(block, key, operation); feedback = Arrays.copyOfRange(result, 0, 8); } else if (operation.equals(\u0026#34;decrypt\u0026#34;)) { result = cryptText(block, key, operation); result = XORBytes(result, feedback); feedback = Arrays.copyOfRange(block, 0, 8); } } else if (mode.equals(\u0026#34;OFB\u0026#34;)) { result = cryptText(feedback, key, operation); feedback = Arrays.copyOfRange(result, 0, 8); result = XORBytes(result, block); } else if (mode.equals(\u0026#34;CFB\u0026#34;)) { if (operation.equals(\u0026#34;encrypt\u0026#34;)) { result = cryptText(feedback, key, operation); byte[] resultPart = Arrays.copyOfRange(result, 0, 4); byte[] blockPart = Arrays.copyOfRange(block, 0, 4); byte[] temp1 = XORBytes(resultPart, blockPart); feedback = mergeBytes(Arrays.copyOfRange(result, 4, 8), temp1); resultPart = Arrays.copyOfRange(result, 4, 8); blockPart = Arrays.copyOfRange(block, 4, 8); result = cryptText(feedback, key, operation); byte[] temp2 = XORBytes(resultPart, blockPart); feedback = mergeBytes(Arrays.copyOfRange(result, 4, 8), temp2); result = mergeBytes(temp1, temp2); } else if (operation.equals(\u0026#34;decrypt\u0026#34;)) { result = cryptText(feedback, key, \u0026#34;encrypt\u0026#34;); byte[] resultPart = Arrays.copyOfRange(result, 0, 4); byte[] blockPart = Arrays.copyOfRange(block, 0, 4); byte[] temp1 = XORBytes(resultPart, blockPart); feedback = mergeBytes(Arrays.copyOfRange(result, 4, 8), blockPart); resultPart = Arrays.copyOfRange(result, 4, 8); blockPart = Arrays.copyOfRange(block, 4, 8); result = cryptText(feedback, key, \u0026#34;encrypt\u0026#34;); byte[] temp2 = XORBytes(resultPart, blockPart); feedback = mergeBytes(Arrays.copyOfRange(result, 4, 8), blockPart); result = mergeBytes(temp1, temp2); } } else { System.out.println(\u0026#34;Unsupported mode of operation!\u0026#34;); return null; } // System.out.println(\u0026#34;RESULT: \u0026#34;);  // printBytes(result);  for (j = 0; j \u0026lt; 8 \u0026amp;\u0026amp; k \u0026lt; cipher.length; j++, k++) { cipher[k] = result[j]; } } return cipher; } private byte[] getInitializationVector() { return hexStringToByteArray(\u0026#34;DCBE6AE7EA5D5C61\u0026#34;); } private byte[] getInitializationVectorCFB() { return hexStringToByteArray(\u0026#34;A5D5C61EFADB4351\u0026#34;); } private byte[] getNounce() { // char[] hexArray = \u0026#34;0123456789ABCDEF\u0026#34;.toCharArray();  // String nounceStr = \u0026#34;\u0026#34;;  // for (int i = 0 ; i \u0026lt; 16 ; i++) {  // double random = Math.random();  // int index = (int) (random * 16);  // nounceStr += hexArray[index];  // }  // return hexStringToByteArray(nounceStr);  return hexStringToByteArray(\u0026#34;DCBE6AE7EA5D5C61\u0026#34;); } private byte[] mergeBytes(byte[] in1, byte[] in2) { byte[] out = new byte[in1.length + in2.length]; int i = 0; for (int j = 0; j \u0026lt; in1.length; j++) { out[i++] = in1[j]; } for (int j = 0; j \u0026lt; in2.length; j++) { out[i++] = in2[j]; } return out; } public byte[] cryptText(byte[] message, byte[] key, String operation) { if (message.length != 8) { System.out.println(\u0026#34;Message should be 64 bits\u0026#34;); System.exit(1); } if (key.length != 8) { System.out.println(\u0026#34;Key should be 64 bits\u0026#34;); System.exit(1); } byte[] result = null; int blockSize = IP.length; byte[][] subKeys = getSubKeys(key); int noOfRounds = subKeys.length; /** * Initial Permutation */ message = permute(message, IP); /** * Split message into two halves */ byte[] leftHalf = getBits(message, 0, blockSize / 2); byte[] rightHalf = getBits(message, blockSize / 2, blockSize / 2); for (int i = 0; i \u0026lt; noOfRounds; i++) { byte[] temp = rightHalf; /** * Expansion */ rightHalf = permute(rightHalf, E); /** * XOR rightHalf with roundKey */ byte[] roundKey = null; if (operation.equalsIgnoreCase(\u0026#34;encrypt\u0026#34;)) { roundKey = subKeys[i]; } else if (operation.equalsIgnoreCase(\u0026#34;decrypt\u0026#34;)) { roundKey = subKeys[noOfRounds - i - 1]; } else { System.out.println(\u0026#34;Unsupported operation\u0026#34;); System.exit(0); } rightHalf = performXOR(rightHalf, roundKey); /** * S-Box */ rightHalf = sBox(rightHalf); /** * Permutation */ rightHalf = permute(rightHalf, P); /** * XOR rightHalf with leftHalf */ rightHalf = performXOR(rightHalf, leftHalf); /** * L(i) = R(i-1) */ leftHalf = temp; } /** * 32 bit swap */ byte[] concatHalves = concatBits(rightHalf, blockSize / 2, leftHalf, blockSize / 2); /** * Inverse Initial Permutation */ result = permute(concatHalves, IIP); return result; } public static byte[] XORBytes(byte[] in1, byte[] in2) { byte[] out = new byte[in1.length]; for (int i = 0; i \u0026lt; in1.length; i++) { out[i] = (byte) ((in1[i] ^ in2[i]) \u0026amp; 0xff); } return out; } private byte[] sBox(byte[] input) { /** * Split input to 6-bit blocks */ input = split(input, 6); byte[] output = new byte[input.length / 2]; int leftHalf = 0; for (int i = 0; i \u0026lt; input.length; i++) { byte block = input[i]; /** * row - first and last bits column - 4 bits in the middle */ int row = 2 * (block \u0026gt;\u0026gt; 7 \u0026amp; 0x0001) + (block \u0026gt;\u0026gt; 2 \u0026amp; 0x0001); int col = block \u0026gt;\u0026gt; 3 \u0026amp; 0x000F; int[] selectedSBox = getSBox(i); int rightHalf = selectedSBox[16 * row + col]; if (i % 2 == 0) { leftHalf = rightHalf; } else { output[i / 2] = (byte) (16 * leftHalf + rightHalf); leftHalf = 0; } } return output; } private int[] getSBox(int i) { switch (i) { case 0: return S1; case 1: return S2; case 2: return S3; case 3: return S4; case 4: return S5; case 5: return S6; case 6: return S7; case 7: return S8; default: return null; } } private byte[] split(byte[] input, int length) { int noOfBytes = (8 * input.length - 1) / length + 1; byte[] output = new byte[noOfBytes]; for (int i = 0; i \u0026lt; noOfBytes; i++) { for (int j = 0; j \u0026lt; length; j++) { int value = getBitFromArray(input, length * i + j); setBitInArray(output, 8 * i + j, value); } } return output; } public static void main(String[] args) { try { if (args.length != 1) { System.out.println(\u0026#34;Usage: java \u0026lt; classname \u0026gt; \u0026lt; mode \u0026gt;\u0026#34; + \u0026#34;\\n\\t\u0026lt; mode \u0026gt; := (ECB|CBC|OFB|CFB)\u0026#34;); return; } /* ECB, CBC, OFB, or CFB */ String mode = args[0]; mode = mode.toUpperCase(); DESencrypt des = new DESencrypt(mode); File keyFile = new File(\u0026#34;DESkey.txt\u0026#34;); File textFile = new File(\u0026#34;DESplaintext.txt\u0026#34;); File cipherFile = new File(\u0026#34;DESciphertext.txt\u0026#34;); FileReader keyFileReader = new FileReader(keyFile); BufferedReader bufferedReader = new BufferedReader(keyFileReader); FileInputStream textFileInputStream = new FileInputStream(textFile); FileOutputStream cipherFileOutputStream = new FileOutputStream(cipherFile); byte[] key = new byte[(int) keyFile.length()]; String keyString = bufferedReader.readLine(); key = des.hexStringToByteArray(keyString); byte[] message = new byte[(int) textFile.length()]; textFileInputStream.read(message); byte[] cipher = des.crypt(message, key, \u0026#34;encrypt\u0026#34;); cipherFileOutputStream.write(cipher); cipherFileOutputStream.flush(); cipherFileOutputStream.close(); bufferedReader.close(); textFileInputStream.close(); System.out.println(\u0026#34;Encryption done! Please check DESciphertext.txt for output!\u0026#34;); } catch (Exception exp) { exp.printStackTrace(); } } } Decryption - DESdecrypt.java\nimport java.io.BufferedReader; import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.FileReader; import java.io.FileWriter; import java.util.Arrays; public class DESdecrypt { private String mode = null; final protected static char[] hexArray = \u0026#34;0123456789ABCDEF\u0026#34;.toCharArray(); /* Initial Permutation */ static final int[] IP = { 58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8, 57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7 }; /* Inverse Initial Permutation */ static final int[] IIP = { 40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29, 36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25 }; /* Expansion Permutation */ static final int[] E = { 32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17, 16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1 }; /* Permutation Function */ static final int[] P = { 16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10, 2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25 }; /* S-Boxes*/ static final int[] S1 = { 14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7, 0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8, 4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0, 15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13 }; static final int[] S2 = { 15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10, 3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5, 0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15, 13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9 }; static final int[] S3 = { 10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8, 13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1, 13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7, 1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12 }; static final int[] S4 = { 7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15, 13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9, 10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4, 3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14 }; static final int[] S5 = { 2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9, 14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6, 4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14, 11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3 }; static final int[] S6 = { 12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11, 10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8, 9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6, 4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13 }; static final int[] S7 = { 4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1, 13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6, 1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2, 6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12 }; static final int[] S8 = { 13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7, 1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2, 7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8, 2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11 }; /* Permuted Choice One */ static final int[] PC1 = { 57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4 }; /* Permuted Choice Two */ static final int[] PC2 = { 14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32 }; /* Schedule of Left Shifts */ static final int[] SHIFTS = { 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1 }; public DESdecrypt() { this.mode = \u0026#34;ECB\u0026#34;; } public DESdecrypt(String mode) { this.mode = mode; } private byte[] performXOR(byte[] one, byte[] two) { byte[] result = new byte[one.length]; for (int i = 0; i \u0026lt; one.length; i++) { result[i] = (byte) (one[i] ^ two[i]); } return result; } private byte[] permute(byte[] input, int[] mapping) { int byteCount = 1 + (mapping.length - 1) / 8; byte[] output = new byte[byteCount]; int pos; for (int i = 0; i \u0026lt; mapping.length; i++) { pos = mapping[i] - 1; int value = getBitFromArray(input, pos); setBitInArray(output, i, value); } return output; } private int getBitFromArray(byte[] array, int pos) { int value; int bytePos = pos / 8; int bitPos = pos % 8; value = (array[bytePos] \u0026gt;\u0026gt; (8 - (bitPos + 1))) \u0026amp; 0x0001; /* * eg: right shift selected byte 5 times to get 3rd bit (bitPos = 2) at * rightmost position and then AND with 0x0001 */ return value; } private void setBitInArray(byte[] input, int pos, int value) { int bytePos = pos / 8; int bitPos = pos % 8; byte old = input[bytePos]; old = (byte) (((0xFF7F \u0026gt;\u0026gt; bitPos) \u0026amp; old) \u0026amp; 0x00FF); byte newByte = (byte) ((value \u0026lt;\u0026lt; (8 - (bitPos + 1))) | old); input[bytePos] = newByte; } private byte[] hexStringToByteArray(String string) { int length = string.length(); int n = (int) Math.ceil((length + 1) / 2); byte[] result = new byte[n]; for (int i = length - 1; i \u0026gt;= 0; i -= 2) { if (i == 0) { result[i / 2] = (byte) ((Character.digit(\u0026#39;0\u0026#39;, 16) \u0026lt;\u0026lt; 4) + Character.digit(string.charAt(i), 16)); } else { result[i / 2] = (byte) ((Character.digit(string.charAt(i - 1), 16) \u0026lt;\u0026lt; 4) + Character.digit(string.charAt(i), 16)); } } return result; } public static String bytesToHex(byte[] bytes) { char[] hexChars = new char[bytes.length * 2]; for (int j = 0; j \u0026lt; bytes.length; j++) { int v = bytes[j] \u0026amp; 0xFF; hexChars[j * 2] = hexArray[v \u0026gt;\u0026gt;\u0026gt; 4]; hexChars[j * 2 + 1] = hexArray[v \u0026amp; 0x0F]; } return new String(hexChars); } private void printBytes(byte[] input) { for (int i = 0; i \u0026lt; input.length; i++) { System.out.print(byteToBits(input[i]) + \u0026#34; \u0026#34;); } System.out.println(); } private String byteToBits(byte b) { StringBuffer buffer = new StringBuffer(); for (int i = 0; i \u0026lt; 8; i++) buffer.append((int) (b \u0026gt;\u0026gt; (8 - (i + 1)) \u0026amp; 0x0001)); return buffer.toString(); } private byte[] getBits(byte[] input, int startPos, int length) { int noOfBytes = (length - 1) / 8 + 1; byte[] output = new byte[noOfBytes]; for (int i = 0; i \u0026lt; length; i++) { int value = getBitFromArray(input, startPos + i); setBitInArray(output, i, value); } return output; } private byte[] rotateLeft(byte[] input, int step, int length) { int noOfBytes = (length - 1) / 8 + 1; byte[] output = new byte[noOfBytes]; for (int i = 0; i \u0026lt; length; i++) { int value = getBitFromArray(input, (i + step) % length); setBitInArray(output, i, value); } return output; } private byte[] concatBits(byte[] one, int oneLength, byte[] two, int twoLength) { int noOfBytes = (oneLength + twoLength - 1) / 8 + 1; byte[] output = new byte[noOfBytes]; int i = 0, j = 0; for (; i \u0026lt; oneLength; i++) { int value = getBitFromArray(one, i); setBitInArray(output, j, value); j++; } for (i = 0; i \u0026lt; twoLength; i++) { int value = getBitFromArray(two, i); setBitInArray(output, j, value); j++; } return output; } private byte[][] getSubKeys(byte[] masterKey) { int noOfSubKeys = SHIFTS.length; int keySize = PC1.length; byte[] key = permute(masterKey, PC1); byte[][] subKeys = new byte[noOfSubKeys][keySize]; byte[] leftHalf = getBits(key, 0, keySize / 2); byte[] rightHalf = getBits(key, keySize / 2, keySize / 2); for (int i = 0; i \u0026lt; noOfSubKeys; i++) { leftHalf = rotateLeft(leftHalf, SHIFTS[i], keySize / 2); rightHalf = rotateLeft(rightHalf, SHIFTS[i], keySize / 2); byte[] subKey = concatBits(leftHalf, keySize / 2, rightHalf, keySize / 2); subKeys[i] = permute(subKey, PC2); } return subKeys; } public byte[] crypt(byte[] message, byte[] key, String operation) { if (message.length \u0026lt; 8) { System.out.println(\u0026#34;Message should be atleast 64 bits\u0026#34;); System.exit(1); } if (key.length != 8) { System.out.println(\u0026#34;Key should be 64 bits\u0026#34;); System.exit(1); } int length = message.length; int n = (length + 7) / 8 * 8; byte[] cipher = new byte[n]; if (length == 8) { if (mode.equals(\u0026#34;ECB\u0026#34;)) { return cryptText(message, key, operation); } else if (mode.equals(\u0026#34;CBC\u0026#34;)) { byte[] iv = getInitializationVector(); message = XORBytes(message, iv); return cryptText(message, key, operation); } else if (mode.equals(\u0026#34;OFB\u0026#34;)) { byte[] nounce = getNounce(); byte[] temp = cryptText(nounce, key, \u0026#34;encrypt\u0026#34;); byte[] result = XORBytes(temp, message); return result; } else if (mode.equals(\u0026#34;CFB\u0026#34;)) { } else { System.out.println(\u0026#34;Unsupported mode of operation!\u0026#34;); return null; } } int i = 0; int k = 0; byte[] feedback = new byte[8]; if (mode.equals(\u0026#34;CBC\u0026#34;)) { feedback = getInitializationVector(); } else if (mode.equals(\u0026#34;OFB\u0026#34;)) { feedback = getNounce(); } else if (mode.equals(\u0026#34;CFB\u0026#34;)) { feedback = getInitializationVectorCFB(); } while (i \u0026lt; length) { byte[] block = new byte[8]; byte[] result = new byte[8]; int j = 0; for (; j \u0026lt; 8 \u0026amp;\u0026amp; i \u0026lt; length; j++, i++) { block[j] = message[i]; } while (j \u0026lt; 8) { /* pad with white spaces */ block[j++] = 0x20; } // System.out.println(\u0026#34;BLOCK: \u0026#34;);  // printBytes(block);  if (mode.equals(\u0026#34;ECB\u0026#34;)) { result = cryptText(block, key, operation); } else if (mode.equals(\u0026#34;CBC\u0026#34;)) { if (operation.equals(\u0026#34;encrypt\u0026#34;)) { block = XORBytes(block, feedback); result = cryptText(block, key, operation); feedback = Arrays.copyOfRange(result, 0, 8); } else if (operation.equals(\u0026#34;decrypt\u0026#34;)) { result = cryptText(block, key, operation); result = XORBytes(result, feedback); feedback = Arrays.copyOfRange(block, 0, 8); } } else if (mode.equals(\u0026#34;OFB\u0026#34;)) { result = cryptText(feedback, key, \u0026#34;encrypt\u0026#34;); feedback = Arrays.copyOfRange(result, 0, 8); result = XORBytes(result, block); } else if (mode.equals(\u0026#34;CFB\u0026#34;)) { if (operation.equals(\u0026#34;encrypt\u0026#34;)) { result = cryptText(feedback, key, operation); byte[] resultPart = Arrays.copyOfRange(result, 0, 4); byte[] blockPart = Arrays.copyOfRange(block, 0, 4); byte[] temp1 = XORBytes(resultPart, blockPart); feedback = mergeBytes(Arrays.copyOfRange(result, 4, 8), temp1); resultPart = Arrays.copyOfRange(result, 4, 8); blockPart = Arrays.copyOfRange(block, 4, 8); result = cryptText(feedback, key, operation); byte[] temp2 = XORBytes(resultPart, blockPart); feedback = mergeBytes(Arrays.copyOfRange(result, 4, 8), temp2); result = mergeBytes(temp1, temp2); } else if (operation.equals(\u0026#34;decrypt\u0026#34;)) { result = cryptText(feedback, key, \u0026#34;encrypt\u0026#34;); byte[] resultPart = Arrays.copyOfRange(result, 0, 4); byte[] blockPart = Arrays.copyOfRange(block, 0, 4); byte[] temp1 = XORBytes(resultPart, blockPart); feedback = mergeBytes(Arrays.copyOfRange(result, 4, 8), blockPart); resultPart = Arrays.copyOfRange(result, 4, 8); blockPart = Arrays.copyOfRange(block, 4, 8); result = cryptText(feedback, key, \u0026#34;encrypt\u0026#34;); byte[] temp2 = XORBytes(resultPart, blockPart); feedback = mergeBytes(Arrays.copyOfRange(result, 4, 8), blockPart); result = mergeBytes(temp1, temp2); } } else { System.out.println(\u0026#34;Unsupported mode of operation!\u0026#34;); return null; } // System.out.println(\u0026#34;RESULT: \u0026#34;);  // printBytes(result);  for (j = 0; j \u0026lt; 8 \u0026amp;\u0026amp; k \u0026lt; cipher.length; j++, k++) { cipher[k] = result[j]; } } return cipher; } private byte[] getInitializationVector() { return hexStringToByteArray(\u0026#34;DCBE6AE7EA5D5C61\u0026#34;); } private byte[] getInitializationVectorCFB() { return hexStringToByteArray(\u0026#34;A5D5C61EFADB4351\u0026#34;); } private byte[] getNounce() { // char[] hexArray = \u0026#34;0123456789ABCDEF\u0026#34;.toCharArray();  // String nounceStr = \u0026#34;\u0026#34;;  // for (int i = 0 ; i \u0026lt; 16 ; i++) {  // double random = Math.random();  // int index = (int) (random * 16);  // nounceStr += hexArray[index];  // }  // return hexStringToByteArray(nounceStr);  return hexStringToByteArray(\u0026#34;DCBE6AE7EA5D5C61\u0026#34;); } private byte[] mergeBytes(byte[] in1, byte[] in2) { byte[] out = new byte[in1.length + in2.length]; int i = 0; for (int j = 0; j \u0026lt; in1.length; j++) { out[i++] = in1[j]; } for (int j = 0; j \u0026lt; in2.length; j++) { out[i++] = in2[j]; } return out; } public byte[] cryptText(byte[] message, byte[] key, String operation) { if (message.length != 8) { System.out.println(\u0026#34;Message should be 64 bits\u0026#34;); System.exit(1); } if (key.length != 8) { System.out.println(\u0026#34;Key should be 64 bits\u0026#34;); System.exit(1); } byte[] result = null; int blockSize = IP.length; byte[][] subKeys = getSubKeys(key); int noOfRounds = subKeys.length; /** * Initial Permutation */ message = permute(message, IP); /** * Split message into two halves */ byte[] leftHalf = getBits(message, 0, blockSize / 2); byte[] rightHalf = getBits(message, blockSize / 2, blockSize / 2); for (int i = 0; i \u0026lt; noOfRounds; i++) { byte[] temp = rightHalf; /** * Expansion */ rightHalf = permute(rightHalf, E); /** * XOR rightHalf with roundKey */ byte[] roundKey = null; if (operation.equalsIgnoreCase(\u0026#34;encrypt\u0026#34;)) { roundKey = subKeys[i]; } else if (operation.equalsIgnoreCase(\u0026#34;decrypt\u0026#34;)) { roundKey = subKeys[noOfRounds - i - 1]; } else { System.out.println(\u0026#34;Unsupported operation\u0026#34;); System.exit(0); } rightHalf = performXOR(rightHalf, roundKey); /** * S-Box */ rightHalf = sBox(rightHalf); /** * Permutation */ rightHalf = permute(rightHalf, P); /** * XOR rightHalf with leftHalf */ rightHalf = performXOR(rightHalf, leftHalf); /** * L(i) = R(i-1) */ leftHalf = temp; } /** * 32 bit swap */ byte[] concatHalves = concatBits(rightHalf, blockSize / 2, leftHalf, blockSize / 2); /** * Inverse Initial Permutation */ result = permute(concatHalves, IIP); return result; } public static byte[] XORBytes(byte[] in1, byte[] in2) { byte[] out = new byte[in1.length]; for (int i = 0; i \u0026lt; in1.length; i++) { out[i] = (byte) ((in1[i] ^ in2[i]) \u0026amp; 0xff); } return out; } private byte[] sBox(byte[] input) { /** * Split input to 6-bit blocks */ input = split(input, 6); byte[] output = new byte[input.length / 2]; int leftHalf = 0; for (int i = 0; i \u0026lt; input.length; i++) { byte block = input[i]; /** * row - first and last bits column - 4 bits in the middle */ int row = 2 * (block \u0026gt;\u0026gt; 7 \u0026amp; 0x0001) + (block \u0026gt;\u0026gt; 2 \u0026amp; 0x0001); int col = block \u0026gt;\u0026gt; 3 \u0026amp; 0x000F; int[] selectedSBox = getSBox(i); int rightHalf = selectedSBox[16 * row + col]; if (i % 2 == 0) { leftHalf = rightHalf; } else { output[i / 2] = (byte) (16 * leftHalf + rightHalf); leftHalf = 0; } } return output; } private int[] getSBox(int i) { switch (i) { case 0: return S1; case 1: return S2; case 2: return S3; case 3: return S4; case 4: return S5; case 5: return S6; case 6: return S7; case 7: return S8; default: return null; } } private byte[] split(byte[] input, int length) { int noOfBytes = (8 * input.length - 1) / length + 1; byte[] output = new byte[noOfBytes]; for (int i = 0; i \u0026lt; noOfBytes; i++) { for (int j = 0; j \u0026lt; length; j++) { int value = getBitFromArray(input, length * i + j); setBitInArray(output, 8 * i + j, value); } } return output; } public static void main(String[] args) { try { if (args.length != 1) { System.out.println(\u0026#34;Usage: java \u0026lt; classname \u0026gt; \u0026lt; mode \u0026gt;\u0026#34; + \u0026#34;\\n\\t\u0026lt; mode \u0026gt; := (ECB|CBC|OFB|CFB)\u0026#34;); return; } /* ECB, CBC, OFB, or CFB */ String mode = args[0]; mode = mode.toUpperCase(); DESdecrypt des = new DESdecrypt(mode); File keyFile = new File(\u0026#34;DESkey.txt\u0026#34;); File textFile = new File(\u0026#34;DESplaintext.txt\u0026#34;); File cipherFile = new File(\u0026#34;DESciphertext.txt\u0026#34;); FileReader keyFileReader = new FileReader(keyFile); BufferedReader bufferedReader = new BufferedReader(keyFileReader); FileInputStream cipherFileInputStream = new FileInputStream(cipherFile); FileOutputStream textFileOutputStream = new FileOutputStream(textFile); byte[] key = new byte[(int) keyFile.length()]; String keyString = bufferedReader.readLine(); key = des.hexStringToByteArray(keyString); byte[] cipher = new byte[(int) cipherFile.length()]; cipherFileInputStream.read(cipher); byte[] message = des.crypt(cipher, key, \u0026#34;decrypt\u0026#34;); textFileOutputStream.write(message); textFileOutputStream.flush(); textFileOutputStream.close(); bufferedReader.close(); cipherFileInputStream.close(); System.out.println(\u0026#34;Decryption done! Please check DESplaintext.txt for output!\u0026#34;); } catch (Exception exp) { exp.printStackTrace(); } } }  Output\ndhanoopbhaskar@dhanoop-laptop:~/workspace$ java DESkeygen Key generated and saved in DESkey.txt dhanoopbhaskar@dhanoop-laptop:~/workspace$ java DESencrypt Usage: java \u0026lt;classname\u0026gt; \u0026lt;mode\u0026gt; \u0026lt;mode\u0026gt; := (ECB|CBC|OFB|CFB) dhanoopbhaskar@dhanoop-laptop:~/workspace$ java DESencrypt ecb Encryption done! Please check DESciphertext.txt for output! dhanoopbhaskar@dhanoop-laptop:~/workspace$ java DESdecrypt ecb Decryption done! Please check DESplaintext.txt for output! dhanoopbhaskar@dhanoop-laptop:~/workspace$ java DESencrypt cbc Encryption done! Please check DESciphertext.txt for output! dhanoopbhaskar@dhanoop-laptop:~/workspace$ java DESdecrypt cbc Decryption done! Please check DESplaintext.txt for output! dhanoopbhaskar@dhanoop-laptop:~/workspace$ java DESencrypt ofb Encryption done! Please check DESciphertext.txt for output! dhanoopbhaskar@dhanoop-laptop:~/workspace$ java DESdecrypt ofb Decryption done! Please check DESplaintext.txt for output! dhanoopbhaskar@dhanoop-laptop:~/workspace$ java DESencrypt cfb Encryption done! Please check DESciphertext.txt for output! dhanoopbhaskar@dhanoop-laptop:~/workspace$ java DESdecrypt cfb Decryption done! Please check DESplaintext.txt for output! dhanoopbhaskar@dhanoop-laptop:~/workspace$ java DESdecrypt cfb Decryption done! Please check DESplaintext.txt for output! dhanoopbhaskar@dhanoop-laptop:~/workspace$  About Input/Output Files\nDESkeygen.java - (output) DESkey.txt\nDESencrypt.java - (input) DESkey.txt \u0026amp; DESplaintext.txt (output) DESciphertext.txtÂ DESdecrypt.java - (input) DESkey.txt \u0026amp; DESciphertext.txt (output) DESplaintext.txt\n",
    "ref": "/blog/2014-07-30-des-implementation-in-java-with-ecb-cbc-ofb-cfb-modes-of-operation/"
  },{
    "title": "AES Implementation in Java",
    "date": "July 30, 2014",
    "description": "",
    "body": "AES.java\nimport java.util.Arrays; public class AES { private static final int BITS = 16; private static final int ROUNDS = 10; private static final int NO_OF_WORDS_IN_KEY = 44; private static final int KEY_LENGTH = 16; private static final int BLOCK_LENGTH = 16; final protected static char[] hexArray = \u0026#34;0123456789ABCDEF\u0026#34;.toCharArray(); int[] RC = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36 }; Word[] Rcon = new Word[ROUNDS]; private byte[] word = null; static final int[] sBox = { 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 }; static final int[] invSBox = { 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d }; public AES() { for (int i = 0; i \u0026lt; ROUNDS; i++) { Rcon[i] = new Word(); byte[] temp = new byte[4]; temp[0] = (byte) (RC[i] \u0026amp; 0xff); temp[1] = 0; temp[2] = 0; temp[3] = 0; Rcon[i].setWord(temp); } word = new byte[NO_OF_WORDS_IN_KEY]; } /* Ref: http://www.samiam.org/galois.html */ /* Galois Addition */ byte gadd(byte a, byte b) { return (byte) ((a ^ b) \u0026amp; 0xff); } /* Galois Subtraction */ byte gsub(byte a, byte b) { return (byte) ((a ^ b) \u0026amp; 0xff); } /* Galois Multiplication */ byte gmul(byte a, byte b) { byte p = 0; int counter; byte high_bit_set; byte byte0x80 = hexStringToByteArray(\u0026#34;80\u0026#34;)[0]; for (counter = 0; counter \u0026lt; 8; counter++) { if ((b \u0026amp; 0x01) == 1) { // System.out.println(\u0026#34;lower bit of b is set\u0026#34;);  p = (byte) ((p ^ a) \u0026amp; 0xff); } high_bit_set = (byte) (a \u0026amp; 0x80); // printByte(\u0026#34;high_bit_set\u0026#34;, high_bit_set);  a \u0026lt;\u0026lt;= 1; if (high_bit_set == byte0x80) { // System.out.println(\u0026#34;higher bit of a is set\u0026#34;);  a = (byte) ((a ^ 0x1b) \u0026amp; 0xff); } b = (byte) ((b \u0026gt;\u0026gt; 1) \u0026amp; 0x7f); // printByte(\u0026#34;a\u0026#34;, a);  // printByte(\u0026#34;b\u0026#34;, b);  // printByte(\u0026#34;p\u0026#34;, p);  } return p; } byte gmul(byte a, int b) { byte t = (byte) (b \u0026amp; 0xff); return gmul(a, t); } /* Key Expansion */ private byte[] expandKey(byte[] key) throws Exception { // System.out.println(key.length);  // System.out.println(bytesToHex(key));  if (key.length != KEY_LENGTH) { throw new Exception(\u0026#34;Key should be of length, 128 bits\u0026#34;); } Word[] w = new Word[NO_OF_WORDS_IN_KEY]; Word temp; for (int i = 0; i \u0026lt; 4; i++) { w[i] = new Word(key[4 * i], key[4 * i + 1], key[4 * i + 2], key[4 * i + 3]); // System.out.println(\u0026#34;w\u0026#34; + i + \u0026#34; = \u0026#34; + w[i]);  } for (int i = 4; i \u0026lt; 44; i++) { temp = w[i - 1]; Word temp1 = new Word(); temp1.setWord(temp.getWord()); // System.out.println(\u0026#34;w\u0026#34; + (i-1) + \u0026#34; = \u0026#34; + temp);  if (i % 4 == 0) { temp1.rotWord(); // System.out.println(\u0026#34;Rot=\u0026#34; + temp1);  temp1.subWord(); // System.out.println(\u0026#34;Sub=\u0026#34; + temp1);  temp1 = Word.XORWords(temp1, Rcon[(i / 4) - 1]); // System.out.println(\u0026#34;Rcon\u0026#34; + temp1);  } w[i] = Word.XORWords(w[i - 4], temp1); // System.out.println(\u0026#34;w\u0026#34; + i + \u0026#34; = \u0026#34; + w[i]);  } return Word.wordsToBytes(w); } /* Substitute Bytes */ private byte[] subBytes(byte[] in) { byte[] out = new byte[BITS]; for (int i = 0; i \u0026lt; BITS; i++) { byte a = in[i]; int row = (a \u0026gt;\u0026gt; 4) \u0026amp; 0x000F; int col = a \u0026amp; 0x000F; out[i] = (byte) sBox[row * BITS + col]; } return out; } /* Inverse Substitute Bytes */ private byte[] inverseSubBytes(byte[] in) { byte[] out = new byte[BITS]; for (int i = 0; i \u0026lt; BITS; i++) { byte a = in[i]; int row = (a \u0026gt;\u0026gt; 4) \u0026amp; 0x000F; int col = a \u0026amp; 0x000F; out[i] = (byte) invSBox[row * BITS + col]; } return out; } /* Shift Rows */ private byte[] shiftRows(byte[] in) { byte[] out = new byte[BITS]; byte[] temp = new byte[BITS]; for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { temp[4 * j + i] = in[4 * i + j]; } } // System.out.println(\u0026#34;temp: \u0026#34; + bytesToHex(temp));  for (int i = 0; i \u0026lt; BITS / 4; i++) { byte[] a = Arrays.copyOfRange(temp, (4 * i), (4 * i + 4)); byte[] b = leftShift(a, i); in[4 * i] = b[0]; in[4 * i + 1] = b[1]; in[4 * i + 2] = b[2]; in[4 * i + 3] = b[3]; } for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { out[4 * j + i] = in[4 * i + j]; } } return out; } private byte[] leftShift(byte[] in, int times) { byte[] out = new byte[4]; out = Arrays.copyOfRange(in, 0, 4); for (int i = 0; i \u0026lt; times; i++) { out[0] = in[1]; out[1] = in[2]; out[2] = in[3]; out[3] = in[0]; in = Arrays.copyOfRange(out, 0, 4); } return out; } /* Inverse Shift Rows */ private byte[] inverseShiftRows(byte[] in) { byte[] out = new byte[BITS]; byte[] temp = new byte[BITS]; for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { temp[4 * j + i] = in[4 * i + j]; } } for (int i = 0; i \u0026lt; BITS / 4; i++) { byte[] a = Arrays.copyOfRange(temp, (4 * i), (4 * i + 4)); byte[] b = rightShift(a, i); in[4 * i] = b[0]; in[4 * i + 1] = b[1]; in[4 * i + 2] = b[2]; in[4 * i + 3] = b[3]; } for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { out[4 * j + i] = in[4 * i + j]; } } return out; } private byte[] rightShift(byte[] in, int times) { byte[] out = new byte[4]; out = Arrays.copyOfRange(in, 0, 4); for (int i = 0; i \u0026lt; times; i++) { out[0] = in[3]; out[1] = in[0]; out[2] = in[1]; out[3] = in[2]; in = Arrays.copyOfRange(out, 0, 4); } return out; } /* Mix Columns */ private byte[] mixColumns(byte[] in) { byte[] out = new byte[BITS]; byte[] temp = new byte[BITS]; for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { temp[4 * j + i] = in[4 * i + j]; } } in = temp; for (int j = 0; j \u0026lt; BITS / 4; j++) { out[4 * 0 + j] = (byte) ((gmul(in[4 * 0 + j], 2) ^ gmul(in[4 * 1 + j], 3) ^ in[4 * 2 + j] ^ in[4 * 3 + j]) \u0026amp; 0xff); out[4 * 1 + j] = (byte) ((in[4 * 0 + j] ^ gmul(in[4 * 1 + j], 2) ^ gmul(in[4 * 2 + j], 3) ^ in[4 * 3 + j]) \u0026amp; 0xff); out[4 * 2 + j] = (byte) ((in[4 * 0 + j] ^ in[4 * 1 + j] ^ gmul(in[4 * 2 + j], 2) ^ gmul(in[4 * 3 + j], 3)) \u0026amp; 0xff); out[4 * 3 + j] = (byte) ((gmul(in[4 * 0 + j], 3) ^ in[4 * 1 + j] ^ in[4 * 2 + j] ^ gmul(in[4 * 3 + j], 2)) \u0026amp; 0xff); } for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { temp[4 * j + i] = out[4 * i + j]; } } out = temp; return out; } /* Inverse Mix Columns */ private byte[] inverseMixColumns(byte[] in) { byte[] out = new byte[BITS]; byte[] temp = new byte[BITS]; for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { temp[4 * j + i] = in[4 * i + j]; } } in = temp; for (int j = 0; j \u0026lt; BITS / 4; j++) { out[4 * 0 + j] = (byte) ((gmul(in[4 * 0 + j], 14) ^ gmul(in[4 * 1 + j], 11) ^ gmul(in[4 * 2 + j], 13) ^ gmul(in[4 * 3 + j], 9)) \u0026amp; 0xff); out[4 * 1 + j] = (byte) ((gmul(in[4 * 0 + j], 9) ^ gmul(in[4 * 1 + j], 14) ^ gmul(in[4 * 2 + j], 11) ^ gmul(in[4 * 3 + j], 13)) \u0026amp; 0xff); out[4 * 2 + j] = (byte) ((gmul(in[4 * 0 + j], 13) ^ gmul(in[4 * 1 + j], 9) ^ gmul(in[4 * 2 + j], 14) ^ gmul(in[4 * 3 + j], 11)) \u0026amp; 0xff); out[4 * 3 + j] = (byte) ((gmul(in[4 * 0 + j], 11) ^ gmul(in[4 * 1 + j], 13) ^ gmul(in[4 * 2 + j], 9) ^ gmul(in[4 * 3 + j], 14)) \u0026amp; 0xff); } for (int i = 0; i \u0026lt; BITS / 4; i++) { for (int j = 0; j \u0026lt; BITS / 4; j++) { temp[4 * j + i] = out[4 * i + j]; } } out = temp; return out; } private byte[] hexStringToByteArray(String string) { int length = string.length(); int n = (int) Math.ceil((length + 1) / 2); byte[] result = new byte[n]; for (int i = length - 1; i \u0026gt;= 0; i -= 2) { if (i == 0) { result[i / 2] = (byte) ((Character.digit(\u0026#39;0\u0026#39;, 16) \u0026lt;\u0026lt; 4) + Character.digit(string.charAt(i), 16)); } else { result[i / 2] = (byte) ((Character.digit(string.charAt(i - 1), 16) \u0026lt;\u0026lt; 4) + Character.digit(string.charAt(i), 16)); } } return result; } /* * http://stackoverflow.com/questions/9655181/convert-from-byte-array-to-hex- * string-in-java */ public static String bytesToHex(byte[] bytes) { char[] hexChars = new char[bytes.length * 2]; for (int j = 0; j \u0026lt; bytes.length; j++) { int v = bytes[j] \u0026amp; 0xFF; hexChars[j * 2] = hexArray[v \u0026gt;\u0026gt;\u0026gt; 4]; hexChars[j * 2 + 1] = hexArray[v \u0026amp; 0x0F]; } return new String(hexChars); } private void printBytes(byte[] input) { for (int i = 0; i \u0026lt; input.length; i++) { System.out.print(byteToBits(input[i]) + \u0026#34; \u0026#34;); } System.out.println(); } private void printByte(String msg, byte input) { byte[] temp = new byte[1]; temp[0] = input; System.out.println(msg + \u0026#34;: \u0026#34; + bytesToHex(temp)); } private String byteToBits(byte b) { StringBuffer buffer = new StringBuffer(); for (int i = 0; i \u0026lt; 8; i++) buffer.append((int) (b \u0026gt;\u0026gt; (8 - (i + 1)) \u0026amp; 0x0001)); return buffer.toString(); } private byte[] getRoundKey(int round) { byte[] out = new byte[KEY_LENGTH]; out = Arrays.copyOfRange(word, 16 * round, 16 * round + 16); return out; } public static byte[] XORBytes(byte[] in1, byte[] in2) { byte[] out = new byte[BLOCK_LENGTH]; for (int i = 0; i \u0026lt; BLOCK_LENGTH; i++) { out[i] = (byte) ((in1[i] ^ in2[i]) \u0026amp; 0xff); } return out; } public byte[] encrypt(byte[] plainText, byte[] key) throws Exception { byte[] cipher = new byte[BLOCK_LENGTH]; this.word = expandKey(key); byte[] roundKey = getRoundKey(0); /* Round 0 */ cipher = XORBytes(plainText, roundKey); // System.out.println(\u0026#34;Round 0\\n\u0026#34; + bytesToHex(cipher));  /* Rounds 1 to 9 */ for (int i = 1; i \u0026lt; 10; i++) { // System.out.println(\u0026#34;Round \u0026#34; + i);  cipher = subBytes(cipher); // System.out.println(\u0026#34;SubBytes: \u0026#34; + bytesToHex(cipher));  cipher = shiftRows(cipher); // System.out.println(\u0026#34;ShiftRows: \u0026#34; + bytesToHex(cipher));  cipher = mixColumns(cipher); // System.out.println(\u0026#34;MixColumns: \u0026#34; + bytesToHex(cipher));  roundKey = getRoundKey(i); // System.out.println(\u0026#34;RoundKey: \u0026#34; + bytesToHex(roundKey));  cipher = XORBytes(cipher, roundKey); // System.out.println(\u0026#34;CIPHER: \u0026#34; + bytesToHex(cipher));  } /* Round 10 */ // System.out.println(\u0026#34;Round 10\u0026#34;);  cipher = subBytes(cipher); // System.out.println(\u0026#34;SubBytes: \u0026#34; + bytesToHex(cipher));  cipher = shiftRows(cipher); // System.out.println(\u0026#34;ShiftRows: \u0026#34; + bytesToHex(cipher));  roundKey = getRoundKey(10); // System.out.println(\u0026#34;RoundKey: \u0026#34; + bytesToHex(roundKey));  cipher = XORBytes(cipher, roundKey); // System.out.println(\u0026#34;CIPHER: \u0026#34; + bytesToHex(cipher));  return cipher; } public byte[] decrypt(byte[] cipher, byte[] key) throws Exception { byte[] plainText = new byte[BLOCK_LENGTH]; this.word = expandKey(key); byte[] roundKey = getRoundKey(10); /* Round 0 */ plainText = XORBytes(cipher, roundKey); /* Rounds 1 to 9 */ for (int i = 9; i \u0026gt; 0; i--) { plainText = inverseShiftRows(plainText); plainText = inverseSubBytes(plainText); roundKey = getRoundKey(i); plainText = XORBytes(plainText, roundKey); plainText = inverseMixColumns(plainText); } /* Round 10 */ plainText = inverseShiftRows(plainText); plainText = inverseSubBytes(plainText); roundKey = getRoundKey(0); plainText = XORBytes(plainText, roundKey); return plainText; } public static void main(String[] args) throws Exception { AES aes = new AES(); byte[] plainText = aes.hexStringToByteArray(\u0026#34;0123456789abcdeffedcba9876543210\u0026#34;); System.out.println(\u0026#34;PLAIN TEXT: \u0026#34; + bytesToHex(plainText)); byte[] key = aes.hexStringToByteArray(\u0026#34;0f1571c947d9e8590cb7add6af7f6798\u0026#34;); System.out.println(\u0026#34;KEY: \u0026#34; + bytesToHex(key)); byte[] cipher = aes.encrypt(plainText, key); System.out.println(\u0026#34;CIPHER TEXT: \u0026#34; + bytesToHex(cipher)); plainText = aes.decrypt(cipher, key); System.out.println(\u0026#34;DECRYPTED CIPHER TEXT: \u0026#34; + bytesToHex(plainText)); } } Word.java\npublic class Word { private byte[] word = null; public Word() { word = new byte[4]; } public Word(byte k0, byte k1, byte k2, byte k3) { this(); word[0] = k0; word[1] = k1; word[2] = k2; word[3] = k3; } public byte[] getWord() { return word; } public void setWord(byte[] word) { this.word = word; } public static byte[] wordToBytes(Word word) { return word.getWord(); } public static byte[] wordsToBytes(Word[] words) { byte[] out = new byte[4 * words.length]; for (int i = 0; i \u0026lt; words.length; i++) { byte[] temp = words[i].getWord(); out[4 * i] = temp[0]; out[4 * i + 1] = temp[1]; out[4 * i + 2] = temp[2]; out[4 * i + 3] = temp[3]; } return out; } public void rotWord() { byte[] temp = this.getWord(); byte[] newWord = new byte[4]; newWord[0] = temp[1]; newWord[1] = temp[2]; newWord[2] = temp[3]; newWord[3] = temp[0]; this.setWord(newWord); } public void subWord() { byte[] in = this.getWord(); byte[] out = new byte[4]; for (int i = 0; i \u0026lt; 4; i++) { byte a = in[i]; int row = (a \u0026gt;\u0026gt; 4) \u0026amp; 0x000F; int col = a \u0026amp; 0x000F; out[i] = (byte) AES.sBox[row * 16 + col]; } for (int i = 0; i \u0026lt; 4; i++) { this.word[i] = out[i]; } } public static Word XORWords(Word word1, Word word2) { Word outWord = new Word(); byte[] in1 = word1.getWord(); byte[] in2 = word2.getWord(); byte[] out = new byte[4]; for (int i = 0; i \u0026lt; 4; i++) { out[i] = (byte) ((in1[i] ^ in2[i]) \u0026amp; 0xff); } outWord.setWord(out); return outWord; } public String toString() { return AES.bytesToHex(this.getWord()); } } Output\nPLAIN TEXT: 0123456789ABCDEFFEDCBA9876543210 KEY: 0F1571C947D9E8590CB7ADD6AF7F6798 CIPHER TEXT: FF0B844A0853BF7C6934AB4364148FB9 DECRYPTED CIPHER TEXT: 0123456789ABCDEFFEDCBA9876543210  ",
    "ref": "/blog/2014-07-30-aes-implementation-in-java/"
  },{
    "title": "DES Implementation In Java",
    "date": "June 20, 2014",
    "description": "",
    "body": "DES.java\npublic class DES { /* Initial Permutation */ static final int[] IP = { 58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8, 57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7 }; /* Inverse Initial Permutation */ static final int[] IIP = { 40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29, 36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25 }; /* Expansion Permutation */ static final int[] E = { 32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17, 16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1 }; /* Permutation Function */ static final int[] P = { 16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10, 2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25 }; /* S-Boxes*/ static final int[] S1 = { 14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7, 0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8, 4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0, 15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13 }; static final int[] S2 = { 15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10, 3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5, 0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15, 13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9 }; static final int[] S3 = { 10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8, 13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1, 13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7, 1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12 }; static final int[] S4 = { 7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15, 13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9, 10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4, 3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14 }; static final int[] S5 = { 2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9, 14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6, 4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14, 11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3 }; static final int[] S6 = { 12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11, 10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8, 9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6, 4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13 }; static final int[] S7 = { 4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1, 13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6, 1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2, 6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12 }; static final int[] S8 = { 13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7, 1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2, 7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8, 2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11 }; /* Permuted Choice One */ static final int[] PC1 = { 57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4 }; /* Permuted Choice Two */ static final int[] PC2 = { 14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32 }; /* Schedule of Left Shifts */ static final int[] SHIFTS = { 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1 }; public DES() { } private byte[] performXOR(byte[] one, byte[] two) { byte[] result = new byte[one.length]; for (int i = 0 ; i \u0026lt; one.length ; i++) { result[i] = (byte) (one[i] ^ two[i]); } return result; } private byte[] permute(byte[] input, int[] mapping) { int byteCount = 1 + (mapping.length - 1) / 8; byte[] output = new byte[byteCount]; int pos; for (int i = 0 ; i \u0026lt; mapping.length ; i++) { pos = mapping[i] - 1; int value = getBitFromArray(input, pos); setBitInArray(output, i, value); } return output; } private int getBitFromArray(byte[] array, int pos) { int value; int bytePos = pos / 8; int bitPos = pos % 8; value = (array[bytePos] \u0026gt;\u0026gt; (8 - (bitPos + 1))) \u0026amp; 0x0001; /* eg: right shift selected byte 5 times to get 3rd bit * (bitPos = 2) at rightmost position and * then AND with 0x0001*/ return value; } private void setBitInArray(byte[] input, int pos, int value) { int bytePos = pos / 8; int bitPos = pos % 8; byte old = input[bytePos]; old = (byte) (((0xFF7F \u0026gt;\u0026gt; bitPos) \u0026amp; old) \u0026amp; 0x00FF); byte newByte = (byte) ((value \u0026lt;\u0026lt; (8 - (bitPos + 1))) | old); input[bytePos] = newByte; } private byte[] hexStringToByteArray(String string) { int length = string.length(); int n = (int)Math.ceil((length + 1) / 2); byte[] result = new byte[n]; for (int i = length - 1; i \u0026gt;= 0 ; i -= 2) { if (i == 0) { result[i / 2] = (byte) ((Character.digit(\u0026#39;0\u0026#39;, 16) \u0026lt;\u0026lt; 4) + Character.digit(string.charAt(i), 16)); } else { result[i / 2] = (byte) ((Character.digit(string.charAt(i - 1), 16) \u0026lt;\u0026lt; 4) + Character.digit(string.charAt(i), 16)); } } return result; } private void printBytes(byte[] input) { for (int i = 0 ; i \u0026lt; input.length; i++) { System.out.print(byteToBits(input[i]) + \u0026#34; \u0026#34;); } System.out.println(); } private String byteToBits(byte b) { StringBuffer buffer = new StringBuffer(); for (int i = 0 ; i \u0026lt; 8 ; i++) buffer.append((int)(b \u0026gt;\u0026gt; (8-(i+1)) \u0026amp; 0x0001)); return buffer.toString(); } private byte[] getBits(byte[] input, int startPos, int length) { int noOfBytes = (length-1)/8 + 1; byte[] output = new byte[noOfBytes]; for (int i = 0 ; i \u0026lt; length ; i++) { int value = getBitFromArray(input, startPos + i); setBitInArray(output, i, value); } return output; } private byte[] rotateLeft(byte[] input, int step, int length) { int noOfBytes = (length - 1) / 8 + 1; byte[] output = new byte[noOfBytes]; for (int i = 0 ; i \u0026lt; length ; i++) { int value = getBitFromArray(input, (i + step) % length); setBitInArray(output, i, value); } return output; } private byte[] concatBits(byte[] one, int oneLength, byte[] two, int twoLength) { int noOfBytes = (oneLength + twoLength - 1) / 8 + 1; byte[] output = new byte[noOfBytes]; int i = 0, j = 0; for (; i \u0026lt; oneLength ; i++) { int value = getBitFromArray(one, i); setBitInArray(output, j, value); j++; } for (i = 0 ; i \u0026lt; twoLength ; i++) { int value = getBitFromArray(two, i); setBitInArray(output, j, value); j++; } return output; } private byte[][] getSubKeys(byte[] masterKey) { int noOfSubKeys = SHIFTS.length; int keySize = PC1.length; byte[] key = permute(masterKey, PC1); byte[][] subKeys = new byte[noOfSubKeys][keySize]; byte[] leftHalf = getBits(key, 0, keySize/2); byte[] rightHalf = getBits(key, keySize/2, keySize/2); for (int i = 0 ; i \u0026lt; noOfSubKeys ; i++) { leftHalf = rotateLeft(leftHalf, SHIFTS[i], keySize/2); rightHalf = rotateLeft(rightHalf, SHIFTS[i], keySize/2); byte[] subKey = concatBits(leftHalf, keySize/2, rightHalf, keySize/2); subKeys[i] = permute(subKey, PC2); } return subKeys; } public byte[] crypt(byte[] message, byte[] key, String operation) { if (message.length \u0026lt; 8) { System.out.println(\u0026#34;Message should be atleast 64 bits\u0026#34;); System.exit(1); } if (key.length != 8) { System.out.println(\u0026#34;Key should be 64 bits\u0026#34;); System.exit(1); } int length = message.length; int n = (length + 7)/8 * 8; byte[] cipher = new byte[n]; if (length == 8) { return cryptText(message, key, operation); } int i = 0; int k = 0; while (i \u0026lt; length) { byte[] block = new byte[8]; byte[] result = new byte[8]; int j = 0; for (; j \u0026lt; 8 \u0026amp;\u0026amp; i \u0026lt; length; j++, i++) { block[j] = message[i]; } while (j \u0026lt; 8) { block[j++] = 0x00; } System.out.println(\u0026#34;BLOCK: \u0026#34;); printBytes(block); result = cryptText(block, key, operation); System.out.println(\u0026#34;RESULT: \u0026#34;); printBytes(result); for (j = 0 ; j \u0026lt; 8 \u0026amp;\u0026amp; k \u0026lt; cipher.length; j++, k++) { cipher[k] = result[j]; } } return cipher; } public byte[] cryptText(byte[] message, byte[] key, String operation) { if (message.length != 8) { System.out.println(\u0026#34;Message should be 64 bits\u0026#34;); System.exit(1); } if (key.length != 8) { System.out.println(\u0026#34;Key should be 64 bits\u0026#34;); System.exit(1); } byte[] result = null; int blockSize = IP.length; byte[][] subKeys = getSubKeys(key); int noOfRounds = subKeys.length; /** * Initial Permutation */ message = permute(message, IP); /** * Split message into two halves */ byte[] leftHalf = getBits(message, 0, blockSize/2); byte[] rightHalf = getBits(message, blockSize/2, blockSize/2); for (int i = 0 ; i \u0026lt; noOfRounds ; i++) { byte[] temp = rightHalf; /** * Expansion */ rightHalf = permute(rightHalf, E); /** * XOR rightHalf with roundKey */ byte[] roundKey = null; if (operation.equalsIgnoreCase(\u0026#34;encrypt\u0026#34;)) { roundKey = subKeys[i]; } else if (operation.equalsIgnoreCase(\u0026#34;decrypt\u0026#34;)) { roundKey = subKeys[noOfRounds - i - 1]; } else { System.out.println(\u0026#34;Unsupported operation\u0026#34;); System.exit(0); } rightHalf = performXOR(rightHalf, roundKey); /** * S-Box */ rightHalf = sBox(rightHalf); /** * Permutation */ rightHalf = permute(rightHalf, P); /** * XOR rightHalf with leftHalf */ rightHalf = performXOR(rightHalf, leftHalf); /** * L(i) = R(i-1) */ leftHalf = temp; } /** * 32 bit swap */ byte[] concatHalves = concatBits(rightHalf, blockSize/2, leftHalf, blockSize/2); /** * Inverse Initial Permutation */ result = permute(concatHalves, IIP); return result; } private byte[] sBox(byte[] input) { /** * Split input to 6-bit blocks */ input = split(input,6); byte[] output = new byte[input.length/2]; int leftHalf = 0; for (int i = 0; i \u0026lt; input.length ; i++) { byte block = input[i]; /** * row - first and last bits * column - 4 bits in the middle */ int row = 2 * (block \u0026gt;\u0026gt; 7 \u0026amp; 0x0001) + (block \u0026gt;\u0026gt; 2 \u0026amp; 0x0001); int col = block \u0026gt;\u0026gt; 3 \u0026amp; 0x000F; int[] selectedSBox = getSBox(i); int rightHalf = selectedSBox[16 * row + col]; if (i % 2 == 0) { leftHalf = rightHalf; } else { output[i/2] = (byte) (16 * leftHalf + rightHalf); leftHalf = 0; } } return output; } private int[] getSBox(int i) { switch (i) { case 0: return S1; case 1: return S2; case 2: return S3; case 3: return S4; case 4: return S5; case 5: return S6; case 6: return S7; case 7: return S8; default: return null; } } private byte[] split(byte[] input, int length) { int noOfBytes = (8 * input.length - 1) / length + 1; byte[] output = new byte[noOfBytes]; for (int i = 0 ; i \u0026lt; noOfBytes ; i++) { for (int j = 0; j \u0026lt; length ; j++) { int value = getBitFromArray(input, length * i + j); setBitInArray(output, 8 * i + j, value); } } return output; } public static void main(String[] args) { DES des = new DES(); byte[] message = des.hexStringToByteArray(\u0026#34;123456789ABCDEF\u0026#34;); System.out.println(\u0026#34;PLAIN TEXT:\u0026#34;); des.printBytes(message); byte[] key = des.hexStringToByteArray(\u0026#34;133457799BBCDFF1\u0026#34;); System.out.println(\u0026#34;KEY:\u0026#34;); des.printBytes(key); byte[] cipher = des.crypt(message, key, \u0026#34;encrypt\u0026#34;); System.out.println(\u0026#34;CIPHER TEXT:\u0026#34;); des.printBytes(cipher); byte[] result = des.crypt(cipher, key, \u0026#34;decrypt\u0026#34;); System.out.println(\u0026#34;DECRYPTED TEXT:\u0026#34;); des.printBytes(result); } } Output\ndhanoopbhaskar@dhanoop-laptop:~$ javac DES.java dhanoopbhaskar@dhanoop-laptop:~$ java DES PLAIN TEXT: 00000001 00100011 01000101 01100111 10001001 10101011 11001101 11101111 KEY: 00010011 00110100 01010111 01111001 10011011 10111100 11011111 11110001 CIPHER TEXT: 10000101 11101000 00010011 01010100 00001111 00001010 10110100 00000101 DECRYPTED TEXT: 00000001 00100011 01000101 01100111 10001001 10101011 11001101 11101111 dhanoopbhaskar@dhanoop-laptop:~$ ",
    "ref": "/blog/2014-06-20-des-implementation-in-java/"
  },{
    "title": "Total Views Crossed 50K !! Thanks for your support !!",
    "date": "May 19, 2014",
    "description": "",
    "body": " Today, the total page views crossed 50K :-)\nThanks for your support!\n ",
    "ref": "/blog/2014-05-19-total-views-crossed-50k-thanks-for-your-support/"
  },{
    "title": "Java - Common Problems (and Their Solutions)",
    "date": "April 26, 2014",
    "description": "",
    "body": "Original Link:\nhttp://docs.oracle.com/javase/tutorial/getStarted/problems/\nCheck the license before redistribution: http://docs.oracle.com/javase/tutorial/information/license.html\n",
    "ref": "/blog/2014-04-26-java-common-problems-and-their-solutions/"
  },{
    "title": "Java - Encryption and Decryption of an Image Using Another Image (Blowfish Algorithm)",
    "date": "April 9, 2014",
    "description": "",
    "body": "Here an image file is encrypted and decrypted using another image file as the password\n/* EncryptFile.java */ import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.IllegalBlockSizeException; import javax.crypto.NoSuchPaddingException; import javax.crypto.SecretKey; import javax.crypto.spec.SecretKeySpec; /** * * @author dhanoopbhaskar */ public class EncryptFile { SecretKey secretKey = null; Cipher cipher = null; String filePath = null; public EncryptFile(String filePath) { this.filePath = filePath; try { /** * Create a Blowfish key */ byte[] password = getPasswordFromFile(filePath); if (password == null) { System.out.println(\u0026#34;Unable to read the password file!\u0026#34;); System.exit(0); } secretKey = new SecretKeySpec(password, \u0026#34;Blowfish\u0026#34;); /** * Create an instance of cipher mentioning the name of algorithm * - Blowfish */ cipher = Cipher.getInstance(\u0026#34;Blowfish\u0026#34;); } catch (NoSuchPaddingException ex) { System.out.println(ex); } catch (NoSuchAlgorithmException ex) { System.out.println(ex); } } /** * * @param filePath * @return password * * Encrypts the file in srcPath and creates a file in destPath */ private byte[] getPasswordFromFile(String filePath) { File file = new File(filePath); InputStream inStream; /** * maximum allowable key size for blowfish is 56 bytes, * but java supports only upto 16 bytes. */ byte[] buffer = new byte[16]; try { inStream = new FileInputStream(file); int len = inStream.read(buffer); if (len \u0026lt;= 0) buffer = null; } catch (FileNotFoundException ex) { System.out.println(ex); } catch (IOException ex) { System.out.println(ex); } return buffer; } public static void main(String[] args) { String fileToEncrypt = \u0026#34;fileToEncrypt.jpg\u0026#34;; String encryptedFile = \u0026#34;encryptedFile.jpg\u0026#34;; String decryptedFile = \u0026#34;decryptedFile.jpg\u0026#34;; String directoryPath = \u0026#34;/home/dhanoopbhaskar/Desktop/blowfish/\u0026#34;; String passwordFile = \u0026#34;password.jpg\u0026#34;; EncryptFile encryptFile = new EncryptFile(directoryPath + passwordFile); System.out.println(\u0026#34;Starting Encryption...\u0026#34;); encryptFile.encrypt(directoryPath + fileToEncrypt, directoryPath + encryptedFile); System.out.println(\u0026#34;Encryption completed...\u0026#34;); encryptFile = new EncryptFile(directoryPath + passwordFile); System.out.println(\u0026#34;Starting Decryption...\u0026#34;); encryptFile.decrypt(directoryPath + encryptedFile, directoryPath + decryptedFile); System.out.println(\u0026#34;Decryption completed...\u0026#34;); } /** * * @param srcPath * @param destPath * * Encrypts the file in srcPath and creates a file in destPath */ private void encrypt(String srcPath, String destPath) { File rawFile = new File(srcPath); File encryptedFile = new File(destPath); InputStream inStream = null; OutputStream outStream = null; try { /** * Initialize the cipher for encryption */ cipher.init(Cipher.ENCRYPT_MODE, secretKey); /** * Initialize input and output streams */ inStream = new FileInputStream(rawFile); outStream = new FileOutputStream(encryptedFile); byte[] buffer = new byte[1024]; int len; while ((len = inStream.read(buffer)) \u0026gt; 0) { outStream.write(cipher.update(buffer, 0, len)); outStream.flush(); } outStream.write(cipher.doFinal()); inStream.close(); outStream.close(); } catch (IllegalBlockSizeException ex) { System.out.println(ex); } catch (BadPaddingException ex) { System.out.println(ex); } catch (InvalidKeyException ex) { System.out.println(ex); } catch (FileNotFoundException ex) { System.out.println(ex); } catch (IOException ex) { System.out.println(ex); } } /** * * @param srcPath * @param destPath * * Decrypts the file in srcPath and creates a file in destPath */ private void decrypt(String srcPath, String destPath) { File encryptedFile = new File(srcPath); File decryptedFile = new File(destPath); InputStream inStream = null; OutputStream outStream = null; try { /** * Initialize the cipher for decryption */ cipher.init(Cipher.DECRYPT_MODE, secretKey); /** * Initialize input and output streams */ inStream = new FileInputStream(encryptedFile); outStream = new FileOutputStream(decryptedFile); byte[] buffer = new byte[1024]; int len; while ((len = inStream.read(buffer)) \u0026gt; 0) { outStream.write(cipher.update(buffer, 0, len)); outStream.flush(); } outStream.write(cipher.doFinal()); inStream.close(); outStream.close(); } catch (IllegalBlockSizeException ex) { System.out.println(ex); } catch (BadPaddingException ex) { System.out.println(ex); } catch (InvalidKeyException ex) { System.out.println(ex); } catch (FileNotFoundException ex) { System.out.println(ex); } catch (IOException ex) { System.out.println(ex); } } } \n",
    "ref": "/blog/2014-04-09-java-encryption-and-decryption-of-an-image-using-another-image-blowfish-algorithm/"
  },{
    "title": "Java - Encryption and Decryption of an Image Using Blowfish Algorithm (using password)",
    "date": "April 5, 2014",
    "description": "",
    "body": "package com.java.blowfish; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.IllegalBlockSizeException; import javax.crypto.KeyGenerator; import javax.crypto.NoSuchPaddingException; import javax.crypto.SecretKey; import javax.crypto.spec.SecretKeySpec; /** * * @author dhanoopbhaskar */ public class EncryptFile { KeyGenerator keyGenerator = null; SecretKey secretKey = null; Cipher cipher = null; String masterPassword = null; public EncryptFile(String masterPassword) { this.masterPassword = masterPassword; try { /** * Create a Blowfish key */ keyGenerator = KeyGenerator.getInstance(\u0026#34;Blowfish\u0026#34;); secretKey = new SecretKeySpec(masterPassword.getBytes(), \u0026#34;Blowfish\u0026#34;); /** * Create an instance of cipher mentioning the name of algorithm * - Blowfish */ cipher = Cipher.getInstance(\u0026#34;Blowfish\u0026#34;); } catch (NoSuchPaddingException ex) { System.out.println(ex); } catch (NoSuchAlgorithmException ex) { System.out.println(ex); } } public static void main(String[] args) { String fileToEncrypt = \u0026#34;fileToEncrypt.jpg\u0026#34;; String encryptedFile = \u0026#34;encryptedFile.jpg\u0026#34;; String decryptedFile = \u0026#34;decryptedFile.jpg\u0026#34;; String directoryPath = \u0026#34;/home/dhanoopbhaskar/Desktop/blowfish/\u0026#34;; EncryptFile encryptFile = new EncryptFile(\u0026#34;thisismypassword\u0026#34;); System.out.println(\u0026#34;Starting Encryption...\u0026#34;); encryptFile.encrypt(directoryPath + fileToEncrypt, directoryPath + encryptedFile); System.out.println(\u0026#34;Encryption completed...\u0026#34;); encryptFile = new EncryptFile(\u0026#34;thisismypassword\u0026#34;); System.out.println(\u0026#34;Starting Decryption...\u0026#34;); encryptFile.decrypt(directoryPath + encryptedFile, directoryPath + decryptedFile); System.out.println(\u0026#34;Decryption completed...\u0026#34;); } /** * * @param srcPath * @param destPath * * Encrypts the file in srcPath and creates a file in destPath */ private void encrypt(String srcPath, String destPath) { File rawFile = new File(srcPath); File encryptedFile = new File(destPath); InputStream inStream = null; OutputStream outStream = null; try { /** * Initialize the cipher for encryption */ cipher.init(Cipher.ENCRYPT_MODE, secretKey); /** * Initialize input and output streams */ inStream = new FileInputStream(rawFile); outStream = new FileOutputStream(encryptedFile); byte[] buffer = new byte[1024]; int len; while ((len = inStream.read(buffer)) \u0026gt; 0) { outStream.write(cipher.update(buffer, 0, len)); outStream.flush(); } outStream.write(cipher.doFinal()); inStream.close(); outStream.close(); } catch (IllegalBlockSizeException ex) { System.out.println(ex); } catch (BadPaddingException ex) { System.out.println(ex); } catch (InvalidKeyException ex) { System.out.println(ex); } catch (FileNotFoundException ex) { System.out.println(ex); } catch (IOException ex) { System.out.println(ex); } } /** * * @param srcPath * @param destPath * * Decrypts the file in srcPath and creates a file in destPath */ private void decrypt(String srcPath, String destPath) { File encryptedFile = new File(srcPath); File decryptedFile = new File(destPath); InputStream inStream = null; OutputStream outStream = null; try { /** * Initialize the cipher for decryption */ cipher.init(Cipher.DECRYPT_MODE, secretKey); /** * Initialize input and output streams */ inStream = new FileInputStream(encryptedFile); outStream = new FileOutputStream(decryptedFile); byte[] buffer = new byte[1024]; int len; while ((len = inStream.read(buffer)) \u0026gt; 0) { outStream.write(cipher.update(buffer, 0, len)); outStream.flush(); } outStream.write(cipher.doFinal()); inStream.close(); outStream.close(); } catch (IllegalBlockSizeException ex) { System.out.println(ex); } catch (BadPaddingException ex) { System.out.println(ex); } catch (InvalidKeyException ex) { System.out.println(ex); } catch (FileNotFoundException ex) { System.out.println(ex); } catch (IOException ex) { System.out.println(ex); } } } \n",
    "ref": "/blog/2014-04-05-java-encryption-and-decryption-of-an-image-using-blowfish-algorithm-using-password/"
  },{
    "title": "A simple HTTP client and a server in C",
    "date": "February 13, 2014",
    "description": "",
    "body": "The HTTP server sends the files requested by the client, if it is available at the server. The HTTP client uses GET method for requesting files from the server. Only .html, .txt and .pdf files are implemented. On receiving the file, the client program opens it using firefox or gedit or acrobat reader, as per the file type. Note that the given programs were done in Linux (Debian) environment.\nhttpserver.c\n/**httpserver.c**/ #include\u0026#34;stdio.h\u0026#34; #include\u0026#34;stdlib.h\u0026#34; #include\u0026#34;sys/types.h\u0026#34; #include\u0026#34;sys/socket.h\u0026#34; #include\u0026#34;string.h\u0026#34; #include\u0026#34;netinet/in.h\u0026#34; #include\u0026#34;time.h\u0026#34; #include\u0026#34;dirent.h\u0026#34; #include\u0026#34;netdb.h\u0026#34; #define BUF_SIZE 1024  #define CLADDR_LEN 100  int createSocket(char * host, int port); int listenForRequest(int sockfd); char * getFileType(char * file); int main(int argc, char **argv) { DIR * dirptr; FILE * fileptr; time_t timenow; struct tm * timeinfo; time (\u0026amp;timenow); timeinfo = localtime(\u0026amp;timenow); char * header, * request, * path, * newpath, * host; char * dir, * temp; int port, sockfd, connfd; char get[3], http[9]; char filepath[BUF_SIZE]; char http_not_found[] = \u0026#34;HTTP/1.0 404 Not Found\\n\u0026#34;; char http_ok[] = \u0026#34;HTTP/1.0 200 OK\\n\u0026#34;; char buffer[BUF_SIZE]; char * contentType; if (argc != 4) { printf(\u0026#34;usage: [host] [directory] [portnumber]\\n\u0026#34;); exit(1); } header = (char*)malloc(BUF_SIZE*sizeof(char)); request = (char*)malloc(BUF_SIZE*sizeof(char)); path = (char*)malloc(BUF_SIZE*sizeof(char)); newpath = (char*)malloc(BUF_SIZE*sizeof(char)); host = argv[1]; dir = argv[2]; port = atoi(argv[3]); if ((dirptr = opendir(dir)) == NULL) { printf(\u0026#34;Directory Not Found!\\n\u0026#34;); exit(1); } sockfd = createSocket(host, port); for (;;) { printf(\u0026#34;--------------------------------------------------------\\n\u0026#34;); printf(\u0026#34;Waiting for a connection...\\n\u0026#34;); connfd = listenForRequest(sockfd); //gets the request from the connection  recv(connfd, request, 100, 0); printf(\u0026#34;Processing request...\\n\u0026#34;); //parses request  sscanf(request, \u0026#34;%s %s %s\u0026#34;, get, path, http); newpath = path + 1; //ignores the first slash  sprintf(filepath,\u0026#34;%s/%s\u0026#34;, dir, newpath); contentType = getFileType(newpath); sprintf(header, \u0026#34;Date: %sHostname: %s:%d\\nLocation: %s\\nContent-Type: %s\\n\\n\u0026#34;, asctime(timeinfo), host, port, newpath, contentType); if ((fileptr = fopen(filepath, \u0026#34;r\u0026#34;)) == NULL ) { printf(\u0026#34;File not found!\\n\u0026#34;); send(connfd, http_not_found, strlen(http_not_found), 0); //sends HTTP 404  } else { printf(\u0026#34;Sending the file...\\n\u0026#34;); send(connfd, http_ok, strlen(http_ok), 0); //sends HTTP 200 OK  recv(connfd, buffer, BUF_SIZE, 0); if ((temp = strstr(buffer, \u0026#34;OK\u0026#34;)) == NULL) { printf(\u0026#34;Operation aborted by the user!\\n\u0026#34;); break; } send(connfd, header, strlen(header), 0); //sends the header  recv(connfd, buffer, BUF_SIZE, 0); if ((temp = strstr(buffer, \u0026#34;OK\u0026#34;)) == NULL) { printf(\u0026#34;Operation aborted by the user!\\n\u0026#34;); break; } memset(\u0026amp;buffer, 0, sizeof(buffer)); while (!feof(fileptr)) { //sends the file  fread(\u0026amp;buffer, sizeof(buffer), 1, fileptr); send(connfd, buffer, sizeof(buffer), 0); memset(\u0026amp;buffer, 0, sizeof(buffer)); } printf(\u0026#34;File sent...\\n\u0026#34;); } printf(\u0026#34;Processing completed...\\n\u0026#34;); close(connfd); } close(sockfd); free(header); free(request); free(path); free(newpath); return 0; } int createSocket(char * host, int port) { int sockfd; struct sockaddr_in addr; struct hostent * host_ent; char * hostAddr; memset(\u0026amp;addr, 0, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_addr.s_addr = INADDR_ANY; addr.sin_port = htons((short)port); sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd \u0026lt; 0) { printf(\u0026#34;Error creating socket!\\n\u0026#34;); exit(1); } printf(\u0026#34;Socket created...\\n\u0026#34;); if (bind(sockfd, (struct sockaddr *)\u0026amp;addr, sizeof(addr)) \u0026lt; 0) { printf(\u0026#34;Error binding socket to port!\\n\u0026#34;); exit(1); } printf(\u0026#34;Binding done...\\n\u0026#34;); return sockfd; } int listenForRequest(int sockfd) { int conn; char hostip[32]; struct sockaddr_in addr; struct hostent * host; struct in_addr inAddr; int len; addr.sin_family = AF_INET; listen(sockfd, 5); //maximum 5 connections  len = sizeof(addr); if ((conn = accept(sockfd, (struct sockaddr *)\u0026amp;addr, \u0026amp;len)) \u0026lt; 0) { printf(\u0026#34;Error accepting connection!\\n\u0026#34;); exit(1); } printf(\u0026#34;Connection accepted...\\n\u0026#34;); inet_ntop(AF_INET, \u0026amp;(addr.sin_addr), hostip, 32); inet_pton(AF_INET, hostip, \u0026amp;inAddr); host = gethostbyaddr(\u0026amp;inAddr, sizeof(inAddr), AF_INET); printf(\u0026#34;---Connection received from: %s [IP= %s]---\\n\u0026#34;, host-\u0026gt;h_name, hostip); return conn; } char * getFileType(char * file) { char * temp; if ((temp = strstr(file, \u0026#34;.html\u0026#34;)) != NULL) { return \u0026#34;text/html\u0026#34;; } else if ((temp = strstr(file, \u0026#34;.pdf\u0026#34;)) != NULL) { return \u0026#34;application/pdf\u0026#34;; } else if ((temp = strstr(file, \u0026#34;.txt\u0026#34;)) != NULL) { return \u0026#34;text/html\u0026#34;; } } httpclient.c\n/**httpclient.c**/ #include\u0026#34;stdio.h\u0026#34;  #include\u0026#34;stdlib.h\u0026#34;  #include\u0026#34;sys/types.h\u0026#34;  #include\u0026#34;sys/socket.h\u0026#34;  #include\u0026#34;string.h\u0026#34;  #include\u0026#34;netinet/in.h\u0026#34;  #include\u0026#34;netdb.h\u0026#34; #define BUF_SIZE 1024  int get_request(char * url, char * port); int isValidIP(char * ip); int parseHeader(char * header); char * splitKeyValue(char * line, int index); void openFile(); FILE * fileptr; char keys[][25] = {\u0026#34;Date: \u0026#34;, \u0026#34;Hostname: \u0026#34;, \u0026#34;Location: \u0026#34;, \u0026#34;Content-Type: \u0026#34;}; char status[4] = {0, 0, 0, 0}; char contentFileType[100]; char path[1000]; int main(int argc, char**argv) { struct sockaddr_in addr, cl_addr; int sockfd, ret; struct hostent * server; char * url, * temp; int portNumber; char * fileName; char status_ok[] = \u0026#34;OK\u0026#34;; char buffer[BUF_SIZE]; char http_not_found[] = \u0026#34;HTTP/1.0 404 Not Found\u0026#34;; char http_ok[] = \u0026#34;HTTP/1.0 200 OK\u0026#34;; char location[] = \u0026#34;Location: \u0026#34;; char contentType[] = \u0026#34;Content-Type: \u0026#34;; int sPos, ePos; if (argc \u0026lt; 3) { printf(\u0026#34;usage: [URL] [port number]\\n\u0026#34;); exit(1); } url = argv[1]; portNumber = atoi(argv[2]); //checking the protocol specified  if ((temp = strstr(url, \u0026#34;http://\u0026#34;)) != NULL) { url = url + 7; } else if ((temp = strstr(url, \u0026#34;https://\u0026#34;)) != NULL) { url = url + 8; } //checking the port number  if (portNumber \u0026gt; 65536 || portNumber \u0026lt; 0) { printf(\u0026#34;Invalid Port Number!\u0026#34;); exit(1); } sockfd = get_request(url, argv[2]); memset(\u0026amp;buffer, 0, sizeof(buffer)); ret = recv(sockfd, buffer, BUF_SIZE, 0); if (ret \u0026lt; 0) { printf(\u0026#34;Error receiving HTTP status!\\n\u0026#34;); } else { printf(\u0026#34;%s\\n\u0026#34;, buffer); if ((temp = strstr(buffer, http_ok)) != NULL) { send(sockfd, status_ok, strlen(status_ok), 0); } else { close(sockfd); return 0; } } memset(\u0026amp;buffer, 0, sizeof(buffer)); ret = recv(sockfd, buffer, BUF_SIZE, 0); if (ret \u0026lt; 0) { printf(\u0026#34;Error receiving HTTP header!\\n\u0026#34;); } else { printf(\u0026#34;%s\\n\u0026#34;, buffer); if (parseHeader(buffer) == 0) { send(sockfd, status_ok, strlen(status_ok), 0); } else { printf(\u0026#34;Error in HTTP header!\\n\u0026#34;); close(sockfd); return 0; } } //printf(\u0026#34;file: [%s]\\n\u0026#34;, fileName);  fileptr = fopen(path, \u0026#34;w\u0026#34;); if (fileptr == NULL) { printf(\u0026#34;Error opening file!\\n\u0026#34;); close(sockfd); return 0; } memset(\u0026amp;buffer, 0, sizeof(buffer)); while (recv(sockfd, buffer, BUF_SIZE, 0) \u0026gt; 0) { //receives the file  if ((strstr(contentFileType, \u0026#34;text/html\u0026#34;)) != NULL) { fprintf(fileptr, \u0026#34;%s\u0026#34;, buffer); } else { fwrite(\u0026amp;buffer, sizeof(buffer), 1, fileptr); } memset(\u0026amp;buffer, 0, sizeof(buffer)); } fclose(fileptr); close(sockfd); openFile(); return 0; } int get_request(char * url, char * port) { int sockfd, bindfd; char * ptr, * host; char getrequest[1024]; struct sockaddr_in addr; if (isValidIP(url)) { //when an IP address is given  sprintf(getrequest, \u0026#34;GET / HTTP/1.0\\nHOST: %s\\n\\n\u0026#34;, url); } else { //when a host name is given  if ((ptr = strstr(url, \u0026#34;/\u0026#34;)) == NULL) { //when hostname does not contain a slash  sprintf(getrequest, \u0026#34;GET / HTTP/1.0\\nHOST: %s\\n\\n\u0026#34;, url); } else { //when hostname contains a slash, it is a path to file  strcpy(path, ptr); host = strtok(url, \u0026#34;/\u0026#34;); sprintf(getrequest, \u0026#34;GET %s HTTP/1.0\\nHOST: %s\\n\\n\u0026#34;, path, url); } } // creates a socket to the host  sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd \u0026lt; 0) { printf(\u0026#34;Error creating socket!\\n\u0026#34;); exit(1); } printf(\u0026#34;Socket created...\\n\u0026#34;); memset(\u0026amp;addr, 0, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_addr.s_addr = inet_addr(url); addr.sin_port = htons(atoi(port)); if (connect(sockfd, (struct sockaddr *) \u0026amp;addr, sizeof(addr)) \u0026lt; 0 ) { printf(\u0026#34;Connection Error!\\n\u0026#34;); exit(1); } printf(\u0026#34;Connection successful...\\n\\n\\n\u0026#34;); ptr = strtok(path, \u0026#34;/\u0026#34;); strcpy(path, ptr); //printf(\u0026#34;path=%s\\n\u0026#34;, path);  //fileptr = fopen(path, \u0026#34;w\u0026#34;);  //strcpy(fileName, path);  //sprintf(fileName, \u0026#34;%s\u0026#34;, path);  //int optval = 1;  //setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, \u0026amp;optval, sizeof optval);  // writes the HTTP GET Request to the sockfd  write(sockfd, getrequest, strlen(getrequest)); return sockfd; } int isValidIP(char * ip) { struct sockaddr_in addr; int valid = inet_pton(AF_INET, ip, \u0026amp;(addr.sin_addr)); return valid != 0; } int parseHeader(char * header) { //\u0026#34;Date: %sHostname: %s:%d\\nLocation: %s\\nContent-Type: %s\\n\\n\u0026#34;  char * line, * key, * value; char temp[100]; int i = 0; line = strtok(header, \u0026#34;\\n\u0026#34;); while (line != NULL) { //printf(\u0026#34;%s\\n\u0026#34;, line);  strcpy(temp, line); value = splitKeyValue(line, i); if (i == 3) { strcpy(contentFileType, value); } //printf(\u0026#34;value=%s\\n\u0026#34;, value);  line = strtok(NULL, \u0026#34;\\n\u0026#34;); i++; } for (i = 0; i \u0026lt; 4; i++) { if (status[i] == 0) return 1; //printf(\u0026#34;status[%d]=%d\\n\u0026#34;, i, status[i]);  } return 0; } char * splitKeyValue(char * line, int index) { char * temp; if ((temp = strstr(line, keys[index])) != NULL) { temp = temp + strlen(keys[index]); status[index] = 1; } return temp; } void openFile() { char * temp; char command[100]; char fileName[1000]; strcpy(fileName, path); //printf(\u0026#34;File Name: %s\\n\u0026#34;, fileName);  //printf(\u0026#34;Content Type: %s\\n\u0026#34;, contentFileType);  if ((temp = strstr(contentFileType, \u0026#34;text/html\u0026#34;)) != NULL) { if ((temp = strstr(fileName, \u0026#34;.txt\u0026#34;)) != NULL) { sprintf(command, \u0026#34;gedit %s\u0026#34;, fileName); } else { sprintf(command, \u0026#34;firefox %s\u0026#34;, fileName); } system(command); } else if ((temp = strstr(contentFileType, \u0026#34;application/pdf\u0026#34;)) != NULL) { sprintf(command, \u0026#34;acroread %s\u0026#34;, fileName); system(command); } else { printf(\u0026#34;The filetype %s is not supported. Failed to open %s!\\n\u0026#34;, contentFileType, fileName); } } Execution:\n(terminal 1)\ngcc httpserver.c -o server ./server 'www.dhanoop.com' '/home/dhanoopbhaskar/coding/http/dir/' 4444  (terminal 2)\ngcc httpclient.c -o client ./client '192.168.0.6/abc.txt' 4444 ./client '192.168.0.6/abc.html' 4444 ./client '192.168.0.6/abc.pdf' 4444  NB: The requested files abc.txt, abc.html and abc.pdf should be present in the path /home/dhanoopbhaskar/coding/http/dir/ (or whatever is given while running server).\n",
    "ref": "/blog/2014-02-13-a-simple-http-client-and-a-server-in-c/"
  },{
    "title": "A simple chat program in C (TCP)",
    "date": "January 22, 2014",
    "description": "",
    "body": "tcpserver.c\n#include\u0026#34;stdio.h\u0026#34; #include\u0026#34;stdlib.h\u0026#34; #include\u0026#34;sys/types.h\u0026#34; #include\u0026#34;sys/socket.h\u0026#34; #include\u0026#34;string.h\u0026#34; #include\u0026#34;netinet/in.h\u0026#34; #include\u0026#34;pthread.h\u0026#34; #define PORT 4444  #define BUF_SIZE 2000  #define CLADDR_LEN 100  void * receiveMessage(void * socket) { int sockfd, ret; char buffer[BUF_SIZE]; sockfd = (int) socket; memset(buffer, 0, BUF_SIZE); for (;;) { ret = recvfrom(sockfd, buffer, BUF_SIZE, 0, NULL, NULL); if (ret \u0026lt; 0) { printf(\u0026#34;Error receiving data!\\n\u0026#34;); } else { printf(\u0026#34;client: \u0026#34;); fputs(buffer, stdout); //printf(\u0026#34;\\n\u0026#34;);  } } } void main() { struct sockaddr_in addr, cl_addr; int sockfd, len, ret, newsockfd; char buffer[BUF_SIZE]; pid_t childpid; char clientAddr[CLADDR_LEN]; pthread_t rThread; sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd \u0026lt; 0) { printf(\u0026#34;Error creating socket!\\n\u0026#34;); exit(1); } printf(\u0026#34;Socket created...\\n\u0026#34;); memset(\u0026amp;addr, 0, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_addr.s_addr = INADDR_ANY; addr.sin_port = PORT; ret = bind(sockfd, (struct sockaddr *) \u0026amp;addr, sizeof(addr)); if (ret \u0026lt; 0) { printf(\u0026#34;Error binding!\\n\u0026#34;); exit(1); } printf(\u0026#34;Binding done...\\n\u0026#34;); printf(\u0026#34;Waiting for a connection...\\n\u0026#34;); listen(sockfd, 5); len = sizeof(cl_addr); newsockfd = accept(sockfd, (struct sockaddr *) \u0026amp;cl_addr, \u0026amp;len); if (newsockfd \u0026lt; 0) { printf(\u0026#34;Error accepting connection!\\n\u0026#34;); exit(1); } inet_ntop(AF_INET, \u0026amp;(cl_addr.sin_addr), clientAddr, CLADDR_LEN); printf(\u0026#34;Connection accepted from %s...\\n\u0026#34;, clientAddr); memset(buffer, 0, BUF_SIZE); printf(\u0026#34;Enter your messages one by one and press return key!\\n\u0026#34;); //creating a new thread for receiving messages from the client  ret = pthread_create(\u0026amp;rThread, NULL, receiveMessage, (void *) newsockfd); if (ret) { printf(\u0026#34;ERROR: Return Code from pthread_create() is %d\\n\u0026#34;, ret); exit(1); } while (fgets(buffer, BUF_SIZE, stdin) != NULL) { ret = sendto(newsockfd, buffer, BUF_SIZE, 0, (struct sockaddr *) \u0026amp;cl_addr, len); if (ret \u0026lt; 0) { printf(\u0026#34;Error sending data!\\n\u0026#34;); exit(1); } } close(newsockfd); close(sockfd); pthread_exit(NULL); return; } tcpclient.c\n#include\u0026#34;stdio.h\u0026#34;  #include\u0026#34;stdlib.h\u0026#34;  #include\u0026#34;sys/types.h\u0026#34;  #include\u0026#34;sys/socket.h\u0026#34;  #include\u0026#34;string.h\u0026#34;  #include\u0026#34;netinet/in.h\u0026#34;  #include\u0026#34;netdb.h\u0026#34; #include\u0026#34;pthread.h\u0026#34; #define PORT 4444  #define BUF_SIZE 2000  void * receiveMessage(void * socket) { int sockfd, ret; char buffer[BUF_SIZE]; sockfd = (int) socket; memset(buffer, 0, BUF_SIZE); for (;;) { ret = recvfrom(sockfd, buffer, BUF_SIZE, 0, NULL, NULL); if (ret \u0026lt; 0) { printf(\u0026#34;Error receiving data!\\n\u0026#34;); } else { printf(\u0026#34;server: \u0026#34;); fputs(buffer, stdout); //printf(\u0026#34;\\n\u0026#34;);  } } } int main(int argc, char**argv) { struct sockaddr_in addr, cl_addr; int sockfd, ret; char buffer[BUF_SIZE]; char * serverAddr; pthread_t rThread; if (argc \u0026lt; 2) { printf(\u0026#34;usage: client \u0026lt; ip address \u0026gt;\\n\u0026#34;); exit(1); } serverAddr = argv[1]; sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd \u0026lt; 0) { printf(\u0026#34;Error creating socket!\\n\u0026#34;); exit(1); } printf(\u0026#34;Socket created...\\n\u0026#34;); memset(\u0026amp;addr, 0, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_addr.s_addr = inet_addr(serverAddr); addr.sin_port = PORT; ret = connect(sockfd, (struct sockaddr *) \u0026amp;addr, sizeof(addr)); if (ret \u0026lt; 0) { printf(\u0026#34;Error connecting to the server!\\n\u0026#34;); exit(1); } printf(\u0026#34;Connected to the server...\\n\u0026#34;); memset(buffer, 0, BUF_SIZE); printf(\u0026#34;Enter your messages one by one and press return key!\\n\u0026#34;); //creating a new thread for receiving messages from the server  ret = pthread_create(\u0026amp;rThread, NULL, receiveMessage, (void *) sockfd); if (ret) { printf(\u0026#34;ERROR: Return Code from pthread_create() is %d\\n\u0026#34;, ret); exit(1); } while (fgets(buffer, BUF_SIZE, stdin) != NULL) { ret = sendto(sockfd, buffer, BUF_SIZE, 0, (struct sockaddr *) \u0026amp;addr, sizeof(addr)); if (ret \u0026lt; 0) { printf(\u0026#34;Error sending data!\\n\\t-%s\u0026#34;, buffer); } } close(sockfd); pthread_exit(NULL); return 0; }  (terminal 1)\ngcc tcpserver.c -o server -pthread ./server  (terminal 2)\ngcc tcpclient.c -o client -pthread ./client 192.168.0.4  NB: Here 192.168.0.4 is the IP address of the system where server code is running\n",
    "ref": "/blog/2014-01-22-a-simple-chat-program-in-c-tcp/"
  },{
    "title": "TCP in C (one server and multiple clients) ",
    "date": "January 16, 2014",
    "description": "",
    "body": "tcpserver.c\n#include\u0026#34;stdio.h\u0026#34; #include\u0026#34;stdlib.h\u0026#34; #include\u0026#34;sys/types.h\u0026#34; #include\u0026#34;sys/socket.h\u0026#34; #include\u0026#34;string.h\u0026#34; #include\u0026#34;netinet/in.h\u0026#34; #define PORT 4444  #define BUF_SIZE 2000  #define CLADDR_LEN 100  void main() { struct sockaddr_in addr, cl_addr; int sockfd, len, ret, newsockfd; char buffer[BUF_SIZE]; pid_t childpid; char clientAddr[CLADDR_LEN]; sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd \u0026lt; 0) { printf(\u0026#34;Error creating socket!\\n\u0026#34;); exit(1); } printf(\u0026#34;Socket created...\\n\u0026#34;); memset(\u0026amp;addr, 0, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_addr.s_addr = INADDR_ANY; addr.sin_port = PORT; ret = bind(sockfd, (struct sockaddr *) \u0026amp;addr, sizeof(addr)); if (ret \u0026lt; 0) { printf(\u0026#34;Error binding!\\n\u0026#34;); exit(1); } printf(\u0026#34;Binding done...\\n\u0026#34;); printf(\u0026#34;Waiting for a connection...\\n\u0026#34;); listen(sockfd, 5); for (;;) { //infinite loop  len = sizeof(cl_addr); newsockfd = accept(sockfd, (struct sockaddr *) \u0026amp;cl_addr, \u0026amp;len); if (newsockfd \u0026lt; 0) { printf(\u0026#34;Error accepting connection!\\n\u0026#34;); exit(1); } printf(\u0026#34;Connection accepted...\\n\u0026#34;); inet_ntop(AF_INET, \u0026amp;(cl_addr.sin_addr), clientAddr, CLADDR_LEN); if ((childpid = fork()) == 0) { //creating a child process  close(sockfd); //stop listening for new connections by the main process.  //the child will continue to listen.  //the main process now handles the connected client.  for (;;) { memset(buffer, 0, BUF_SIZE); ret = recvfrom(newsockfd, buffer, BUF_SIZE, 0, (struct sockaddr *) \u0026amp;cl_addr, \u0026amp;len); if(ret \u0026lt; 0) { printf(\u0026#34;Error receiving data!\\n\u0026#34;); exit(1); } printf(\u0026#34;Received data from %s: %s\\n\u0026#34;, clientAddr, buffer); ret = sendto(newsockfd, buffer, BUF_SIZE, 0, (struct sockaddr *) \u0026amp;cl_addr, len); if (ret \u0026lt; 0) { printf(\u0026#34;Error sending data!\\n\u0026#34;); exit(1); } printf(\u0026#34;Sent data to %s: %s\\n\u0026#34;, clientAddr, buffer); } } close(newsockfd); } } tcpclient.c\n#include\u0026#34;stdio.h\u0026#34;  #include\u0026#34;stdlib.h\u0026#34;  #include\u0026#34;sys/types.h\u0026#34;  #include\u0026#34;sys/socket.h\u0026#34;  #include\u0026#34;string.h\u0026#34;  #include\u0026#34;netinet/in.h\u0026#34;  #include\u0026#34;netdb.h\u0026#34; #define PORT 4444  #define BUF_SIZE 2000  int main(int argc, char**argv) { struct sockaddr_in addr, cl_addr; int sockfd, ret; char buffer[BUF_SIZE]; struct hostent * server; char * serverAddr; if (argc \u0026lt; 2) { printf(\u0026#34;usage: client \u0026lt; ip address \u0026gt;\\n\u0026#34;); exit(1); } serverAddr = argv[1]; sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd \u0026lt; 0) { printf(\u0026#34;Error creating socket!\\n\u0026#34;); exit(1); } printf(\u0026#34;Socket created...\\n\u0026#34;); memset(\u0026amp;addr, 0, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_addr.s_addr = inet_addr(serverAddr); addr.sin_port = PORT; ret = connect(sockfd, (struct sockaddr *) \u0026amp;addr, sizeof(addr)); if (ret \u0026lt; 0) { printf(\u0026#34;Error connecting to the server!\\n\u0026#34;); exit(1); } printf(\u0026#34;Connected to the server...\\n\u0026#34;); memset(buffer, 0, BUF_SIZE); printf(\u0026#34;Enter your message(s): \u0026#34;); while (fgets(buffer, BUF_SIZE, stdin) != NULL) { ret = sendto(sockfd, buffer, BUF_SIZE, 0, (struct sockaddr *) \u0026amp;addr, sizeof(addr)); if (ret \u0026lt; 0) { printf(\u0026#34;Error sending data!\\n\\t-%s\u0026#34;, buffer); } ret = recvfrom(sockfd, buffer, BUF_SIZE, 0, NULL, NULL); if (ret \u0026lt; 0) { printf(\u0026#34;Error receiving data!\\n\u0026#34;); } else { printf(\u0026#34;Received: \u0026#34;); fputs(buffer, stdout); printf(\u0026#34;\\n\u0026#34;); } } return 0; } First run the tcpserver code and then run multiple instances of the tcpclient code (i.e., in different terminal windows/tabs)\n",
    "ref": "/blog/2014-01-16-tcp-in-c-one-server-and-multiple-clients/"
  },{
    "title": "Socket Programming in C, TCP over a network (2 systems)",
    "date": "January 16, 2014",
    "description": "",
    "body": "tcpserver.c\n#include\u0026#34;stdio.h\u0026#34; #include\u0026#34;stdlib.h\u0026#34; #include\u0026#34;sys/types.h\u0026#34; #include\u0026#34;sys/socket.h\u0026#34; #include\u0026#34;string.h\u0026#34; #include\u0026#34;netinet/in.h\u0026#34; #define PORT 4444  #define BUF_SIZE 2000  void main() { struct sockaddr_in addr, cl_addr; int sockfd, len, ret, newsockfd; char buffer[BUF_SIZE]; sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd \u0026lt; 0) { printf(\u0026#34;Error creating socket!\\n\u0026#34;); exit(1); } printf(\u0026#34;Socket created...\\n\u0026#34;); memset(\u0026amp;addr, 0, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_addr.s_addr = INADDR_ANY; addr.sin_port = PORT; ret = bind(sockfd, (struct sockaddr *) \u0026amp;addr, sizeof(addr)); if (ret \u0026lt; 0) { printf(\u0026#34;Error binding!\\n\u0026#34;); exit(1); } printf(\u0026#34;Binding done...\\n\u0026#34;); printf(\u0026#34;Waiting for a connection...\\n\u0026#34;); listen(sockfd, 5); len = sizeof(cl_addr); newsockfd = accept(sockfd, (struct sockaddr *) \u0026amp;cl_addr, \u0026amp;len); if (newsockfd \u0026lt; 0) { printf(\u0026#34;Error accepting connection!\\n\u0026#34;); exit(1); } printf(\u0026#34;Connection accepted...\\n\u0026#34;); memset(buffer, 0, BUF_SIZE); ret = recv(newsockfd, buffer, BUF_SIZE, 0); if(ret \u0026lt; 0) { printf(\u0026#34;Error receiving data!\\n\u0026#34;); exit(1); } printf(\u0026#34;Received data: %s\\n\u0026#34;, buffer); ret = send(newsockfd, buffer, strlen(buffer), 0); if (ret \u0026lt; 0) { printf(\u0026#34;Error sending data!\\n\u0026#34;); exit(1); } printf(\u0026#34;Sent data: %s\\n\u0026#34;, buffer); close(sockfd); close(newsockfd); } tcpclient.c\n#include\u0026#34;stdio.h\u0026#34;  #include\u0026#34;stdlib.h\u0026#34;  #include\u0026#34;sys/types.h\u0026#34;  #include\u0026#34;sys/socket.h\u0026#34;  #include\u0026#34;string.h\u0026#34;  #include\u0026#34;netinet/in.h\u0026#34;  #include\u0026#34;netdb.h\u0026#34; #define PORT 4444  #define BUF_SIZE 2000  int main(int argc, char**argv) { struct sockaddr_in addr, cl_addr; int sockfd, ret; char buffer[BUF_SIZE]; struct hostent * server; char * serverAddr; if (argc \u0026lt; 2) { printf(\u0026#34;usage: client \u0026lt; ip address \u0026gt;\\n\u0026#34;); exit(1); } serverAddr = argv[1]; sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd \u0026lt; 0) { printf(\u0026#34;Error creating socket!\\n\u0026#34;); exit(1); } printf(\u0026#34;Socket created...\\n\u0026#34;); memset(\u0026amp;addr, 0, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_addr.s_addr = inet_addr(serverAddr); addr.sin_port = PORT; ret = connect(sockfd, (struct sockaddr *) \u0026amp;addr, sizeof(addr)); if (ret \u0026lt; 0) { printf(\u0026#34;Error connecting to the server!\\n\u0026#34;); exit(1); } printf(\u0026#34;Connected to the server...\\n\u0026#34;); memset(buffer, 0, BUF_SIZE); printf(\u0026#34;Enter your message: \u0026#34;); scanf(\u0026#34;%s\u0026#34;, buffer); ret = send(sockfd, buffer, strlen(buffer), 0); if (ret \u0026lt; 0) { printf(\u0026#34;Error sending data!\\n\u0026#34;); exit(1); } printf(\u0026#34;Sent data: %s\\n\u0026#34;, buffer); memset(buffer, 0, BUF_SIZE); ret = recv(sockfd, buffer, BUF_SIZE, 0); if(ret \u0026lt; 0) { printf(\u0026#34;Error receiving data!\\n\u0026#34;); exit(1); } printf(\u0026#34;Received data: %s\\n\u0026#34;, buffer); return 0; }  Output:\nterminal 1\ndhanoopbhaskar@dhanoop-laptop:~/coding/tcp_2sys$ gcc tcpserver.c -o server dhanoopbhaskar@dhanoop-laptop:~/coding/tcp_2sys$ gcc tcpclient.c -o client dhanoopbhaskar@dhanoop-laptop:~/coding/tcp_2sys$ ./server Socket created... Binding done... Waiting for a connection... Connection accepted... Received data: hi Sent data: hi dhanoopbhaskar@dhanoop-laptop:~/coding/tcp_2sys$ p-laptop:~/coding/tcp_2sys$ gcc tcpclient.c -o client dhanoopbhaskar@dhanoop-laptop:~/coding/tcp_2sys$ ./server Socket created... Binding done... Waiting for a connection... Connection accepted... Received data: hi Sent data: hi dhanoopbhaskar@dhanoop-laptop:~/coding/tcp_2sys$  terminal 2\ndhanoopbhaskar@dhanoop-laptop:~/coding/tcp_2sys$ ./client usage: client dhanoopbhaskar@dhanoop-laptop:~/coding/tcp_2sys$ ./client 192.168.0.4 Socket created... Connected to the server... Enter your message: hi Sent data: hi Received data: hi dhanoopbhaskar@dhanoop-laptop:~/coding/tcp_2sys$  NB: Here 192.168.0.4 is the IP address of the system where tcpserver code is running\n",
    "ref": "/blog/2014-01-16-socket-programming-in-c-tcp-over-a-network-2-systems/"
  },{
    "title": "Socket Programming In C (TCP)",
    "date": "January 5, 2014",
    "description": "",
    "body": "tcpserver.c\n#include\u0026#34;stdio.h\u0026#34; #include\u0026#34;stdlib.h\u0026#34; #include\u0026#34;sys/types.h\u0026#34; #include\u0026#34;sys/socket.h\u0026#34; #include\u0026#34;string.h\u0026#34; #include\u0026#34;netinet/in.h\u0026#34; #define PORT 4444  #define BUF_SIZE 20  void main() { struct sockaddr_in addr, cl_addr; int sockfd, len, ret, newsockfd; char buffer[BUF_SIZE]; sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd \u0026lt; 0) { printf(\u0026#34;Error creating socket!\\n\u0026#34;); exit(1); } printf(\u0026#34;Socket created...\\n\u0026#34;); memset(\u0026amp;addr, 0, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_addr.s_addr = INADDR_ANY; addr.sin_port = PORT; ret = bind(sockfd, (struct sockaddr *) \u0026amp;addr, sizeof(addr)); if (ret \u0026lt; 0) { printf(\u0026#34;Error binding!\\n\u0026#34;); exit(1); } printf(\u0026#34;Binding done...\\n\u0026#34;); printf(\u0026#34;Waiting for a connection...\\n\u0026#34;); listen(sockfd, 5); len = sizeof(cl_addr); newsockfd = accept(sockfd, (struct sockaddr *) \u0026amp;cl_addr, \u0026amp;len); if (newsockfd \u0026lt; 0) { printf(\u0026#34;Error accepting connection!\\n\u0026#34;); exit(1); } printf(\u0026#34;Connection accepted...\\n\u0026#34;); memset(buffer, 0, BUF_SIZE); ret = recv(newsockfd, buffer, BUF_SIZE, 0); if(ret \u0026lt; 0) { printf(\u0026#34;Error receiving data!\\n\u0026#34;); exit(1); } printf(\u0026#34;Received data: %s\\n\u0026#34;, buffer); } tcpclient.c\n#include\u0026#34;stdio.h\u0026#34; #include\u0026#34;stdlib.h\u0026#34; #include\u0026#34;sys/types.h\u0026#34; #include\u0026#34;sys/socket.h\u0026#34; #include\u0026#34;string.h\u0026#34; #include\u0026#34;netinet/in.h\u0026#34; #define PORT 4444  void main() { struct sockaddr_in addr, cl_addr; int sockfd, ret; char * buffer=\u0026#34;hi there?\u0026#34;; sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd \u0026lt; 0) { printf(\u0026#34;Error creating socket!\\n\u0026#34;); exit(1); } printf(\u0026#34;Socket created...\\n\u0026#34;); memset(\u0026amp;addr, 0, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_addr.s_addr = INADDR_ANY; addr.sin_port = PORT; ret = connect(sockfd, (struct sockaddr *) \u0026amp;addr, sizeof(addr)); if (ret \u0026lt; 0) { printf(\u0026#34;Error connecting to the server!\\n\u0026#34;); exit(1); } printf(\u0026#34;Connected to the server...\\n\u0026#34;); ret = send(sockfd, buffer, strlen(buffer), 0); if (ret \u0026lt; 0) { printf(\u0026#34;Error sending data!\\n\u0026#34;); exit(1); } printf(\u0026#34;Sent data: %s\\n\u0026#34;, buffer); } Executing the program\n(in first terminal)\ngcc tcpserver.c -o server ./server  (in second terminal)\ngcc tcpclient.c -o client ./client  ",
    "ref": "/blog/2014-01-05-socket-programming-in-c-tcp/"
  },{
    "title": "Initialization-on-demand holder idiom",
    "date": "August 31, 2013",
    "description": "",
    "body": "See Singleton PatternÂ here\u0026hellip;\npackage me.dhanoop.singleton; /** * * @author dhanoopbhaskar */ public class Singleton { private static class HelperHolder { public static Helper helper = new Helper(); } public static Helper getHelper() { return HelperHolder.helper; } public static void main(String[] args) { Runnable runnable = new Runnable() { @Override public void run() { Singleton.getHelper(); } }; new Thread(runnable).start(); new Thread(runnable).start(); new Thread(runnable).start(); } }  Here, as the helper object is static, an alternative is used - initialization-on-demand holder idiom. This is based on the fact that inner classes are not loaded until they are referenced.\n",
    "ref": "/blog/2013-08-31-initialization-on-demand-holder-idiom/"
  },{
    "title": "Eager initialization",
    "date": "August 31, 2013",
    "description": "",
    "body": "See Singleton Pattern here\u0026hellip;\nIf the program will always need an instance, or if the cost of creating the instance is not too large in terms of time/resources, the programmer can switch to eager initialization, which always creates an instance.\nSingleton.java\npackage me.dhanoop.singleton; /** * * @author dhanoopbhaskar */ public class Singleton { private static final Helper helper = new Helper(); public static Helper getHelper() { return helper; } public static void main(String[] args) { Runnable runnable = new Runnable() { @Override public void run() { Singleton.getHelper(); } }; new Thread(runnable).start(); new Thread(runnable).start(); new Thread(runnable).start(); } } Output:\nCreated Helper Object  Advantages:\n The instance is not constructed until the class is used. There is no need of synchronization, which means all the threads will see the same instance even without expensive locking mechanism. The final keyword means that the instance cannot be redefined, ensuring that one (and only one) instance ever exists.  ",
    "ref": "/blog/2013-08-31-eager-initialization/"
  },{
    "title": "Double-checked locking and Lazy initialization",
    "date": "August 31, 2013",
    "description": "",
    "body": "Lazy initialization is the tactic of delaying the creation of an object, the calculation of a value, or some other expensive process until the first time it is needed.\nThis is generally accomplished by maintaining a flag indicating whether the process has taken place. Each time the desired object is summoned, the flag is tested. If it is ready, it is returned. If not, it is initialized on the spot. In multithreaded code, access to the flag must be synchronized to guard against a race condition.\nRead more about lazy initialization here\u0026hellip;\nLet us consider Singleton Pattern again.\nSingleton.java\npackage me.dhanoop.singleton; /** * * @author dhanoopbhaskar */ public class Singleton { private static Helper helper = null; public static Helper getHelper() { if (helper == null) { synchronized (Singleton.class) { if (helper == null) { helper = new Helper(); } } } return helper; } public static void main(String[] args) { Runnable runnable = new Runnable() { @Override public void run() { Singleton.getHelper(); } }; new Thread(runnable).start(); new Thread(runnable).start(); new Thread(runnable).start(); } } Note: This method uses double-checked locking, which should NOT be used prior to JSE 5.0, as it is vulnerable to subtle bugs. The problem is that an out-of-order write may allow the instance reference to be returned before the Singleton constructor is executed.\nThe above code does NOT work in the presence of either optimizing compilers or shared memory multiprocessors.\nThe helper field can have a reference before completely creating an object of Helper class. Thus, a thread which invokes getHelper() could see a non-null reference to a Helper object, but see the default values for fields of the Helper object, rather than the values set in the constructor. This occurs due to compiler based re-orderings (for optimization) or on a multi-processor system, the memory writes may get re-ordered.\nFixing Double-Checked Locking using Volatile JDK5 and later extends the semantics for volatile so that the system will not allow a write of a volatile to be reordered with respect to any previous read or write, and a read of a volatile cannot be reordered with respect to any following read or write.\nWith this change, the Double-Checked Locking idiom can be made to work by declaring the helper field to be volatile. This does not work under JDK4 and earlier.\nSingleton.java\npackage me.dhanoop.singleton; /** * * @author dhanoopbhaskar */ public class Singleton { private static volatile Helper helper = null; public static Helper getHelper() { if (helper == null) { synchronized (Singleton.class) { if (helper == null) { helper = new Helper(); } } } return helper; } public static void main(String[] args) { Runnable runnable = new Runnable() { @Override public void run() { Singleton.getHelper(); } }; new Thread(runnable).start(); new Thread(runnable).start(); new Thread(runnable).start(); } }  Another solution:\nHereÂ the local variable result, which seems unnecessary, ensures that in cases where helper is already initialized, the volatile field is only accessed once, which can improve the method\u0026rsquo;s overall performance by as much as 25 percent.\npackage me.dhanoop.singleton; /** * * @author dhanoopbhaskar */ public class Singleton { private static volatile Helper helper = null; public static Helper getHelper() { Helper result = helper; if (result == null) { synchronized (Singleton.class) { result = helper; if (result == null) { helper = result = new Helper(); } } } return result; } public static void main(String[] args) { Runnable runnable = new Runnable() { @Override public void run() { Singleton.getHelper(); } }; new Thread(runnable).start(); new Thread(runnable).start(); new Thread(runnable).start(); } } Read more aboutÂ Double-Checked Locking here\u0026hellip;\n",
    "ref": "/blog/2013-08-31-double-checked-locking-and-lazy-initialization/"
  },{
    "title": "Singleton Pattern",
    "date": "August 31, 2013",
    "description": "",
    "body": "In software engineering, the singleton pattern is a design pattern that restricts a class from creating more than one object (Instantiation is restricted to one object).Â Such a design is generally used in a software system which operates more efficiently when only one object exists. It is useful when exactly one object is needed to coordinate actions across the system.\nRead more about singleton pattern here\u0026hellip;\nJava implementation\n1. Single Threaded version\nHelper.java\npackage me.dhanoop.singleton; /** * * @author dhanoopbhaskar */ public class Helper { public Helper() { System.out.println(\u0026#34;Created Helper Object\u0026#34;); } }  Singleton.java\npackage me.dhanoop.singleton; /** * * @author dhanoopbhaskar */ public class Singleton { private Helper helper = null; public Helper getHelper() { if (helper == null) { helper = new Helper(); } return helper; } public static void main(String[] args) { Singleton instance1 = new Singleton(); Helper helper1 = instance1.getHelper(); Helper helper2 = instance1.getHelper(); Helper helper3 = instance1.getHelper(); } } Output:\nCreated Helper Object  2. Multi-threaded version\nSingleton.java\npackage me.dhanoop.singleton; /** * * @author dhanoopbhaskar */ public class Singleton { private static Helper helper = null; public static Helper getHelper() { if (helper == null) { helper = new Helper(); } return helper; } public static void main(String[] args) { Runnable runnable = new Runnable() { @Override public void run() { Singleton.getHelper(); } }; new Thread(runnable).start(); new Thread(runnable).start(); new Thread(runnable).start(); } } Output:\nCreated Helper Object Created Helper Object Created Helper Object  Note: The output may vary depending on the execution of threads. Sometimes you will get only two lines in the output.\n The above is not a desired output. The Helper object should be created only once.\n 3. Corrected multi-threaded version\nSingleton.java\npackage me.dhanoop.singleton; /** * * @author dhanoopbhaskar */ public class Singleton { private static Helper helper = null; public static synchronized Helper getHelper() { if (helper == null) { helper = new Helper(); } return helper; } public static void main(String[] args) { Runnable runnable = new Runnable() { @Override public void run() { Singleton.getHelper(); } }; new Thread(runnable).start(); new Thread(runnable).start(); new Thread(runnable).start(); } } Output:\nCreated Helper Object  Note:Â The code above performs synchronization every timeÂ getHelper()Â is called. The double-checked locking idiom tries to avoid synchronization after the helper is allocated.\n",
    "ref": "/blog/2013-08-31-singleton-pattern/"
  },{
    "title": "Software Design Pattern",
    "date": "August 31, 2013",
    "description": "",
    "body": " A software design pattern is a general reusable solution to a commonly occurring problem within a given context in software design. A design pattern is not a finished or completed design. It is actually a description or template for solution to a problem.\n Design patterns are of many types, such as:\n Algorithm strategy patterns Computational design patterns Execution patterns Implementation strategy patterns Structural design patterns  Read more about design patterns here\u0026hellip;\n",
    "ref": "/blog/2013-08-31-software-design-pattern/"
  },{
    "title": "[SOLVED] Missing verify.dll",
    "date": "August 29, 2013",
    "description": "",
    "body": "Error: The program can\u0026rsquo;t start because verify.dll is missing from your computer. TryÂ reinstallingÂ the program to fix this problem.\nThis error also occurred when I tried to run a program using Java Virtual Machine Launcher.\nThe permanent solution to this error is adding the pathÂ JDK_HOME\\jre\\binÂ (e.g. C:\\Java\\jdk1.7.0\\jre\\bin; - in my case) to theÂ System Environment Variable -Â PATH\n",
    "ref": "/blog/2013-08-29-solved-missing-verify-dll/"
  },{
    "title": "[SOLVED] Could not open jvm.cfg",
    "date": "August 29, 2013",
    "description": "",
    "body": "Error: could not open \u0026lsquo;C:\\Java\\jre7\\lib\\i386\\jvm.cfg\u0026rsquo; This error occurred when I tried to run a program using Java Virtual Machine Launcher.\nSolution: As a temporary fix what I did was searching for the file jvm.cfg (which was found somewhere under JDK_HOME) and made the file available in the path mentioned in the error message.\nThe following is the content of the file jvm.cfg\n-client KNOWN -server KNOWN -hotspot ALIASED_TO -client -classic WARN -native ERROR -green ERROR  The permanent solution to this error is adding the path JDK_HOME\\jre\\bin (e.g. C:\\Java\\jdk1.7.0\\jre\\bin; - in my case) to the System Environment Variable - PATH\n",
    "ref": "/blog/2013-08-29-solved-could-not-open-jvm-cfg/"
  },{
    "title": "Java - Avoid multiple occurrence of some character in a String",
    "date": "August 29, 2013",
    "description": "",
    "body": "The following is a Java method/function which avoids multiple occurrence (in a row) of some character in an input String. The parameters to the method (i.e., inputs) to the method/function include:\n input - The parent String under consideration character - The character of which multiple occurrence (in a row) should be avoided.  public static String avoidMultipleOccurrence(String input, char character) { if (input == null) { return null; } if (input.length() == 0) { return \u0026#34;\u0026#34;; } StringBuilder output = new StringBuilder(); output.append(input.charAt(0)); for (int idx = 1; idx \u0026lt; input.length(); idx++) { if (Character.toString(input.charAt(idx)).equals( \u0026#34;\u0026#34; + character)) { if(input.charAt(idx) != input.charAt(idx-1)) { output.append(input.charAt(idx)); } } else { output.append(input.charAt(idx)); } } return output.toString(); } Sample Input: \u0026ldquo;theeee insaneeeee teeeeechieeeee\u0026rdquo;\nCharacter selected: \u0026lsquo;e\u0026rsquo;\npublic static void main(String[] args) { System.out.println(avoidMultipleOccurrence( \u0026#34;theeee insaneeeee teeeeechieeeee\u0026#34;, \u0026#39;e\u0026#39;)); } Output:Â the insane techie\n",
    "ref": "/blog/2013-08-29-java-avoid-multiple-occurrence-of-some-character-in-a-string/"
  },{
    "title": "Another Milestone",
    "date": "August 20, 2013",
    "description": "",
    "body": " Within the time period from Aug 19, 2013 12:30 AM IST to Aug 19, 2013 11:30 PM IST, the blog had 1K+ hits :) Out of which 900+ were from United States!!!\n \nFrom today, the 20th of August 2013, onwards the blog will be available under another domain - https://theinsanetechie.in\n",
    "ref": "/blog/2013-08-20-another-milestone/"
  },{
    "title": "Independence Day Wishes",
    "date": "August 15, 2013",
    "description": "",
    "body": "à´µà´¨àµà´¦àµ‡ à´®à´¾à´¤à´°à´‚!\nà´¸àµà´œà´²à´¾à´‚ à´¸àµà´«à´²à´¾à´‚, à´®à´²à´¯à´œ à´¶àµ€à´¤à´³à´¾à´‚,\nà´¸à´¸àµà´¯ à´¶àµà´¯à´¾à´®à´³à´¾à´‚, à´®à´¾à´¤à´°à´‚!\nà´¶àµà´­àµà´°à´œàµà´¯àµ‹à´¤àµà´¸àµà´¨ à´ªàµà´³à´•à´¿à´¤à´¯à´¾à´®à´¿à´£à´¿à´‚,\nà´«àµà´²àµà´²à´•àµà´¸àµà´®à´¿à´¤ à´¦àµà´°àµà´®à´¤à´² à´¶àµ‹à´­à´¿à´£à´¿à´‚,\nà´¸àµà´¹à´¾à´¸à´¿à´¨à´¿à´‚, à´¸àµà´®à´¦àµà´° à´­à´¾à´·à´¿à´£à´¿à´‚ ,\nà´¸àµà´–à´¦à´¾à´‚, à´µà´°à´¦à´¾à´‚ ,à´®à´¾à´¤à´°à´‚!\nà´¸à´ªàµà´¤à´•àµ‹à´Ÿà´¿à´•à´¾à´¨àµà´¤ à´•à´³ à´•à´³ à´¨à´¿à´¨à´¾à´¦ à´•à´°à´¾à´³àµ†\nà´¦àµà´µà´¿à´¸à´ªàµà´¤à´•àµ‹à´Ÿà´¿ à´­àµà´œàµˆà´°àµâ€ à´§àµƒà´¤-à´–à´¾à´° à´•à´°à´µà´²àµ†\nà´…à´¬à´² à´•àµ‡à´£ à´®à´¾ à´‡à´¤à´¾ à´¬à´²àµ†\nà´¬à´¹àµà´¬à´² à´§à´°à´¿à´£à´¿à´‚, à´¨à´®à´¾à´®à´¿ à´¤à´°à´¿à´£à´¿à´‚,\nà´°à´¿à´ªàµà´¤à´³à´µà´¾à´°à´¿à´£à´¿à´‚ à´®à´¾à´¤à´°à´‚ !\nà´¤àµà´®à´¿ à´µà´¿à´¦àµà´¯, à´¤àµà´®à´¿ à´§à´°àµâ€à´®àµà´®,\nà´¤àµà´®à´¿ à´¹àµƒà´¦à´¿ , à´¤àµà´®à´¿ à´®à´°àµâ€à´®àµà´® ,\nà´¤àµà´µà´‚ à´¹à´¿ à´ªàµà´°à´¾à´£ à´¶à´¾à´°à´¿à´°àµ†!\nà´¬à´¾à´¹àµà´¤àµ† à´¤àµà´®à´¿ à´®à´¾ à´¶à´•àµà´¤à´¿ ,\nà´¹àµƒà´¦à´¯àµ‡ à´¤àµà´®à´¿ à´®à´¾ à´­à´•àµà´¤à´¿,\nà´¤àµ‹à´®à´°àµà´¯ à´ªàµà´°à´¤à´¿à´® à´—à´¾à´°à´¿ à´®à´¨àµà´¦à´¿à´°àµ‡ à´®à´¨àµà´¦à´¿à´°àµ‡!\nà´¤àµà´µà´‚ à´¹à´¿ à´¦àµà´°àµâ€à´—àµà´— à´¦à´¶à´ªàµà´°à´¹à´°à´£ à´§à´°à´¿à´£à´¿,\nà´•à´®à´², à´•à´®à´²à´¾à´¦à´³à´µà´¿à´¹à´¾à´°à´¿à´£à´¿,\nà´µà´¾à´£à´¿, à´µà´¿à´¦àµà´¯à´¦à´¾à´¯à´¿à´¨à´¿ à´¨à´®à´¾à´®à´¿ à´¤àµà´µà´‚,\nà´¨à´®à´¾à´®à´¿ à´•à´®à´²à´‚, à´…à´®à´²à´‚, à´…à´¤àµà´²à´¾à´‚,\nà´¸àµà´œà´²à´¾à´‚, à´¸àµà´«à´²à´¾à´‚, à´®à´¾à´¤à´°à´‚,\nà´µà´¨àµà´¦àµ‡ à´®à´¾à´¤à´°à´‚!\nà´¶àµà´¯à´¾à´®à´³à´‚, à´¸à´°à´³à´‚, à´¸àµà´¸àµà´®à´¿à´¤à´‚, à´­àµ‚à´·à´¿à´¤à´‚,\nà´§à´°à´£à´¿à´‚, à´­à´°à´£à´¿à´‚, à´®à´¾à´¤à´°à´‚!\nà´œà´¯àµâ€Œ à´¹à´¿à´¨àµà´¦àµâ€Œ !\n\nMother, I bow to thee!\nRich with thy hurrying streams,\nbright with orchard gleams,\nCool with thy winds of delight,\nDark fields waving Mother of might,\nMother free.\nGlory of moonlight dreams,\nOver thy branches and lordly streams,\nClad in thy blossoming trees,\nMother, giver of ease\nLaughing low and sweet!\nMother I kiss thy feet,\nSpeaker sweet and low!\nMother, to thee I bow.\nWho hath said thou art weak in thy lands\nWhen the sword flesh out in the seventy million hands\nAnd seventy million voices roar\nThy dreadful name from shore to shore?\nWith many strengths who art mighty and stored,\nTo thee I call Mother and Lord!\nThough who savest, arise and save!\nTo her I cry who ever her foeman drove\nBack from plain and Sea\nAnd shook herself free.\nThou art wisdom, thou art law,\nThou art heart, our soul, our breath\nThough art love divine, the awe\nIn our hearts that conquers death.\nThine the strength that nerves the arm,\nThine the beauty, thine the charm.\nEvery image made divine\nIn our temples is but thine.\nThou art Durga, Lady and Queen,\nWith her hands that strike and her\nswords of sheen,\nThou art Lakshmi lotus-throned,\nAnd the Muse a hundred-toned,\nPure and perfect without peer,\nMother lend thine ear,\nRich with thy hurrying streams,\nBright with thy orchard gleems,\nDark of hue O candid-fair\nIn thy soul, with jewelled hair\nAnd thy glorious smile divine,\nLovilest of all earthly lands,\nShowering wealth from well-stored hands!\nMother, mother mine!\nMother sweet, I bow to thee,\nMother great and free!\nJai Hind!\n",
    "ref": "/blog/2013-08-15-independence-day-wishes/"
  },{
    "title": "Java - Encryption and Decryption of an Image Using Blowfish Algorithm",
    "date": "August 11, 2013",
    "description": "",
    "body": "EncryptFile.java\npackage com.java.blowfish; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.IllegalBlockSizeException; import javax.crypto.KeyGenerator; import javax.crypto.NoSuchPaddingException; import javax.crypto.SecretKey; /** * * @author dhanoopbhaskar */ public class EncryptFile { KeyGenerator keyGenerator = null; SecretKey secretKey = null; Cipher cipher = null; public EncryptFile() { try { /** * Create a Blowfish key */ keyGenerator = KeyGenerator.getInstance(\u0026#34;Blowfish\u0026#34;); secretKey = keyGenerator.generateKey(); /** * Create an instance of cipher mentioning the name of algorithm * - Blowfish */ cipher = Cipher.getInstance(\u0026#34;Blowfish\u0026#34;); } catch (NoSuchPaddingException ex) { System.out.println(ex); } catch (NoSuchAlgorithmException ex) { System.out.println(ex); } } public static void main(String[] args) { String fileToEncrypt = \u0026#34;fileToEncrypt.jpg\u0026#34;; String encryptedFile = \u0026#34;encryptedFile.jpg\u0026#34;; String decryptedFile = \u0026#34;decryptedFile.jpg\u0026#34;; String directoryPath = \u0026#34;C:/Users/dhanoopbhaskar/Desktop/blowfish/\u0026#34;; EncryptFile encryptFile = new EncryptFile(); System.out.println(\u0026#34;Starting Encryption...\u0026#34;); encryptFile.encrypt(directoryPath + fileToEncrypt, directoryPath + encryptedFile); System.out.println(\u0026#34;Encryption completed...\u0026#34;); System.out.println(\u0026#34;Starting Decryption...\u0026#34;); encryptFile.decrypt(directoryPath + encryptedFile, directoryPath + decryptedFile); System.out.println(\u0026#34;Decryption completed...\u0026#34;); } /** * * @param srcPath * @param destPath * * Encrypts the file in srcPath and creates a file in destPath */ private void encrypt(String srcPath, String destPath) { File rawFile = new File(srcPath); File encryptedFile = new File(destPath); InputStream inStream = null; OutputStream outStream = null; try { /** * Initialize the cipher for encryption */ cipher.init(Cipher.ENCRYPT_MODE, secretKey); /** * Initialize input and output streams */ inStream = new FileInputStream(rawFile); outStream = new FileOutputStream(encryptedFile); byte[] buffer = new byte[1024]; int len; while ((len = inStream.read(buffer)) \u0026gt; 0) { outStream.write(cipher.update(buffer, 0, len)); outStream.flush(); } outStream.write(cipher.doFinal()); inStream.close(); outStream.close(); } catch (IllegalBlockSizeException ex) { System.out.println(ex); } catch (BadPaddingException ex) { System.out.println(ex); } catch (InvalidKeyException ex) { System.out.println(ex); } catch (FileNotFoundException ex) { System.out.println(ex); } catch (IOException ex) { System.out.println(ex); } } /** * * @param srcPath * @param destPath * * Decrypts the file in srcPath and creates a file in destPath */ private void decrypt(String srcPath, String destPath) { File encryptedFile = new File(srcPath); File decryptedFile = new File(destPath); InputStream inStream = null; OutputStream outStream = null; try { /** * Initialize the cipher for decryption */ cipher.init(Cipher.DECRYPT_MODE, secretKey); /** * Initialize input and output streams */ inStream = new FileInputStream(encryptedFile); outStream = new FileOutputStream(decryptedFile); byte[] buffer = new byte[1024]; int len; while ((len = inStream.read(buffer)) \u0026gt; 0) { outStream.write(cipher.update(buffer, 0, len)); outStream.flush(); } outStream.write(cipher.doFinal()); inStream.close(); outStream.close(); } catch (IllegalBlockSizeException ex) { System.out.println(ex); } catch (BadPaddingException ex) { System.out.println(ex); } catch (InvalidKeyException ex) { System.out.println(ex); } catch (FileNotFoundException ex) { System.out.println(ex); } catch (IOException ex) { System.out.println(ex); } } } Output:\nStarting Encryptionâ€¦ Encryption completedâ€¦ Starting Decryptionâ€¦ Decryption completedâ€¦  Before Encryption\n\nAfter Encryption\n\nThe method doFinal() should not be used in loop or repeatedly. If we have to encrypt/decrypt multiple blocks we use update() method.\noutStream.write(cipher.update(buffer, 0, len));  After everything is done we call doFinal() method.\noutStream.write(cipher.doFinal());  If we use doFinal repeatedly, the encryption will work without errors. But decryption will fail throwing exception - javax.crypto.BadPaddingException\nSee related posts:\n  Java - Encryption and Decryption of an Image Using Blowfish Algorithm (using password)\n  Java - Encryption and Decryption of an Image Using Another Image (Blowfish Algorithm)\n  ",
    "ref": "/blog/2013-08-11-java-encryption-and-decryption-of-an-image-using-blowfish-algorithm/"
  },{
    "title": "Java - Blowfish Encryption Algorithm",
    "date": "August 11, 2013",
    "description": "",
    "body": "BlowfishAlgorithm.java\npackage com.java.blowfish; import com.sun.org.apache.xml.internal.security.exceptions.Base64DecodingException; import com.sun.org.apache.xml.internal.security.utils.Base64; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.IllegalBlockSizeException; import javax.crypto.KeyGenerator; import javax.crypto.NoSuchPaddingException; import javax.crypto.SecretKey; /** * * @author dhanoopbhaskar */ public class BlowfishAlgorithm { KeyGenerator keyGenerator = null; SecretKey secretKey = null; Cipher cipher = null; public BlowfishAlgorithm() { try { /** * Create a Blowfish key */ keyGenerator = KeyGenerator.getInstance(\u0026#34;Blowfish\u0026#34;); secretKey = keyGenerator.generateKey(); /** * Create an instance of cipher mentioning the name of algorithm * - Blowfish */ cipher = Cipher.getInstance(\u0026#34;Blowfish\u0026#34;); } catch (NoSuchPaddingException ex) { System.out.println(ex); } catch (NoSuchAlgorithmException ex) { System.out.println(ex); } } /** * * @param plainText * @return cipherBytes */ public byte[] encryptText(String plainText) { byte[] cipherBytes = null; try { /** * Initialize the cipher for encryption */ cipher.init(Cipher.ENCRYPT_MODE, secretKey); /** * Convert the text string to byte format */ byte[] plainBytes = plainText.getBytes(); /** * Perform encryption with method doFinal() */ cipherBytes = cipher.doFinal(plainBytes); } catch (IllegalBlockSizeException ex) { System.out.println(ex); } catch (BadPaddingException ex) { System.out.println(ex); } catch (InvalidKeyException ex) { System.out.println(ex); } return cipherBytes; } /** * * @param cipherBytes * @return plainText */ public String decryptText(byte[] cipherBytes) { String plainText = null; try { /** * Initialize the cipher for decryption */ cipher.init(Cipher.DECRYPT_MODE, secretKey); /** * Perform decryption with method doFinal() */ byte[] plainBytes = cipher.doFinal(cipherBytes); /** * Convert encrypted text to string format */ plainText = new String(plainBytes); } catch (IllegalBlockSizeException ex) { System.out.println(ex); } catch (BadPaddingException ex) { System.out.println(ex); } catch (InvalidKeyException ex) { System.out.println(ex); } return plainText; } /** * * @param plainText * @return cipherText */ public String encrypt(String plainText) { String cipherText = null; byte[] cipherBytes = encryptText(plainText); cipherText = bytesToString(cipherBytes); return cipherText; } /** * * @param cipherText * @return plainText */ public String decrypt(String cipherText) { String plainText = null; byte[] cipherBytes = stringToBytes(cipherText); plainText = decryptText(cipherBytes); return plainText; } public static void main(String[] args) { BlowfishAlgorithm blowfishAlgorithm = new BlowfishAlgorithm(); String textToEncrypt = \u0026#34;Blowfish Algorithm\u0026#34;; System.out.println(\u0026#34;Text before Encryption: \u0026#34; + textToEncrypt); String cipherText = blowfishAlgorithm.encrypt(textToEncrypt); System.out.println(\u0026#34;Cipher Text: \u0026#34; + cipherText); System.out.println(\u0026#34;Text after Decryption: \u0026#34; + blowfishAlgorithm.decrypt(cipherText)); } /** * * @param rawText * @return plainText * * Perform Base64 encoding */ private String bytesToString(byte[] rawText) { String plainText = null; plainText = Base64.encode(rawText); return plainText; } /** * * @param plainText * @return rawText * * Perform Base64 decoding */ private byte[] stringToBytes(String plainText) { byte[] rawText = null; try { rawText = Base64.decode(plainText); } catch (Base64DecodingException ex) { System.out.println(ex); } return rawText; } } Output:\nText before Encryption: Blowfish Algorithm Cipher Text: tsNKEZdUIivNDDN287v9NIl8vCHTPrlT Text after Decryption: Blowfish Algorithm  ",
    "ref": "/blog/2013-08-11-java-blowfish-encryption-algorithm/"
  },{
    "title": "Java - Advanced Encryption Standard (AES) Algorithm",
    "date": "August 11, 2013",
    "description": "",
    "body": "AESAlgorithm.java\npackage com.java.aes; import com.sun.org.apache.xml.internal.security.exceptions.Base64DecodingException; import com.sun.org.apache.xml.internal.security.utils.Base64; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.IllegalBlockSizeException; import javax.crypto.KeyGenerator; import javax.crypto.NoSuchPaddingException; import javax.crypto.SecretKey; /** * * @author dhanoopbhaskar */ public class AESAlgorithm { KeyGenerator keyGenerator = null; SecretKey secretKey = null; Cipher cipher = null; public AESAlgorithm() { try { /** * Create a AES key */ keyGenerator = KeyGenerator.getInstance(\u0026#34;AES\u0026#34;); secretKey = keyGenerator.generateKey(); /** * Create an instance of cipher providing the following info * separated by slash. * * - Algorithm name * - Mode (optional) * - Padding scheme (optional) * * NB: * AES = Advanced Encryption Standard. * ECB = Electronic Codebook mode. * PKCS5Padding = PKCS #5-style padding. */ cipher = Cipher.getInstance(\u0026#34;AES/ECB/PKCS5Padding\u0026#34;); } catch (NoSuchPaddingException ex) { System.out.println(ex); } catch (NoSuchAlgorithmException ex) { System.out.println(ex); } } /** * * @param plainText * @return cipherBytes */ public byte[] encryptText(String plainText) { byte[] cipherBytes = null; try { /** * Initialize the cipher for encryption */ cipher.init(Cipher.ENCRYPT_MODE, secretKey); /** * Convert the text string to byte format */ byte[] plainBytes = plainText.getBytes(); /** * Perform encryption with method doFinal() */ cipherBytes = cipher.doFinal(plainBytes); } catch (IllegalBlockSizeException ex) { System.out.println(ex); } catch (BadPaddingException ex) { System.out.println(ex); } catch (InvalidKeyException ex) { System.out.println(ex); } return cipherBytes; } /** * * @param cipherBytes * @return plainText */ public String decryptText(byte[] cipherBytes) { String plainText = null; try { /** * Initialize the cipher for decryption */ cipher.init(Cipher.DECRYPT_MODE, secretKey); /** * Perform decryption with method doFinal() */ byte[] plainBytes = cipher.doFinal(cipherBytes); /** * Convert encrypted text to string format */ plainText = new String(plainBytes); } catch (IllegalBlockSizeException ex) { System.out.println(ex); } catch (BadPaddingException ex) { System.out.println(ex); } catch (InvalidKeyException ex) { System.out.println(ex); } return plainText; } /** * * @param plainText * @return cipherText */ public String encrypt(String plainText) { String cipherText = null; byte[] cipherBytes = encryptText(plainText); cipherText = bytesToString(cipherBytes); return cipherText; } /** * * @param cipherText * @return plainText */ public String decrypt(String cipherText) { String plainText = null; byte[] cipherBytes = stringToBytes(cipherText); plainText = decryptText(cipherBytes); return plainText; } public static void main(String[] args) { AESAlgorithm desAlgorithm = new AESAlgorithm(); String textToEncrypt = \u0026#34;AES Algorithm\u0026#34;; System.out.println(\u0026#34;Text before Encryption: \u0026#34; + textToEncrypt); String cipherText = desAlgorithm.encrypt(textToEncrypt); System.out.println(\u0026#34;Cipher Text: \u0026#34; + cipherText); System.out.println(\u0026#34;Text after Decryption: \u0026#34; + desAlgorithm.decrypt(cipherText)); } /** * * @param rawText * @return plainText * * Perform Base64 encoding */ private String bytesToString(byte[] rawText) { String plainText = null; plainText = Base64.encode(rawText); return plainText; } /** * * @param plainText * @return rawText * * Perform Base64 decoding */ private byte[] stringToBytes(String plainText) { byte[] rawText = null; try { rawText = Base64.decode(plainText); } catch (Base64DecodingException ex) { System.out.println(ex); } return rawText; } } Output:Â Text before Encryption: AES AlgorithmÂ Cipher Text: rqDMYCW17enP8S7sio3Kbg==Â Text after Decryption: AES Algorithm  ",
    "ref": "/blog/2013-08-11-java-advanced-encryption-standard-aes-algorithm/"
  },{
    "title": "Java - JButton in a JTable cell",
    "date": "August 3, 2013",
    "description": "",
    "body": "Now we shall discuss how to include a JButton in a table cell.\nButtonJTable.java\n/* * ButtonJTable.java * * Created on Aug 3, 2013, 02:57:58 PM */ package me.dhanoop.forblog; import java.awt.Component; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import javax.swing.JButton; import javax.swing.JCheckBox; import javax.swing.JFrame; import javax.swing.JOptionPane; import javax.swing.JTable; import javax.swing.UIManager; import javax.swing.table.DefaultTableModel; import javax.swing.table.TableCellRenderer; /** * * @author dhanoopbhaskar */ public class ButtonJTable extends javax.swing.JFrame { private JButton tableData = null; /** Creates new form ButtonJTable */ public ButtonJTable() { initComponents(); customizeTable(); } /** This method is called from within the constructor to * initialize the form. * WARNING: Do NOT modify this code. The content of this method is * always regenerated by the Form Editor. */ @SuppressWarnings(\u0026#34;unchecked\u0026#34;) //  private void initComponents() { dbScrollPane = new javax.swing.JScrollPane(); dbTable = new javax.swing.JTable(); setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE); dbTable.setModel(new javax.swing.table.DefaultTableModel( new Object [][] { }, new String [] { \u0026#34;Title 1\u0026#34; } )); dbScrollPane.setViewportView(dbTable); javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane()); getContentPane().setLayout(layout); layout.setHorizontalGroup( layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING) .addComponent(dbScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 226, javax.swing.GroupLayout.PREFERRED_SIZE) ); layout.setVerticalGroup( layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING) .addComponent(dbScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 81, javax.swing.GroupLayout.PREFERRED_SIZE) ); pack(); }//  /** * @param args the command line arguments */ public static void main(String args[]) { java.awt.EventQueue.invokeLater(new Runnable() { public void run() { new ButtonJTable().setVisible(true); } }); } // Variables declaration - do not modify  private javax.swing.JScrollPane dbScrollPane; private javax.swing.JTable dbTable; // End of variables declaration  private void customizeTable() { Object[] columnNames = new Object[1]; columnNames[0] = \u0026#34;Button\u0026#34;; String buttonString = \u0026#34;Click Me\u0026#34;; Object[][] rowData = new Object[1][1]; rowData[0][0] = buttonString; DefaultTableModel tableModel = new DBTableModel(rowData, columnNames); dbTable.setModel(tableModel); tableData = new JButton(buttonString); tableData.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { JOptionPane.showMessageDialog(new JFrame(), \u0026#34;I\u0026#39;m clicked!\u0026#34;, \u0026#34;ButtonJTable\u0026#34;, JOptionPane.INFORMATION_MESSAGE); } }); dbTable.getColumnModel().getColumn(0).setCellEditor(new ButtonCellEditor(new JCheckBox())); dbTable.getColumnModel().getColumn(0).setCellRenderer(new TableCellRenderer() { public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) { if (isSelected) { setForeground(table.getSelectionForeground()); setBackground(table.getSelectionBackground()); } else { setForeground(table.getForeground()); setBackground(UIManager.getColor(\u0026#34;Button.background\u0026#34;)); } tableData.setText((value == null) ? \u0026#34;\u0026#34; : value.toString()); return tableData; } }); dbTable.updateUI(); } } DBTableModel.java\npackage me.dhanoop.forblog; import javax.swing.table.DefaultTableModel; /** * * @author dhanoopbhaskar */ public class DBTableModel extends DefaultTableModel { public DBTableModel(Object[] columns) { super(columns, 0); } public DBTableModel(Object[][] data, Object[] columns) { super(data, columns); } @Override public boolean isCellEditable(int row, int column) { return true; } } The following is the key snippet in the program.\nHere we do mainly two things:\n  Changing the CellEditor of the ColumnModel of the column at position 0 (zero) of the table.\n  Changing the CellRenderer of the ColumnModel of the column at position 0 (zero) of the table.Â   Unlike JComboBox and JCheckBox, for JButton we don\u0026rsquo;t have a suitable constructor.Â public javax.swing.DefaultCellEditor(javax.swing.JTextField);Â public javax.swing.DefaultCellEditor(javax.swing.JCheckBox); public javax.swing.DefaultCellEditor(javax.swing.JComboBox); The above are the ONLY available constructors for DefaultCellEditor. Hence we have to create fully customized DefaultCellEditor for JButton.\nprivate void customizeTable() { Object[] columnNames = new Object[1]; columnNames[0] = \u0026#34;Button\u0026#34;; String buttonString = \u0026#34;Click Me\u0026#34;; Object[][] rowData = new Object[1][1]; rowData[0][0] = buttonString; DefaultTableModel tableModel = new DBTableModel(rowData, columnNames); dbTable.setModel(tableModel); tableData = new JButton(buttonString); tableData.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { JOptionPane.showMessageDialog(new JFrame(), \u0026#34;I\u0026#39;m clicked!\u0026#34;, \u0026#34;ButtonJTable\u0026#34;, JOptionPane.INFORMATION_MESSAGE); } }); dbTable.getColumnModel().getColumn(0).setCellEditor(new ButtonCellEditor(new JCheckBox())); dbTable.getColumnModel().getColumn(0).setCellRenderer(new TableCellRenderer() { public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) { if (isSelected) { setForeground(table.getSelectionForeground()); setBackground(table.getSelectionBackground()); } else { setForeground(table.getForeground()); setBackground(UIManager.getColor(\u0026#34;Button.background\u0026#34;)); } tableData.setText((value == null) ? \u0026#34;\u0026#34; : value.toString()); return tableData; } }); dbTable.updateUI(); } Please find below an example of such a customized DefaultCellEditor\nButtonCellEditor.java\npackage me.dhanoop.forblog; import java.awt.Component; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import javax.swing.DefaultCellEditor; import javax.swing.JButton; import javax.swing.JCheckBox; import javax.swing.JOptionPane; import javax.swing.JTable; /** * * @author dhanoopbhaskar */ public class ButtonCellEditor extends DefaultCellEditor { private JButton button = null; private String buttonText = null; private boolean isClicked; public ButtonCellEditor(JCheckBox checkBox) { super(checkBox); button = new JButton(); button.setOpaque(true); button.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { fireEditingStopped(); } }); } @Override public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column) { if (isSelected) { button.setForeground(table.getSelectionForeground()); button.setBackground(table.getSelectionBackground()); } else { button.setForeground(table.getForeground()); button.setBackground(table.getBackground()); } buttonText = (value == null) ? \u0026#34;\u0026#34; : value.toString(); button.setText(buttonText); isClicked = true; return button; } @Override public Object getCellEditorValue() { if (isClicked) { JOptionPane.showMessageDialog(button, \u0026#34;I\u0026#39;m clicked!\u0026#34;, \u0026#34;ButtonJTable\u0026#34;, JOptionPane.INFORMATION_MESSAGE); } isClicked = false; return buttonText; } @Override public boolean stopCellEditing() { isClicked = false; return super.stopCellEditing(); } @Override protected void fireEditingStopped() { super.fireEditingStopped(); } } \n\n",
    "ref": "/blog/2013-08-03-java-jbutton-in-a-jtable-cell/"
  },{
    "title": "Java - JCheckBox in a JTable cell",
    "date": "August 3, 2013",
    "description": "",
    "body": "Now we shall discuss how to include a JCheckBox in a table cell.\nCheckBoxJFrame.java\n/** * CheckBoxJFrame.java * * Created on Aug 2, 2013, 11:57:36 PM */ package me.dhanoop.forblog; import java.awt.Component; import java.awt.event.ItemEvent; import java.awt.event.ItemListener; import javax.swing.DefaultCellEditor; import javax.swing.JCheckBox; import javax.swing.JFrame; import javax.swing.JOptionPane; import javax.swing.JTable; import javax.swing.table.DefaultTableModel; import javax.swing.table.TableCellRenderer; /** * * @author dhanoopbhaskar */ public class CheckBoxJFrame extends javax.swing.JFrame { private JCheckBox tableData = null; /** Creates new form CheckBoxJFrame */ public CheckBoxJFrame() { initComponents(); customizeTable(); } /** This method is called from within the constructor to * initialize the form. * WARNING: Do NOT modify this code. The content of this method is * always regenerated by the Form Editor. */ @SuppressWarnings(\u0026#34;unchecked\u0026#34;) //  private void initComponents() { dbScrollPane = new javax.swing.JScrollPane(); dbTable = new javax.swing.JTable(); setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE); dbTable.setModel(new javax.swing.table.DefaultTableModel( new Object [][] { }, new String [] { \u0026#34;Title 1\u0026#34; } )); dbScrollPane.setViewportView(dbTable); javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane()); getContentPane().setLayout(layout); layout.setHorizontalGroup( layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING) .addComponent(dbScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 226, javax.swing.GroupLayout.PREFERRED_SIZE) ); layout.setVerticalGroup( layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING) .addComponent(dbScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 81, javax.swing.GroupLayout.PREFERRED_SIZE) ); pack(); }//  /** * @param args the command line arguments */ public static void main(String args[]) { java.awt.EventQueue.invokeLater(new Runnable() { public void run() { new CheckBoxJFrame().setVisible(true); } }); } // Variables declaration - do not modify  private javax.swing.JScrollPane dbScrollPane; private javax.swing.JTable dbTable; // End of variables declaration  private void customizeTable() { Object[] columnNames = new Object[1]; columnNames[0] = \u0026#34;CheckBox\u0026#34;; String checkString = \u0026#34;Gate Qualified?\u0026#34;; Object[][] rowData = new Object[1][1]; rowData[0][0] = checkString; DefaultTableModel tableModel = new DBTableModel(rowData, columnNames); dbTable.setModel(tableModel); tableData = new JCheckBox(checkString); tableData.setSelected(false); tableData.addItemListener(new ItemListener() { public void itemStateChanged(ItemEvent e) { String result = \u0026#34;\u0026#34;; if (tableData.isSelected()) { result = \u0026#34;YES\u0026#34;; } else { result = \u0026#34;NO\u0026#34;; } JOptionPane.showMessageDialog(new JFrame(), result, \u0026#34;Gate Qualified?\u0026#34;, JOptionPane.INFORMATION_MESSAGE); } }); dbTable.getColumnModel().getColumn(0).setCellEditor(new DefaultCellEditor(tableData)); dbTable.getColumnModel().getColumn(0).setCellRenderer(new TableCellRenderer() { public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) { return tableData; } }); dbTable.updateUI(); } } DBTableModel.java\npackage me.dhanoop.forblog; import javax.swing.table.DefaultTableModel; /** * * @author dhanoopbhaskar */ public class DBTableModel extends DefaultTableModel { public DBTableModel(Object[] columns) { super(columns, 0); } public DBTableModel(Object[][] data, Object[] columns) { super(data, columns); } @Override public boolean isCellEditable(int row, int column) { return true; } } The following is the key snippet in the program. Here we do mainly two things:\n  Changing the CellEditor of the ColumnModel of the column at position 0 (zero) of the table\n  Changing the CellRenderer of the ColumnModel of the column at position 0 (zero) of the table.\n  private void customizeTable() { Object[] columnNames = new Object[1]; columnNames[0] = \u0026#34;CheckBox\u0026#34;; String checkString = \u0026#34;Gate Qualified?\u0026#34;; Object[][] rowData = new Object[1][1]; rowData[0][0] = checkString; DefaultTableModel tableModel = new DBTableModel(rowData, columnNames); dbTable.setModel(tableModel); tableData = new JCheckBox(checkString); tableData.setSelected(false); tableData.addItemListener(new ItemListener() { public void itemStateChanged(ItemEvent e) { String result = \u0026#34;\u0026#34;; if (tableData.isSelected()) { result = \u0026#34;YES\u0026#34;; } else { result = \u0026#34;NO\u0026#34;; } JOptionPane.showMessageDialog(new JFrame(), result, \u0026#34;Gate Qualified?\u0026#34;, JOptionPane.INFORMATION_MESSAGE); } }); dbTable.getColumnModel().getColumn(0).setCellEditor(new DefaultCellEditor(tableData)); dbTable.getColumnModel().getColumn(0).setCellRenderer(new TableCellRenderer() { public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) { return tableData; } }); dbTable.updateUI(); }  \n\n\n",
    "ref": "/blog/2013-08-03-java-jcheckbox-in-a-jtable-cell/"
  },{
    "title": "Java - JComboBox in a JTable cell (with event handling)",
    "date": "August 3, 2013",
    "description": "",
    "body": "Please refer to the previous post here\u0026hellip;\nThe function customizeTable() has been modified in order to include event handling functionality in the combo box.\nprivate void customizeTable() { Object[] columnNames = new Object[1]; columnNames[0] = \u0026#34;ComboBox\u0026#34;; Object[][] rowData = new Object[1][1]; rowData[0][0] = \u0026#34;select gender\u0026#34;; DefaultTableModel tableModel = new DBTableModel(rowData, columnNames); dbTable.setModel(tableModel); String[] gender = {\u0026#34;Male\u0026#34;, \u0026#34;Female\u0026#34;}; tableData = new JComboBox(gender); tableData.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { String item = (String) tableData.getSelectedItem(); JOptionPane.showMessageDialog(new JFrame(), item, \u0026#34;Selected Item\u0026#34;, JOptionPane.INFORMATION_MESSAGE); } }); dbTable.getColumnModel().getColumn(0).setCellEditor(new DefaultCellEditor(tableData)); dbTable.updateUI(); }  For the JComboBox tableData to be accessible in the inner class\u0026rsquo; method actionPerformed(), it should be declared in class level as below. (In the previous post, it\u0026rsquo;s declared locally).\npublic class MainJFrame extends javax.swing.JFrame { private JComboBox tableData = null; . . .  \n\n",
    "ref": "/blog/2013-08-03-java-jcombobox-in-a-jtable-cell-with-event-handling/"
  },{
    "title": "Java - JComboBox in a JTable cell",
    "date": "August 3, 2013",
    "description": "",
    "body": "MainJFrame.java\n/** * MainJFrame.java * * Created on Aug 2, 2013, 11:57:36 PM */ package me.dhanoop.forblog; import javax.swing.DefaultCellEditor; import javax.swing.JComboBox; import javax.swing.table.DefaultTableModel; import javax.swing.table.TableCellEditor; /** * * @author dhanoopbhaskar */ public class MainJFrame extends javax.swing.JFrame { /** Creates new form MainJFrame */ public MainJFrame() { initComponents(); customizeTable(); } /** This method is called from within the constructor to * initialize the form. * WARNING: Do NOT modify this code. The content of this method is * always regenerated by the Form Editor. */ @SuppressWarnings(\u0026#34;unchecked\u0026#34;) //  private void initComponents() { dbScrollPane = new javax.swing.JScrollPane(); dbTable = new javax.swing.JTable(); setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE); dbTable.setModel(new javax.swing.table.DefaultTableModel( new Object [][] { }, new String [] { \u0026#34;Title 1\u0026#34; } )); dbScrollPane.setViewportView(dbTable); javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane()); getContentPane().setLayout(layout); layout.setHorizontalGroup( layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING) .addComponent(dbScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 169, javax.swing.GroupLayout.PREFERRED_SIZE) ); layout.setVerticalGroup( layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING) .addComponent(dbScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 81, javax.swing.GroupLayout.PREFERRED_SIZE) ); pack(); }//  /** * @param args the command line arguments */ public static void main(String args[]) { java.awt.EventQueue.invokeLater(new Runnable() { public void run() { new MainJFrame().setVisible(true); } }); } // Variables declaration - do not modify  private javax.swing.JScrollPane dbScrollPane; private javax.swing.JTable dbTable; // End of variables declaration  private void customizeTable() { Object[] columnNames = new Object[1]; columnNames[0] = \u0026#34;ComboBox\u0026#34;; Object[][] rowData = new Object[1][1]; rowData[0][0] = \u0026#34;select gender\u0026#34;; DefaultTableModel tableModel = new DBTableModel(rowData, columnNames); dbTable.setModel(tableModel); String[] gender = {\u0026#34;Male\u0026#34;, \u0026#34;Female\u0026#34;}; JComboBox tableData = new JComboBox(gender); dbTable.getColumnModel().getColumn(0).setCellEditor(new DefaultCellEditor(tableData)); dbTable.updateUI(); } } DBTableModel.java\npackage me.dhanoop.forblog; import javax.swing.table.DefaultTableModel; /** * * @author dhanoopbhaskar */ public class DBTableModel extends DefaultTableModel { public DBTableModel(Object[] columns) { super(columns, 0); } public DBTableModel(Object[][] data, Object[] columns) { super(data, columns); } @Override public boolean isCellEditable(int row, int column) { return true; } } The following is the key snippet in the program. What we do here is simply changing the CellEditor of the ColumnModel of the column at position 0 (zero) of the table.\nprivate void customizeTable() { Object[] columnNames = new Object[1]; columnNames[0] = \u0026#34;ComboBox\u0026#34;; Object[][] rowData = new Object[1][1]; rowData[0][0] = \u0026#34;select gender\u0026#34;; DefaultTableModel tableModel = new DBTableModel(rowData, columnNames); dbTable.setModel(tableModel); String[] gender = {\u0026#34;Male\u0026#34;, \u0026#34;Female\u0026#34;}; JComboBox tableData = new JComboBox(gender); dbTable.getColumnModel().getColumn(0).setCellEditor(new DefaultCellEditor(tableData)); dbTable.updateUI(); } Here we use the following constructor of the class DefaultCellEditor.\npublic javax.swing.DefaultCellEditor(javax.swing.JComboBox); \n\nIn the next post we shall discuss on handling of various events in such combo boxes which are added to the table.\n",
    "ref": "/blog/2013-08-03-java-jcombobox-in-a-jtable-cell/"
  },{
    "title": "Contact",
    "date": "January 1, 0001",
    "description": "",
    "body": "",
    "ref": "/contact/"
  }]
